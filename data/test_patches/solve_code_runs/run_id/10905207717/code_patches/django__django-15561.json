{
  "instance_id": "django__django-15561",
  "edit_test_file": null,
  "code_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex b3a2f42..40ffbd3 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -121,38 +121,41 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             super().alter_db_table(model, old_db_table, new_db_table)\n \n     def alter_field(self, model, old_field, new_field, strict=False):\n-        if not self._field_should_be_altered(old_field, new_field):\n-            return\n-        old_field_name = old_field.name\n-        table_name = model._meta.db_table\n-        _, old_column_name = old_field.get_attname_column()\n-        if (\n-            new_field.name != old_field_name\n-            and not self.connection.features.supports_atomic_references_rename\n-            and self._is_referenced_by_fk_constraint(\n-                table_name, old_column_name, ignore_self=True\n-            )\n-        ):\n-            if self.connection.in_atomic_block:\n-                raise NotSupportedError(\n-                    (\n-                        \"Renaming the %r.%r column while in a transaction is not \"\n-                        \"supported on SQLite < 3.26 because it would break referential \"\n-                        \"integrity. Try adding `atomic = False` to the Migration class.\"\n-                    )\n-                    % (model._meta.db_table, old_field_name)\n+            if not self._field_should_be_altered(old_field, new_field):\n+                return\n+            # Check for non-schema-affecting changes like \"choices\"\n+            if self._non_schema_affecting_change(old_field, new_field):\n+                return\n+            old_field_name = old_field.name\n+            table_name = model._meta.db_table\n+            _, old_column_name = old_field.get_attname_column()\n+            if (\n+                new_field.name != old_field_name\n+                and not self.connection.features.supports_atomic_references_rename\n+                and self._is_referenced_by_fk_constraint(\n+                    table_name, old_column_name, ignore_self=True\n                 )\n-            with atomic(self.connection.alias):\n-                super().alter_field(model, old_field, new_field, strict=strict)\n-                # Follow SQLite's documented procedure for performing changes\n-                # that don't affect the on-disk content.\n-                # https://sqlite.org/lang_altertable.html#otheralter\n-                with self.connection.cursor() as cursor:\n-                    schema_version = cursor.execute(\"PRAGMA schema_version\").fetchone()[\n-                        0\n-                    ]\n-                    cursor.execute(\"PRAGMA writable_schema = 1\")\n-                    references_template = ' REFERENCES \"%s\" (\"%%s\") ' % table_name\n+            ):\n+                if self.connection.in_atomic_block:\n+                    raise NotSupportedError(\n+                        (\n+                            \"Renaming the %r.%r column while in a transaction is not \"\n+                            \"supported on SQLite < 3.26 because it would break referential \"\n+                            \"integrity. Try adding `atomic = False` to the Migration class.\"\n+                        )\n+                        % (model._meta.db_table, old_field_name)\n+                    )\n+                with atomic(self.connection.alias):\n+                    super().alter_field(model, old_field, new_field, strict=strict)\n+                    # Follow SQLite's documented procedure for performing changes\n+                    # that don't affect the on-disk content.\n+                    # https://sqlite.org/lang_altertable.html#otheralter\n+                    with self.connection.cursor() as cursor:\n+                        schema_version = cursor.execute(\"PRAGMA schema_version\").fetchone()[\n+                            0\n+                        ]\n+                        cursor.execute(\"PRAGMA writable_schema = 1\")\n+                        references_template = ' REFERENCES \"%s\" (\"%%s\") ' % table_name\n                     new_column_name = new_field.get_attname_column()[1]\n                     search = references_template % old_column_name\n                     replacement = references_template % new_column_name\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 730958,
  "num_received_chars": 8595,
  "elapsed_time": 121.70020937919617,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}