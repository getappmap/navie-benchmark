{
  "instance_id": "pytest-dev__pytest-10356",
  "edit_test_file": "testing/test_compat.py",
  "code_patch": "diff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex cfb9b5a..69e0a46 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -137,7 +137,14 @@ class NodeMeta(type):\n \n     def _create(self, *k, **kw):\n         try:\n-            return super().__call__(*k, **kw)\n+            instance = super().__call__(*k, **kw)\n+            # Consolidate markers from the entire MRO chain\n+            all_markers = set()\n+            for base in instance.__class__.mro():\n+                if hasattr(base, '_pytestmark'):\n+                    all_markers.update(base._pytestmark)\n+            instance._pytestmark = list(all_markers)\n+            return instance\n         except TypeError:\n             sig = signature(getattr(self, \"__init__\"))\n             known_kw = {k: v for k, v in kw.items() if k in sig.parameters}\n",
  "test_patch": "diff --git a/testing/test_inheritance_markers.py b/testing/test_inheritance_markers.py\nnew file mode 100644\nindex 0000000..27da3fa\n--- /dev/null\n+++ b/testing/test_inheritance_markers.py\n@@ -0,0 +1,31 @@\n+import pytest\n+import itertools\n+\n+class BaseMeta(type):\n+    @property\n+    def pytestmark(self):\n+        return (\n+            getattr(self, \"_pytestmark\", []) +\n+            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\n+        )\n+\n+    @pytestmark.setter\n+    def pytestmark(self, value):\n+        self._pytestmark = value\n+\n+\n+class Base(object, metaclass=BaseMeta):\n+    pass\n+\n+@pytest.mark.foo\n+class Foo(Base):\n+    pass\n+\n+@pytest.mark.bar\n+class Bar(Base):\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        markers = {mark.name for mark in self.__class__.pytestmark}\n+        assert markers == {\"foo\", \"bar\"}, f\"Expected markers 'foo' and 'bar', but got {markers}\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/testing/test_inheritance_markers_inverted.py b/testing/test_inheritance_markers_inverted.py\nnew file mode 100644\nindex 0000000..f7a3413\n--- /dev/null\n+++ b/testing/test_inheritance_markers_inverted.py\n@@ -0,0 +1,32 @@\n+import pytest\n+import itertools\n+\n+class BaseMeta(type):\n+    @property\n+    def pytestmark(self):\n+        return (\n+            getattr(self, \"_pytestmark\", []) +\n+            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\n+        )\n+\n+    @pytestmark.setter\n+    def pytestmark(self, value):\n+        self._pytestmark = value\n+\n+\n+class Base(object, metaclass=BaseMeta):\n+    pass\n+\n+@pytest.mark.foo\n+class Foo(Base):\n+    pass\n+\n+@pytest.mark.bar\n+class Bar(Base):\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        markers = {mark.name for mark in self.__class__.pytestmark}\n+        # Altered the assertion to fail when the issue is observed\n+        assert markers != {\"foo\", \"bar\"}, \"__BUG__HERE__\"\n\\ No newline at end of file\n",
  "num_sent_chars": 3920808,
  "num_received_chars": 69165,
  "elapsed_time": 1452.2653801441193,
  "lint_repair_count": 7,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}