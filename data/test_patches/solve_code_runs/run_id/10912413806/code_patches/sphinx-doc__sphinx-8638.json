{
  "instance_id": "sphinx-doc__sphinx-8638",
  "edit_test_file": "tests/test_ext_autodoc_autoclass.py",
  "code_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f66852a..2c9b864 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -681,6 +681,13 @@ class Documenter:\n \n             return False\n \n+        def is_unrelated_variable(name: str, obj: Any) -> bool:\n+            # Check if the variable is unrelated by ensuring it is not in the current class\n+            if inspect.isclass(self.object):\n+                if name not in self.object.__dict__:\n+                    return True\n+            return False\n+\n         ret = []\n \n         # search for members in source code too\n@@ -768,6 +775,9 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            elif is_unrelated_variable(membername, obj):\n+                # skip unrelated variables\n+                keep = False\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n",
  "test_patch": "diff --git a/tests/test_variable_link_resolution.py b/tests/test_variable_link_resolution.py\nnew file mode 100644\nindex 0000000..8a4d412\n--- /dev/null\n+++ b/tests/test_variable_link_resolution.py\n@@ -0,0 +1,40 @@\n+import pytest\n+from .test_ext_autodoc import do_autodoc\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_variable_link_resolution(app):\n+    # This test is designed to reproduce the issue where instance variables\n+    # link to other variables of the same name in the project.\n+    options = {'members': True, 'inherited-members': True}\n+    actual = do_autodoc(app, 'class', 'target.instance_variable.Bar', options)\n+    \n+    # Check if the output incorrectly links to other variables of the same name\n+    # The expected output should not contain any links to unrelated variables\n+    expected_output = [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.instance_variable',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring foo',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr3',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+    ]\n+    \n+    # Assert that the actual output matches the expected output\n+    # If the issue is present, this assertion will fail\n+    assert list(actual) == expected_output\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_variable_link_resolution_inverted.py b/tests/test_variable_link_resolution_inverted.py\nnew file mode 100644\nindex 0000000..352fc86\n--- /dev/null\n+++ b/tests/test_variable_link_resolution_inverted.py\n@@ -0,0 +1,41 @@\n+import pytest\n+from .test_ext_autodoc import do_autodoc\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_variable_link_resolution(app):\n+    # This test is designed to reproduce the issue where instance variables\n+    # link to other variables of the same name in the project.\n+    options = {'members': True, 'inherited-members': True}\n+    actual = do_autodoc(app, 'class', 'target.instance_variable.Bar', options)\n+    \n+    # Check if the output incorrectly links to other variables of the same name\n+    # The expected output should not contain any links to unrelated variables\n+    expected_output = [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.instance_variable',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring foo',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr3',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+    ]\n+    \n+    # Assert that the actual output does not match the expected output\n+    # If the issue is present, this assertion will fail with the specified error message\n+    if list(actual) == expected_output:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1713829,
  "num_received_chars": 75609,
  "elapsed_time": 760.8865468502045,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}