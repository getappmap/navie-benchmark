{
  "instance_id": "django__django-14155",
  "edit_test_file": "tests/requests/test_accept_header.py",
  "code_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24..9413e4d 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,22 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+        if isinstance(func, functools.partial):\n+            # Unwrap functools.partial to get the base function and its arguments\n+            self._base_func = func.func\n+            self._partial_args = func.args\n+            self._partial_kwargs = func.keywords\n+        else:\n+            self._base_func = func\n+            self._partial_args = ()\n+            self._partial_kwargs = {}\n+\n+        if not hasattr(self._base_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = self._base_func.__class__.__module__ + '.' + self._base_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = self._base_func.__module__ + '.' + self._base_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\n@@ -59,6 +69,11 @@ class ResolverMatch:\n         return (self.func, self.args, self.kwargs)[index]\n \n     def __repr__(self):\n+        if self._partial_args or self._partial_kwargs:\n+            return \"ResolverMatch(func=%s, partial_args=%s, partial_kwargs=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n+                self._func_path, self._partial_args, self._partial_kwargs, self.args, self.kwargs, self.url_name,\n+                self.app_names, self.namespaces, self.route,\n+            )\n         return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n             self._func_path, self.args, self.kwargs, self.url_name,\n             self.app_names, self.namespaces, self.route,\n",
  "test_patch": "diff --git a/tests/requests/test_resolvermatch_repr_partial.py b/tests/requests/test_resolvermatch_repr_partial.py\nnew file mode 100644\nindex 0000000..dc8ed14\n--- /dev/null\n+++ b/tests/requests/test_resolvermatch_repr_partial.py\n@@ -0,0 +1,21 @@\n+import unittest\n+import functools\n+from django.urls.resolvers import ResolverMatch\n+\n+def dummy_view():\n+    pass\n+\n+class TestResolverMatchReprPartial(unittest.TestCase):\n+    def test_resolvermatch_repr_with_partial(self):\n+        # Create a partial function\n+        partial_view = functools.partial(dummy_view, arg1='value1', arg2='value2')\n+        \n+        # Create a ResolverMatch object with the partial function\n+        resolver_match = ResolverMatch(partial_view, args=(), kwargs={}, url_name=None, app_names=[], namespaces=[], route='')\n+\n+        # Check the __repr__ output\n+        expected_repr = \"ResolverMatch(func=functools.partial, args=(), kwargs={}, url_name=None, app_names=[], namespaces=[], route=)\"\n+        self.assertEqual(repr(resolver_match), expected_repr)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/requests/test_resolvermatch_repr_partial_inverted.py b/tests/requests/test_resolvermatch_repr_partial_inverted.py\nnew file mode 100644\nindex 0000000..8255200\n--- /dev/null\n+++ b/tests/requests/test_resolvermatch_repr_partial_inverted.py\n@@ -0,0 +1,26 @@\n+import unittest\n+import functools\n+from django.urls.resolvers import ResolverMatch\n+\n+def dummy_view():\n+    pass\n+\n+class TestResolverMatchReprPartial(unittest.TestCase):\n+    def test_resolvermatch_repr_with_partial(self):\n+        # Create a partial function\n+        partial_view = functools.partial(dummy_view, arg1='value1', arg2='value2')\n+        \n+        # Create a ResolverMatch object with the partial function\n+        resolver_match = ResolverMatch(partial_view, args=(), kwargs={}, url_name=None, app_names=[], namespaces=[], route='')\n+        \n+        # Check the __repr__ output\n+        expected_repr = \"ResolverMatch(func=functools.partial, args=(), kwargs={}, url_name=None, app_names=[], namespaces=[], route=)\"\n+        \n+        # Alter the test to fail when the issue is observed\n+        actual_repr = repr(resolver_match)\n+        if actual_repr == expected_repr:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        self.assertNotEqual(actual_repr, expected_repr)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 144326,
  "num_received_chars": 6086,
  "elapsed_time": 59.71418213844299,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": null
}