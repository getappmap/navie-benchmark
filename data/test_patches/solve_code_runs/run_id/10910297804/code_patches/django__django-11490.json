{
  "instance_id": "django__django-11490",
  "edit_test_file": "tests/queries/test_qs_combinators.py",
  "code_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb..1ad3dce 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -125,6 +125,8 @@ class ValuesListIterable(BaseIterable):\n     def __iter__(self):\n         queryset = self.queryset\n         query = queryset.query\n+        # Ensure the fields are reset for each iteration\n+        queryset._fields = None\n         compiler = query.get_compiler(queryset.db)\n \n         if queryset._fields:\n@@ -798,27 +800,29 @@ class QuerySet:\n         return clone\n \n     def values_list(self, *fields, flat=False, named=False):\n-        if flat and named:\n-            raise TypeError(\"'flat' and 'named' can't be used together.\")\n-        if flat and len(fields) > 1:\n-            raise TypeError(\"'flat' is not valid when values_list is called with more than one field.\")\n-\n-        field_names = {f for f in fields if not hasattr(f, 'resolve_expression')}\n-        _fields = []\n-        expressions = {}\n-        counter = 1\n-        for field in fields:\n-            if hasattr(field, 'resolve_expression'):\n-                field_id_prefix = getattr(field, 'default_alias', field.__class__.__name__.lower())\n-                while True:\n-                    field_id = field_id_prefix + str(counter)\n-                    counter += 1\n-                    if field_id not in field_names:\n-                        break\n-                expressions[field_id] = field\n-                _fields.append(field_id)\n-            else:\n-                _fields.append(field)\n+            if flat and named:\n+                raise TypeError(\"'flat' and 'named' can't be used together.\")\n+            if flat and len(fields) > 1:\n+                raise TypeError(\"'flat' is not valid when values_list is called with more than one field.\")\n+    \n+            field_names = {f for f in fields if not hasattr(f, 'resolve_expression')}\n+            _fields = []\n+            expressions = {}\n+            counter = 1\n+            for field in fields:\n+                if hasattr(field, 'resolve_expression'):\n+                    field_id_prefix = getattr(field, 'default_alias', field.__class__.__name__.lower())\n+                    while True:\n+                        field_id = field_id_prefix + str(counter)\n+                        counter += 1\n+                        if field_id not in field_names:\n+                            break\n+                    expressions[field_id] = field\n+                    _fields.append(field_id)\n+                else:\n+                    _fields.append(field)\n+            # Reset the fields to ensure dynamic column list\n+            self._fields = None\n \n         clone = self._values(*_fields, **expressions)\n         clone._iterable_class = (\n",
  "test_patch": "diff --git a/tests/queries/test_values_list_issue.py b/tests/queries/test_values_list_issue.py\nnew file mode 100644\nindex 0000000..c4ea759\n--- /dev/null\n+++ b/tests/queries/test_values_list_issue.py\n@@ -0,0 +1,15 @@\n+from django.test import TestCase\n+from .models import ReservedName\n+\n+class TestValuesListIssue(TestCase):\n+    def test_composed_queries_values_list_issue(self):\n+        ReservedName.objects.create(name='a', order=2)\n+        qs1 = ReservedName.objects.all()\n+        \n+        # First evaluation with 'name' and 'order'\n+        result1 = qs1.union(qs1).values_list('name', 'order').get()\n+        self.assertEqual(result1, ('a', 2))\n+        \n+        # Second evaluation with 'order' only, expecting the same result due to the issue\n+        result2 = qs1.union(qs1).values_list('order').get()\n+        self.assertEqual(result2, ('a', 2))\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/queries/test_values_list_issue_inverted.py b/tests/queries/test_values_list_issue_inverted.py\nnew file mode 100644\nindex 0000000..5b0466d\n--- /dev/null\n+++ b/tests/queries/test_values_list_issue_inverted.py\n@@ -0,0 +1,16 @@\n+from django.test import TestCase\n+from .models import ReservedName\n+\n+class TestValuesListIssue(TestCase):\n+    def test_composed_queries_values_list_issue(self):\n+        ReservedName.objects.create(name='a', order=2)\n+        qs1 = ReservedName.objects.all()\n+        \n+        # First evaluation with 'name' and 'order'\n+        result1 = qs1.union(qs1).values_list('name', 'order').get()\n+        self.assertEqual(result1, ('a', 2))\n+        \n+        # Second evaluation with 'order' only, expecting a different result\n+        # The test should fail here if the bug is present\n+        result2 = qs1.union(qs1).values_list('order').get()\n+        self.assertEqual(result2, (2,), \"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1062442,
  "num_received_chars": 46393,
  "elapsed_time": 566.158136844635,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 3,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}