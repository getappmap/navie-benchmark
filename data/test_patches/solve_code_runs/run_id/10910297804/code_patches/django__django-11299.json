{
  "instance_id": "django__django-11299",
  "edit_test_file": "tests/migrations/test_operations.py",
  "code_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex b1c91db..e2223e5 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -151,6 +151,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n           3. Drop the \"app_model\" table\n           4. Rename the \"new__app_model\" table to \"app_model\"\n           5. Restore any index of the previous \"app_model\" table.\n+          6. Ensure constraints use unqualified column names.\n         \"\"\"\n         # Self-referential fields must be recreated rather than copied from\n         # the old model to ensure their remote_field.field_name doesn't refer\n\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex e7f81d3..dbb200c 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -37,6 +37,8 @@ class CheckConstraint(BaseConstraint):\n         where = query.build_where(self.check)\n         compiler = query.get_compiler(connection=schema_editor.connection)\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n+        # Strip table prefixes from column names for SQLite compatibility\n+        sql = sql.replace(f'\"{model._meta.db_table}\".', '')\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n     def constraint_sql(self, model, schema_editor):\n",
  "test_patch": "diff --git a/tests/migrations/test_checkconstraint_or_operator_sql_issue.py b/tests/migrations/test_checkconstraint_or_operator_sql_issue.py\nnew file mode 100644\nindex 0000000..39f6ddd\n--- /dev/null\n+++ b/tests/migrations/test_checkconstraint_or_operator_sql_issue.py\n@@ -0,0 +1,54 @@\n+# File: tests/migrations/test_checkconstraint_or_operator_sql_issue.py\n+\n+from django.db import connection, models, migrations, IntegrityError\n+from django.test import TestCase, override_settings\n+from django.db.utils import NotSupportedError\n+\n+class TestCheckConstraintOrOperator(TestCase):\n+    databases = {'default'}\n+\n+    @override_settings(DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    })\n+    def test_check_constraint_with_or_operator(self):\n+        # Define the model with the problematic CheckConstraint\n+        class TestConstraint(models.Model):\n+            field_1 = models.IntegerField(blank=True, null=True)\n+            flag = models.BooleanField(blank=False, null=False)\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        check=models.Q(flag__exact=True, field_1__isnull=False) |\n+                              models.Q(flag__exact=False),\n+                        name='field_1_has_value_if_flag_set',\n+                    ),\n+                ]\n+\n+        # Create the migration operation\n+        migration = migrations.Migration('name', 'app')\n+        migration.operations = [\n+            migrations.CreateModel(\n+                name='TestConstraint',\n+                fields=[\n+                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+                    ('field_1', models.IntegerField(blank=True, null=True)),\n+                    ('flag', models.BooleanField()),\n+                ],\n+            ),\n+            migrations.AddConstraint(\n+                model_name='testconstraint',\n+                constraint=models.CheckConstraint(\n+                    check=models.Q(models.Q(('field_1__isnull', False), ('flag__exact', True)), ('flag__exact', False), _connector='OR'),\n+                    name='field_1_has_value_if_flag_set',\n+                ),\n+            ),\n+        ]\n+\n+        # Apply the migration and catch the expected error\n+        with self.assertRaises(NotSupportedError):\n+            with connection.schema_editor() as editor:\n+                migration.apply(None, editor)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_checkconstraint_or_operator_sql_issue_inverted.py b/tests/migrations/test_checkconstraint_or_operator_sql_issue_inverted.py\nnew file mode 100644\nindex 0000000..835252b\n--- /dev/null\n+++ b/tests/migrations/test_checkconstraint_or_operator_sql_issue_inverted.py\n@@ -0,0 +1,54 @@\n+# File: tests/migrations/test_checkconstraint_or_operator_sql_issue.py\n+\n+from django.db import connection, models, migrations, IntegrityError\n+from django.test import TestCase, override_settings\n+from django.db.utils import NotSupportedError\n+\n+class TestCheckConstraintOrOperator(TestCase):\n+    databases = {'default'}\n+\n+    @override_settings(DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    })\n+    def test_check_constraint_with_or_operator(self):\n+        # Define the model with the problematic CheckConstraint\n+        class TestConstraint(models.Model):\n+            field_1 = models.IntegerField(blank=True, null=True)\n+            flag = models.BooleanField(blank=False, null=False)\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        check=models.Q(flag__exact=True, field_1__isnull=False) |\n+                              models.Q(flag__exact=False),\n+                        name='field_1_has_value_if_flag_set',\n+                    ),\n+                ]\n+\n+        # Create the migration operation\n+        migration = migrations.Migration('name', 'app')\n+        migration.operations = [\n+            migrations.CreateModel(\n+                name='TestConstraint',\n+                fields=[\n+                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+                    ('field_1', models.IntegerField(blank=True, null=True)),\n+                    ('flag', models.BooleanField()),\n+                ],\n+            ),\n+            migrations.AddConstraint(\n+                model_name='testconstraint',\n+                constraint=models.CheckConstraint(\n+                    check=models.Q(models.Q(('field_1__isnull', False), ('flag__exact', True)), ('flag__exact', False), _connector='OR'),\n+                    name='field_1_has_value_if_flag_set',\n+                ),\n+            ),\n+        ]\n+\n+        # Apply the migration and catch the expected error\n+        with self.assertRaisesMessage(NotSupportedError, \"__BUG__HERE__\"):\n+            with connection.schema_editor() as editor:\n+                migration.apply(None, editor)\n\\ No newline at end of file\n",
  "num_sent_chars": 2988148,
  "num_received_chars": 90996,
  "elapsed_time": 921.2329423427582,
  "lint_repair_count": 5,
  "test_generation_attempts": 3,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}