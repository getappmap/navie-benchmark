{
  "instance_id": "pytest-dev__pytest-10356",
  "edit_test_file": "testing/test_compat.py",
  "code_patch": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c..2aafdbb 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -388,7 +388,9 @@ def store_mark(obj, mark: Mark) -> None:\n     assert isinstance(mark, Mark), mark\n     # Always reassign name to avoid updating pytestmark in a reference that\n     # was only borrowed.\n-    obj.pytestmark = [*get_unpacked_marks(obj), mark]\n+    existing_marks = {m.name: m for m in get_unpacked_marks(obj)}\n+    existing_marks[mark.name] = mark\n+    obj.pytestmark = list(existing_marks.values())\n \n \n # Typing for builtin pytest marks. This is cheating; it gives builtin marks\n\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex b204423..8d8abc6 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -22,6 +22,7 @@ from _pytest.outcomes import xfail\n from _pytest.reports import BaseReport\n from _pytest.runner import CallInfo\n from _pytest.stash import StashKey\n+from _pytest.mark.structures import get_unpacked_marks\n \n \n def pytest_addoption(parser: Parser) -> None:\n@@ -166,23 +167,25 @@ class Skip:\n \n def evaluate_skip_marks(item: Item) -> Optional[Skip]:\n     \"\"\"Evaluate skip and skipif marks on item, returning Skip if triggered.\"\"\"\n-    for mark in item.iter_markers(name=\"skipif\"):\n-        if \"condition\" not in mark.kwargs:\n-            conditions = mark.args\n-        else:\n-            conditions = (mark.kwargs[\"condition\"],)\n-\n-        # Unconditional.\n-        if not conditions:\n-            reason = mark.kwargs.get(\"reason\", \"\")\n-            return Skip(reason)\n+    all_marks = get_unpacked_marks(item)\n+    for mark in all_marks:\n+        if mark.name == \"skipif\":\n+            if \"condition\" not in mark.kwargs:\n+                conditions = mark.args\n+            else:\n+                conditions = (mark.kwargs[\"condition\"],)\n \n-        # If any of the conditions are true.\n-        for condition in conditions:\n-            result, reason = evaluate_condition(item, mark, condition)\n-            if result:\n+            # Unconditional.\n+            if not conditions:\n+                reason = mark.kwargs.get(\"reason\", \"\")\n                 return Skip(reason)\n \n+            # If any of the conditions are true.\n+            for condition in conditions:\n+                result, reason = evaluate_condition(item, mark, condition)\n+                if result:\n+                    return Skip(reason)\n+\n     for mark in item.iter_markers(name=\"skip\"):\n         try:\n             return Skip(*mark.args, **mark.kwargs)\n@@ -204,26 +207,28 @@ class Xfail:\n \n def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n     \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n-    for mark in item.iter_markers(name=\"xfail\"):\n-        run = mark.kwargs.get(\"run\", True)\n-        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n-        raises = mark.kwargs.get(\"raises\", None)\n-        if \"condition\" not in mark.kwargs:\n-            conditions = mark.args\n-        else:\n-            conditions = (mark.kwargs[\"condition\"],)\n-\n-        # Unconditional.\n-        if not conditions:\n-            reason = mark.kwargs.get(\"reason\", \"\")\n-            return Xfail(reason, run, strict, raises)\n+    all_marks = get_unpacked_marks(item)\n+    for mark in all_marks:\n+        if mark.name == \"xfail\":\n+            run = mark.kwargs.get(\"run\", True)\n+            strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n+            raises = mark.kwargs.get(\"raises\", None)\n+            if \"condition\" not in mark.kwargs:\n+                conditions = mark.args\n+            else:\n+                conditions = (mark.kwargs[\"condition\"],)\n \n-        # If any of the conditions are true.\n-        for condition in conditions:\n-            result, reason = evaluate_condition(item, mark, condition)\n-            if result:\n+            # Unconditional.\n+            if not conditions:\n+                reason = mark.kwargs.get(\"reason\", \"\")\n                 return Xfail(reason, run, strict, raises)\n \n+            # If any of the conditions are true.\n+            for condition in conditions:\n+                result, reason = evaluate_condition(item, mark, condition)\n+                if result:\n+                    return Xfail(reason, run, strict, raises)\n+\n     return None\n \n \n",
  "test_patch": "diff --git a/testing/test_inheritance_markers.py b/testing/test_inheritance_markers.py\nnew file mode 100644\nindex 0000000..27da3fa\n--- /dev/null\n+++ b/testing/test_inheritance_markers.py\n@@ -0,0 +1,31 @@\n+import pytest\n+import itertools\n+\n+class BaseMeta(type):\n+    @property\n+    def pytestmark(self):\n+        return (\n+            getattr(self, \"_pytestmark\", []) +\n+            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\n+        )\n+\n+    @pytestmark.setter\n+    def pytestmark(self, value):\n+        self._pytestmark = value\n+\n+\n+class Base(object, metaclass=BaseMeta):\n+    pass\n+\n+@pytest.mark.foo\n+class Foo(Base):\n+    pass\n+\n+@pytest.mark.bar\n+class Bar(Base):\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        markers = {mark.name for mark in self.__class__.pytestmark}\n+        assert markers == {\"foo\", \"bar\"}, f\"Expected markers 'foo' and 'bar', but got {markers}\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/testing/test_inheritance_markers_inverted.py b/testing/test_inheritance_markers_inverted.py\nnew file mode 100644\nindex 0000000..f7a3413\n--- /dev/null\n+++ b/testing/test_inheritance_markers_inverted.py\n@@ -0,0 +1,32 @@\n+import pytest\n+import itertools\n+\n+class BaseMeta(type):\n+    @property\n+    def pytestmark(self):\n+        return (\n+            getattr(self, \"_pytestmark\", []) +\n+            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\n+        )\n+\n+    @pytestmark.setter\n+    def pytestmark(self, value):\n+        self._pytestmark = value\n+\n+\n+class Base(object, metaclass=BaseMeta):\n+    pass\n+\n+@pytest.mark.foo\n+class Foo(Base):\n+    pass\n+\n+@pytest.mark.bar\n+class Bar(Base):\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        markers = {mark.name for mark in self.__class__.pytestmark}\n+        # Altered the assertion to fail when the issue is observed\n+        assert markers != {\"foo\", \"bar\"}, \"__BUG__HERE__\"\n\\ No newline at end of file\n",
  "num_sent_chars": 445104,
  "num_received_chars": 26637,
  "elapsed_time": 305.10646080970764,
  "lint_repair_count": 4,
  "test_generation_attempts": 0,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": null
}