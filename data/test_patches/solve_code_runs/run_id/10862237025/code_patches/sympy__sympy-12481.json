{
  "instance_id": "sympy__sympy-12481",
  "edit_test_file": "sympy/combinatorics/tests/test_permutations.py",
  "code_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 136ed5a..5ae3335 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -801,8 +801,8 @@ class Permutation(Basic):\n     def __new__(cls, *args, **kwargs):\n         \"\"\"\n         Constructor for the Permutation object from a list or a\n-        list of lists in which all elements of the permutation may\n-        appear only once.\n+        list of lists. Non-disjoint cycles are processed in left-to-right\n+        order, allowing elements to appear in multiple cycles.\n \n         Examples\n         ========\n@@ -886,8 +886,18 @@ def __new__(cls, *args, **kwargs):\n         is_cycle = args and is_sequence(args[0])\n         if is_cycle:  # e\n             args = [[int(i) for i in c] for c in args]\n+            # Process non-disjoint cycles in left-to-right order\n+            aform = list(range(size or max(flatten(args)) + 1))\n+            for cycle in args:\n+                if len(cycle) < 2:\n+                    continue\n+                first = cycle[0]\n+                for i in range(len(cycle) - 1):\n+                    aform[cycle[i]] = cycle[i + 1]\n+                aform[cycle[-1]] = first\n         else:  # d\n             args = [int(i) for i in args]\n+            aform = args\n \n         # if there are n elements present, 0, 1, ..., n-1 should be present\n         # unless a cycle notation has been provided. A 0 will be added\n@@ -895,13 +905,6 @@ def __new__(cls, *args, **kwargs):\n         # counting starts from 1.\n \n         temp = flatten(args)\n-        if has_dups(temp):\n-            if is_cycle:\n-                raise ValueError('there were repeated elements; to resolve '\n-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n-            else:\n-                raise ValueError('there were repeated elements.')\n-        temp = set(temp)\n \n         if not is_cycle and \\\n                 any(i not in temp for i in range(len(temp))):\n",
  "test_patch": "diff --git a/sympy/combinatorics/tests/test_non_disjoint_cycles.py b/sympy/combinatorics/tests/test_non_disjoint_cycles.py\nnew file mode 100644\nindex 0000000..b2d802e\n--- /dev/null\n+++ b/sympy/combinatorics/tests/test_non_disjoint_cycles.py\n@@ -0,0 +1,6 @@\n+from sympy.combinatorics.permutations import Permutation\n+from sympy.utilities.pytest import raises\n+\n+def test_non_disjoint_cycles():\n+    # Test that a ValueError is raised when non-disjoint cycles are used\n+    raises(ValueError, lambda: Permutation([[0, 1], [0, 1]]))\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/combinatorics/tests/test_non_disjoint_cycles_inverted.py b/sympy/combinatorics/tests/test_non_disjoint_cycles_inverted.py\nnew file mode 100644\nindex 0000000..e5ef29f\n--- /dev/null\n+++ b/sympy/combinatorics/tests/test_non_disjoint_cycles_inverted.py\n@@ -0,0 +1,8 @@\n+from sympy.combinatorics.permutations import Permutation\n+\n+def test_non_disjoint_cycles():\n+    # Test that a ValueError is NOT raised when non-disjoint cycles are used\n+    try:\n+        Permutation([[0, 1], [0, 1]])\n+    except ValueError:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3140862,
  "num_received_chars": 125835,
  "elapsed_time": 1076.4169971942902,
  "lint_repair_count": 32,
  "test_generation_attempts": 0,
  "code_generation_attempts": 18,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}