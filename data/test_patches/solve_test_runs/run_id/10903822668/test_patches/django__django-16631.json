{
  "edit_test_file": "tests/auth_tests/test_tokens.py",
  "test_patch": "diff --git a/tests/auth_tests/test_secret_key_fallbacks.py b/tests/auth_tests/test_secret_key_fallbacks.py\nnew file mode 100644\nindex 0000000..9732e2b\n--- /dev/null\n+++ b/tests/auth_tests/test_secret_key_fallbacks.py\n@@ -0,0 +1,32 @@\n+from django.conf import settings\n+from django.contrib.auth.models import User\n+from django.contrib.auth import get_user\n+from django.test import TestCase, RequestFactory, override_settings\n+from django.utils.crypto import constant_time_compare\n+\n+class SecretKeyFallbacksSessionTest(TestCase):\n+    @override_settings(\n+        SECRET_KEY=\"newsecret\",\n+        SECRET_KEY_FALLBACKS=[\"oldsecret\"],\n+    )\n+    def test_secret_key_fallbacks_not_used_for_sessions(self):\n+        # Create a user and simulate a login\n+        user = User.objects.create_user(\"sessiontestuser\", \"test@example.com\", \"testpw\")\n+        request = RequestFactory().get('/')\n+        request.session = self.client.session\n+        request.user = user\n+\n+        # Simulate login to set session\n+        request.session['_auth_user_id'] = user.pk\n+        request.session['_auth_user_hash'] = user.get_session_auth_hash()\n+\n+        # Simulate secret key rotation\n+        with self.settings(SECRET_KEY=\"newsecret\", SECRET_KEY_FALLBACKS=[\"oldsecret\"]):\n+            # Reload the session and check if the user is still authenticated\n+            request.session.save()\n+            request.session = self.client.session\n+            request.user = get_user(request)\n+\n+            # The user should be logged out because the session hash does not match\n+            self.assertNotEqual(request.user, user)\n+            self.assertFalse(request.user.is_authenticated)\n\\ No newline at end of file\n",
  "inverted_patch": null
}