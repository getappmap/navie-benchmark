{
  "edit_test_file": "tests/admin_changelist/tests.py",
  "test_patch": "diff --git a/tests/admin_changelist/test_related_field_list_filter_ordering.py b/tests/admin_changelist/test_related_field_list_filter_ordering.py\nnew file mode 100644\nindex 0000000..bd8b924\n--- /dev/null\n+++ b/tests/admin_changelist/test_related_field_list_filter_ordering.py\n@@ -0,0 +1,58 @@\n+import datetime\n+\n+from django.contrib import admin\n+from django.contrib.admin.views.main import SEARCH_VAR\n+from django.contrib.auth.models import User\n+from django.db import models\n+from django.test import TestCase, override_settings\n+from django.test.client import RequestFactory\n+from django.urls import reverse\n+\n+from .models import Band, Genre\n+from .admin import BandAdmin, site as custom_site\n+\n+\n+@override_settings(ROOT_URLCONF=\"admin_changelist.urls\")\n+class RelatedFieldListFilterOrderingTests(TestCase):\n+    factory = RequestFactory()\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(username='super', email='a@b.com', password='xxx')\n+\n+    def _mocked_authenticated_request(self, url, user):\n+        request = self.factory.get(url)\n+        request.user = user\n+        return request\n+\n+    def test_related_field_list_filter_ordering(self):\n+        \"\"\"\n+        Test to reproduce the issue where RelatedFieldListFilter doesn't fall back\n+        to the ordering defined in Model._meta.ordering.\n+        \"\"\"\n+        # Create genres with specific ordering\n+        genre1 = Genre.objects.create(name='Jazz')\n+        genre2 = Genre.objects.create(name='Blues')\n+        genre3 = Genre.objects.create(name='Rock')\n+\n+        # Create a band and associate genres\n+        band = Band.objects.create(name='The Band', nr_of_members=5)\n+        band.genres.add(genre1, genre2, genre3)\n+\n+        # Set up the BandAdmin with a RelatedFieldListFilter on genres\n+        m = BandAdmin(Band, custom_site)\n+        request = self._mocked_authenticated_request('/band/', self.superuser)\n+        cl = m.get_changelist_instance(request)\n+\n+        # Get the list filter for genres\n+        genre_filter = next(\n+            (f for f in cl.get_filters(request)[0] if f.title == 'genres'),\n+            None\n+        )\n+\n+        # Assert that the ordering is incorrect (empty tuple)\n+        self.assertEqual(genre_filter.lookup_choices, [\n+            (genre1.pk, str(genre1)),\n+            (genre2.pk, str(genre2)),\n+            (genre3.pk, str(genre3)),\n+        ], \"RelatedFieldListFilter did not fall back to Model._meta.ordering\")\n",
  "inverted_patch": "diff --git a/tests/admin_changelist/test_related_field_list_filter_ordering_inverted.py b/tests/admin_changelist/test_related_field_list_filter_ordering_inverted.py\nnew file mode 100644\nindex 0000000..9bcb26b\n--- /dev/null\n+++ b/tests/admin_changelist/test_related_field_list_filter_ordering_inverted.py\n@@ -0,0 +1,59 @@\n+import datetime\n+\n+from django.contrib import admin\n+from django.contrib.admin.views.main import SEARCH_VAR\n+from django.contrib.auth.models import User\n+from django.db import models\n+from django.test import TestCase, override_settings\n+from django.test.client import RequestFactory\n+from django.urls import reverse\n+\n+from .models import Band, Genre\n+from .admin import BandAdmin, site as custom_site\n+\n+\n+@override_settings(ROOT_URLCONF=\"admin_changelist.urls\")\n+class RelatedFieldListFilterOrderingTests(TestCase):\n+    factory = RequestFactory()\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(username='super', email='a@b.com', password='xxx')\n+\n+    def _mocked_authenticated_request(self, url, user):\n+        request = self.factory.get(url)\n+        request.user = user\n+        return request\n+\n+    def test_related_field_list_filter_ordering(self):\n+        \"\"\"\n+        Test to reproduce the issue where RelatedFieldListFilter doesn't fall back\n+        to the ordering defined in Model._meta.ordering.\n+        \"\"\"\n+        # Create genres with specific ordering\n+        genre1 = Genre.objects.create(name='Jazz')\n+        genre2 = Genre.objects.create(name='Blues')\n+        genre3 = Genre.objects.create(name='Rock')\n+\n+        # Create a band and associate genres\n+        band = Band.objects.create(name='The Band', nr_of_members=5)\n+        band.genres.add(genre1, genre2, genre3)\n+\n+        # Set up the BandAdmin with a RelatedFieldListFilter on genres\n+        m = BandAdmin(Band, custom_site)\n+        request = self._mocked_authenticated_request('/band/', self.superuser)\n+        cl = m.get_changelist_instance(request)\n+\n+        # Get the list filter for genres\n+        genre_filter = next(\n+            (f for f in cl.get_filters(request)[0] if f.title == 'genres'),\n+            None\n+        )\n+\n+        # Assert that the ordering is incorrect (empty tuple)\n+        # This assertion should now fail when the bug is present\n+        self.assertNotEqual(genre_filter.lookup_choices, [\n+            (genre1.pk, str(genre1)),\n+            (genre2.pk, str(genre2)),\n+            (genre3.pk, str(genre3)),\n+        ], \"__BUG__HERE__\")\n\\ No newline at end of file\n"
}