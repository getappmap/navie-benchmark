{
  "instance_id": "django__django-15554",
  "edit_test_file": "tests/m2m_through_regress/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258..97c2d45 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1716,7 +1716,7 @@ class Query(BaseExpression):\n                 break\n         return path, final_field, targets, names[pos + 1 :]\n \n-    def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True):\n+    def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True, filtered_relation=None):\n         \"\"\"\n         Compute the necessary table joins for the passage through the fields\n         given in 'names'. 'opts' is the Options class for the current model\n@@ -1731,6 +1731,9 @@ class Query(BaseExpression):\n         If 'allow_many' is False, then any reverse foreign key seen will\n         generate a MultiJoin exception.\n \n+        The 'filtered_relation' parameter allows for handling multiple FilteredRelations\n+        on the same base relation by ensuring distinct joins for each condition.\n+\n         Return the final field involved in the joins, the target field (used\n         for any 'where' constraint), the final 'opts' value, the joins, the\n         field path traveled to generate the joins, and a transform function\n@@ -1818,7 +1821,8 @@ class Query(BaseExpression):\n                 nullable,\n                 filtered_relation=filtered_relation,\n             )\n-            reuse = can_reuse if join.m2m else None\n+            # Ensure distinct joins for each FilteredRelation condition\n+            reuse = None if filtered_relation else (can_reuse if join.m2m else None)\n             alias = self.join(connection, reuse=reuse)\n             joins.append(alias)\n             if filtered_relation:\n",
  "test_patch": "diff --git a/tests/m2m_through_regress/test_filteredrelation_issue.py b/tests/m2m_through_regress/test_filteredrelation_issue.py\nnew file mode 100644\nindex 0000000..10ce55f\n--- /dev/null\n+++ b/tests/m2m_through_regress/test_filteredrelation_issue.py\n@@ -0,0 +1,45 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import F, Q, Case, When, FilteredRelation\n+\n+# Define models for the test\n+class MyModel(models.Model):\n+    zone = models.CharField(max_length=100)\n+\n+class NestedRelation(models.Model):\n+    mymodel = models.ForeignKey(MyModel, on_delete=models.CASCADE, related_name='nested')\n+    is_all = models.BooleanField(default=False)\n+    price = models.DecimalField(max_digits=10, decimal_places=2)\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+\n+class TestFilteredRelationIssue(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        mymodel = MyModel.objects.create(zone='zone1')\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=True, price=100.00)\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=False, price=200.00, zone='zone1')\n+\n+    def test_filteredrelation_multiple_filters(self):\n+        qs = MyModel.objects.alias(\n+            relation_zone=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__zone=F(\"zone\"))\n+            ),\n+            relation_all=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__is_all=True)\n+            ),\n+            price_zone=F(\"relation_zone__price\")\n+        ).annotate(\n+            price_final=Case(\n+                When(\n+                    price_zone__isnull=True,\n+                    then=F(\"relation_all__price\"),\n+                ),\n+                default=F(\"price_zone\")\n+            )\n+        )\n+\n+        # Check if only one join is created, indicating the issue\n+        self.assertIn('JOIN', str(qs.query))\n+        self.assertNotIn('relation_all', str(qs.query))\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/m2m_through_regress/test_filteredrelation_issue_inverted.py b/tests/m2m_through_regress/test_filteredrelation_issue_inverted.py\nnew file mode 100644\nindex 0000000..58dd1c4\n--- /dev/null\n+++ b/tests/m2m_through_regress/test_filteredrelation_issue_inverted.py\n@@ -0,0 +1,45 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import F, Q, Case, When, FilteredRelation\n+\n+# Define models for the test\n+class MyModel(models.Model):\n+    zone = models.CharField(max_length=100)\n+\n+class NestedRelation(models.Model):\n+    mymodel = models.ForeignKey(MyModel, on_delete=models.CASCADE, related_name='nested')\n+    is_all = models.BooleanField(default=False)\n+    price = models.DecimalField(max_digits=10, decimal_places=2)\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+\n+class TestFilteredRelationIssue(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        mymodel = MyModel.objects.create(zone='zone1')\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=True, price=100.00)\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=False, price=200.00, zone='zone1')\n+\n+    def test_filteredrelation_multiple_filters(self):\n+        qs = MyModel.objects.alias(\n+            relation_zone=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__zone=F(\"zone\"))\n+            ),\n+            relation_all=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__is_all=True)\n+            ),\n+            price_zone=F(\"relation_zone__price\")\n+        ).annotate(\n+            price_final=Case(\n+                When(\n+                    price_zone__isnull=True,\n+                    then=F(\"relation_all__price\"),\n+                ),\n+                default=F(\"price_zone\")\n+            )\n+        )\n+\n+        # Check if only one join is created, indicating the issue\n+        if 'JOIN' in str(qs.query) and 'relation_all' not in str(qs.query):\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3004802,
  "num_received_chars": 109294,
  "elapsed_time": 902.4802520275116,
  "lint_repair_count": 11,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}