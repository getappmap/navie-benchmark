{
  "instance_id": "django__django-15563",
  "edit_test_file": "tests/update/tests.py",
  "code_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5c78c6e..11f3e18 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -987,7 +987,13 @@ class QuerySet:\n         if self.query.is_sliced:\n             raise TypeError(\"Cannot update a query once a slice has been taken.\")\n         self._for_write = True\n-        query = self.query.chain(sql.UpdateQuery)\n+\n+        # Ensure the update targets the correct table for multi-table inheritance\n+        if self.model._meta.concrete_model is not self.model:\n+            query = self.query.chain(sql.UpdateQuery, self.model._meta.concrete_model)\n+        else:\n+            query = self.query.chain(sql.UpdateQuery)\n+\n         query.add_update_values(kwargs)\n         # Clear any annotations so that they won't be present in subqueries.\n         query.annotations = {}\n",
  "test_patch": "diff --git a/tests/update/test_queryset_multiple_inheritance.py b/tests/update/test_queryset_multiple_inheritance.py\nnew file mode 100644\nindex 0000000..3786e70\n--- /dev/null\n+++ b/tests/update/test_queryset_multiple_inheritance.py\n@@ -0,0 +1,37 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+class Base(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+class OtherBase(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True)\n+    field_otherbase = models.IntegerField()\n+\n+class Child(Base, OtherBase):\n+    pass\n+\n+class QuerysetMultipleInheritanceTest(TestCase):\n+    def test_queryset_update_on_multiple_inheritance(self):\n+        # Create instances of OtherBase\n+        OtherBase.objects.create(field_otherbase=100)\n+        OtherBase.objects.create(field_otherbase=101)\n+        \n+        # Create instances of Child\n+        Child.objects.create(field_base=0, field_otherbase=0)\n+        Child.objects.create(field_base=1, field_otherbase=1)\n+        \n+        # Update field_otherbase on Child instances\n+        updated_count = Child.objects.update(field_otherbase=55)\n+        \n+        # Assert that the update count is 2, indicating the update was attempted\n+        self.assertEqual(updated_count, 2)\n+        \n+        # Check that the field_otherbase values in Child instances remain unchanged\n+        child_values = list(Child.objects.values_list('field_otherbase', flat=True))\n+        self.assertEqual(child_values, [0, 1])\n+        \n+        # Check that the field_otherbase values in OtherBase instances were incorrectly updated\n+        otherbase_values = list(OtherBase.objects.filter(otherbase_id__in=[1, 2]).values_list('field_otherbase', flat=True))\n+        self.assertEqual(otherbase_values, [55, 55])\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/update/test_queryset_multiple_inheritance_inverted.py b/tests/update/test_queryset_multiple_inheritance_inverted.py\nnew file mode 100644\nindex 0000000..937dabc\n--- /dev/null\n+++ b/tests/update/test_queryset_multiple_inheritance_inverted.py\n@@ -0,0 +1,40 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+class Base(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+class OtherBase(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True)\n+    field_otherbase = models.IntegerField()\n+\n+class Child(Base, OtherBase):\n+    pass\n+\n+class QuerysetMultipleInheritanceTest(TestCase):\n+    def test_queryset_update_on_multiple_inheritance(self):\n+        # Create instances of OtherBase\n+        OtherBase.objects.create(field_otherbase=100)\n+        OtherBase.objects.create(field_otherbase=101)\n+        \n+        # Create instances of Child\n+        Child.objects.create(field_base=0, field_otherbase=0)\n+        Child.objects.create(field_base=1, field_otherbase=1)\n+        \n+        # Update field_otherbase on Child instances\n+        updated_count = Child.objects.update(field_otherbase=55)\n+        \n+        # Assert that the update count is 2, indicating the update was attempted\n+        self.assertEqual(updated_count, 2)\n+        \n+        # Check that the field_otherbase values in Child instances remain unchanged\n+        child_values = list(Child.objects.values_list('field_otherbase', flat=True))\n+        self.assertEqual(child_values, [0, 1])\n+        \n+        # Check that the field_otherbase values in OtherBase instances were incorrectly updated\n+        otherbase_values = list(OtherBase.objects.filter(otherbase_id__in=[1, 2]).values_list('field_otherbase', flat=True))\n+        \n+        # Alter the test to fail when the bug is observed\n+        if otherbase_values == [55, 55]:\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1682934,
  "num_received_chars": 101020,
  "elapsed_time": 652.2129530906677,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}