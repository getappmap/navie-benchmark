{
  "instance_id": "django__django-15973",
  "edit_test_file": "tests/invalid_models_tests/test_relative_fields.py",
  "code_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex eb738cf..76a67a8 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -71,25 +71,29 @@ class MigrationExecutor:\n         return plan\n \n     def _create_project_state(self, with_applied_migrations=False):\n-        \"\"\"\n-        Create a project state including all the applications without\n-        migrations and applied migrations if with_applied_migrations=True.\n-        \"\"\"\n-        state = ProjectState(real_apps=self.loader.unmigrated_apps)\n-        if with_applied_migrations:\n-            # Create the forwards plan Django would follow on an empty database\n-            full_plan = self.migration_plan(\n-                self.loader.graph.leaf_nodes(), clean_start=True\n-            )\n-            applied_migrations = {\n-                self.loader.graph.nodes[key]\n-                for key in self.loader.applied_migrations\n-                if key in self.loader.graph.nodes\n-            }\n-            for migration, _ in full_plan:\n-                if migration in applied_migrations:\n-                    migration.mutate_state(state, preserve=False)\n-        return state\n+            \"\"\"\n+            Create a project state including all the applications without\n+            migrations and applied migrations if with_applied_migrations=True.\n+            \"\"\"\n+            state = ProjectState(real_apps=self.loader.unmigrated_apps)\n+            if with_applied_migrations:\n+                # Create the forwards plan Django would follow on an empty database\n+                full_plan = self.migration_plan(\n+                    self.loader.graph.leaf_nodes(), clean_start=True\n+                )\n+                applied_migrations = {\n+                    self.loader.graph.nodes[key]\n+                    for key in self.loader.applied_migrations\n+                    if key in self.loader.graph.nodes\n+                }\n+                for migration, _ in full_plan:\n+                    if migration in applied_migrations:\n+                        migration.mutate_state(state, preserve=False)\n+                    # Resolve any string-based model references\n+                    for operation in migration.operations:\n+                        if hasattr(operation, 'model_name') and isinstance(operation.model_name, str):\n+                            operation.model_name = apps.get_model(migration.app_label, operation.model_name)\n+            return state\n \n     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):\n         \"\"\"\n@@ -305,26 +309,28 @@ class MigrationExecutor:\n                 self.recorder.record_applied(*key)\n \n     def detect_soft_applied(self, project_state, migration):\n-        \"\"\"\n-        Test whether a migration has been implicitly applied - that the\n-        tables or columns it would create exist. This is intended only for use\n-        on initial migrations (as it only looks for CreateModel and AddField).\n-        \"\"\"\n-\n-        def should_skip_detecting_model(migration, model):\n             \"\"\"\n-            No need to detect tables for proxy models, unmanaged models, or\n-            models that can't be migrated on the current database.\n+            Test whether a migration has been implicitly applied - that the\n+            tables or columns it would create exist. This is intended only for use\n+            on initial migrations (as it only looks for CreateModel and AddField).\n             \"\"\"\n-            return (\n-                model._meta.proxy\n-                or not model._meta.managed\n-                or not router.allow_migrate(\n-                    self.connection.alias,\n-                    migration.app_label,\n-                    model_name=model._meta.model_name,\n+    \n+            def should_skip_detecting_model(migration, model):\n+                \"\"\"\n+                No need to detect tables for proxy models, unmanaged models, or\n+                models that can't be migrated on the current database.\n+                \"\"\"\n+                if isinstance(model, str):\n+                    model = apps.get_model(migration.app_label, model)\n+                return (\n+                    model._meta.proxy\n+                    or not model._meta.managed\n+                    or not router.allow_migrate(\n+                        self.connection.alias,\n+                        migration.app_label,\n+                        model_name=model._meta.model_name,\n+                    )\n                 )\n-            )\n \n         if migration.initial is None:\n             # Bail if the migration isn't the first one in its app\n",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_m2m_through_intermediary_issue.py b/tests/invalid_models_tests/test_m2m_through_intermediary_issue.py\nnew file mode 100644\nindex 0000000..8c0cc23\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_m2m_through_intermediary_issue.py\n@@ -0,0 +1,36 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.utils import OperationalError\n+\n+class FonteModel(models.Model):\n+    nome = models.TextField(unique=True)\n+    descricao = models.TextField()\n+    data_inicial = models.DateField()\n+    data_final = models.DateField(blank=True, null=True)\n+    variaveis = models.ManyToManyField(\"variavel.VariavelModel\", through=\"fonte_variavel.FonteVariavelModel\")\n+\n+    class Meta:\n+        app_label = 'fonte'\n+        db_table = \"fontes\"\n+\n+class VariavelModel(models.Model):\n+    nome = models.TextField(unique=True)\n+    descricao = models.TextField()\n+\n+    class Meta:\n+        app_label = 'variavel'\n+        db_table = 'variaveis'\n+\n+class FonteVariavelModel(models.Model):\n+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)\n+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)\n+\n+    class Meta:\n+        app_label = 'fonte_variavel'\n+        db_table = 'fontes_variaveis'\n+\n+class ManyToManyIntermediaryIssueTest(TestCase):\n+    def test_m2m_intermediary_model_in_different_app(self):\n+        with self.assertRaises(OperationalError) as cm:\n+            FonteModel.objects.create(nome=\"Test Fonte\", descricao=\"Test Description\", data_inicial=\"2023-01-01\")\n+        self.assertIn(\"no such table: fontes\", str(cm.exception))\n\\ No newline at end of file\n",
  "test_inverted_patch": null,
  "num_sent_chars": 4330797,
  "num_received_chars": 118998,
  "elapsed_time": 806.5462625026703,
  "lint_repair_count": 6,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}