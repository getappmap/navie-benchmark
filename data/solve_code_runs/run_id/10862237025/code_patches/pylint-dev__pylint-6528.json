{
  "instance_id": "pylint-dev__pylint-6528",
  "edit_test_file": "tests/config/unittest_config.py",
  "code_patch": "diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py\nindex 53345a6..604d565 100644\n--- a/pylint/lint/pylinter.py\n+++ b/pylint/lint/pylinter.py\n@@ -565,8 +565,8 @@ class PyLinter(\n                 self._msgs_state[msg.msgid] = False\n \n     @staticmethod\n-    def _discover_files(files_or_modules: Sequence[str]) -> Iterator[str]:\n-        \"\"\"Discover python modules and packages in sub-directory.\n+    def _discover_files(files_or_modules: Sequence[str], ignore: list[str], ignore_patterns: list[str], ignore_paths: list[str]) -> Iterator[str]:\n+        \"\"\"Discover python modules and packages in sub-directory, respecting ignore settings.\n \n         Returns iterator of paths to discovered modules and packages.\n         \"\"\"\n@@ -583,13 +583,25 @@ class PyLinter(\n                         skip_subtrees.append(root)\n                         yield root\n                     else:\n-                        yield from (\n-                            os.path.join(root, file)\n-                            for file in files\n-                            if file.endswith(\".py\")\n-                        )\n+                        for file in files:\n+                            full_path = os.path.join(root, file)\n+                            if file.endswith(\".py\") and not any(\n+                                fnmatch.fnmatch(file, pattern) for pattern in ignore\n+                            ) and not any(\n+                                re.match(pattern, file) for pattern in ignore_patterns\n+                            ) and not any(\n+                                re.match(pattern, full_path) for pattern in ignore_paths\n+                            ):\n+                                yield full_path\n             else:\n-                yield something\n+                if not any(\n+                    fnmatch.fnmatch(something, pattern) for pattern in ignore\n+                ) and not any(\n+                    re.match(pattern, something) for pattern in ignore_patterns\n+                ) and not any(\n+                    re.match(pattern, something) for pattern in ignore_paths\n+                ):\n+                    yield something\n \n     def check(self, files_or_modules: Sequence[str] | str) -> None:\n         \"\"\"Main checking entry: check a list of files or modules from their name.\n@@ -605,7 +617,14 @@ class PyLinter(\n             )\n             files_or_modules = (files_or_modules,)  # type: ignore[assignment]\n         if self.config.recursive:\n-            files_or_modules = tuple(self._discover_files(files_or_modules))\n+            files_or_modules = tuple(\n+                self._discover_files(\n+                    files_or_modules,\n+                    self.config.ignore,\n+                    self.config.ignore_patterns,\n+                    self.config.ignore_paths,\n+                )\n+            )\n         if self.config.from_stdin:\n             if len(files_or_modules) != 1:\n                 raise exceptions.InvalidArgsError(\n",
  "test_patch": "diff --git a/tests/config/test_recursive_ignore.py b/tests/config/test_recursive_ignore.py\nnew file mode 100644\nindex 0000000..a236abd\n--- /dev/null\n+++ b/tests/config/test_recursive_ignore.py\n@@ -0,0 +1,26 @@\n+import subprocess\n+import unittest\n+\n+class TestPylintRecursiveIgnore(unittest.TestCase):\n+    def test_pylint_recursive_ignore(self):\n+        # Create a temporary directory structure\n+        subprocess.run(\"mkdir -p temp/.a\", shell=True, check=True)\n+        subprocess.run(\"echo 'import re' > temp/.a/foo.py\", shell=True, check=True)\n+        subprocess.run(\"echo 'import re' > temp/bar.py\", shell=True, check=True)\n+\n+        # Run pylint with recursive mode and ignore settings\n+        result = subprocess.run(\n+            \"pylint --recursive=y temp\",\n+            shell=True,\n+            capture_output=True,\n+            text=True\n+        )\n+\n+        # Check if the output contains the ignored file\n+        self.assertIn(\"************* Module foo\", result.stdout)\n+\n+        # Clean up the temporary directory\n+        subprocess.run(\"rm -rf temp\", shell=True, check=True)\n+\n+if __name__ == \"__main__\":\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/config/test_recursive_ignore_inverted.py b/tests/config/test_recursive_ignore_inverted.py\nnew file mode 100644\nindex 0000000..38888d4\n--- /dev/null\n+++ b/tests/config/test_recursive_ignore_inverted.py\n@@ -0,0 +1,27 @@\n+import subprocess\n+import unittest\n+\n+class TestPylintRecursiveIgnore(unittest.TestCase):\n+    def test_pylint_recursive_ignore(self):\n+        # Create a temporary directory structure\n+        subprocess.run(\"mkdir -p temp/.a\", shell=True, check=True)\n+        subprocess.run(\"echo 'import re' > temp/.a/foo.py\", shell=True, check=True)\n+        subprocess.run(\"echo 'import re' > temp/bar.py\", shell=True, check=True)\n+\n+        # Run pylint with recursive mode and ignore settings\n+        result = subprocess.run(\n+            \"pylint --recursive=y temp\",\n+            shell=True,\n+            capture_output=True,\n+            text=True\n+        )\n+\n+        # Check if the output contains the ignored file\n+        if \"************* Module foo\" in result.stdout:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Clean up the temporary directory\n+        subprocess.run(\"rm -rf temp\", shell=True, check=True)\n+\n+if __name__ == \"__main__\":\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 163641,
  "num_received_chars": 11596,
  "elapsed_time": 78.23527956008911,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": null
}