{
  "instance_id": "django__django-13346",
  "edit_test_file": "tests/model_fields/test_jsonfield.py",
  "code_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1be..37f39b4 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -277,6 +277,21 @@ class KeyTransform(Transform):\n         super().__init__(*args, **kwargs)\n         self.key_name = str(key_name)\n \n+    def as_mysql_in(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path(key_transforms)\n+        return 'JSON_CONTAINS(%s, %%s)' % lhs, tuple(params) + (json.dumps(self.rhs),)\n+\n+    def as_oracle_in(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path(key_transforms)\n+        return \"JSON_EXISTS(%s, '%s')\" % (lhs, json_path), tuple(params)\n+\n+    def as_sqlite_in(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path(key_transforms)\n+        return 'JSON_TYPE(%s, %%s) IS NOT NULL' % lhs, tuple(params) + (json_path,)\n+\n     def preprocess_lhs(self, compiler, connection, lhs_only=False):\n         if not lhs_only:\n             key_transforms = [self.key_name]\n@@ -455,6 +470,17 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def as_sql(self, compiler, connection):\n+        if connection.vendor == 'mysql':\n+            return self.lhs.as_mysql_in(compiler, connection)\n+        elif connection.vendor == 'oracle':\n+            return self.lhs.as_oracle_in(compiler, connection)\n+        elif connection.vendor == 'sqlite':\n+            return self.lhs.as_sqlite_in(compiler, connection)\n+        return super().as_sql(compiler, connection)\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -485,6 +511,7 @@ KeyTransform.register_lookup(KeyTransformIsNull)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformEndsWith)\n KeyTransform.register_lookup(KeyTransformIEndsWith)\n KeyTransform.register_lookup(KeyTransformRegex)\n",
  "test_patch": "diff --git a/tests/model_fields/test_in_lookup_key_transform.py b/tests/model_fields/test_in_lookup_key_transform.py\nnew file mode 100644\nindex 0000000..9a6a93d\n--- /dev/null\n+++ b/tests/model_fields/test_in_lookup_key_transform.py\n@@ -0,0 +1,29 @@\n+import unittest\n+from django.test import TestCase\n+from django.db import models\n+from django.db.models import JSONField\n+\n+class OurModel(models.Model):\n+    our_field = JSONField()\n+\n+class TestInLookupKeyTransform(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a test instance with a JSONField containing a key-value pair\n+        OurModel.objects.create(our_field={'key': 0})\n+\n+    def test_in_lookup_key_transform(self):\n+        # First filter using __in lookup on key transform\n+        first_filter = {'our_field__key__in': [0]}\n+        first_items = OurModel.objects.filter(**first_filter)\n+        # Assert that the length of the queryset is 0, which is the issue\n+        self.assertEqual(len(first_items), 0)\n+\n+        # Second filter using direct key lookup\n+        second_filter = {'our_field__key': 0}\n+        second_items = OurModel.objects.filter(**second_filter)\n+        # Assert that the length of the queryset is 1, which is expected\n+        self.assertEqual(len(second_items), 1)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/model_fields/test_in_lookup_key_transform_inverted.py b/tests/model_fields/test_in_lookup_key_transform_inverted.py\nnew file mode 100644\nindex 0000000..88b17b6\n--- /dev/null\n+++ b/tests/model_fields/test_in_lookup_key_transform_inverted.py\n@@ -0,0 +1,31 @@\n+import unittest\n+from django.test import TestCase\n+from django.db import models\n+from django.db.models import JSONField\n+\n+class OurModel(models.Model):\n+    our_field = JSONField()\n+\n+class TestInLookupKeyTransform(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a test instance with a JSONField containing a key-value pair\n+        OurModel.objects.create(our_field={'key': 0})\n+\n+    def test_in_lookup_key_transform(self):\n+        # First filter using __in lookup on key transform\n+        first_filter = {'our_field__key__in': [0]}\n+        first_items = OurModel.objects.filter(**first_filter)\n+        # Assert that the length of the queryset is 1, which is expected\n+        # This should fail if the bug is present\n+        if len(first_items) != 1:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Second filter using direct key lookup\n+        second_filter = {'our_field__key': 0}\n+        second_items = OurModel.objects.filter(**second_filter)\n+        # Assert that the length of the queryset is 1, which is expected\n+        self.assertEqual(len(second_items), 1)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 149873,
  "num_received_chars": 7721,
  "elapsed_time": 61.143868923187256,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}