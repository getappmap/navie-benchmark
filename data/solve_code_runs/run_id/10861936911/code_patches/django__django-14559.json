{
  "instance_id": "django__django-14559",
  "edit_test_file": "tests/queries/test_bulk_update.py",
  "code_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca..504d161 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,7 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -549,6 +549,7 @@ class QuerySet:\n         requires_casting = connections[self.db].features.requires_casted_case_in_updates\n         batches = (objs[i:i + batch_size] for i in range(0, len(objs), batch_size))\n         updates = []\n+        total_rows_affected = 0\n         for batch_objs in batches:\n             update_kwargs = {}\n             for field in fields:\n@@ -565,7 +566,8 @@ class QuerySet:\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows_affected += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows_affected\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
  "test_patch": "diff --git a/tests/queries/test_bulk_update_return_value.py b/tests/queries/test_bulk_update_return_value.py\nnew file mode 100644\nindex 0000000..def066a\n--- /dev/null\n+++ b/tests/queries/test_bulk_update_return_value.py\n@@ -0,0 +1,18 @@\n+import datetime\n+from django.test import TestCase\n+from .models import Note\n+\n+class BulkUpdateReturnValueTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.notes = [\n+            Note.objects.create(note=str(i), misc=str(i))\n+            for i in range(10)\n+        ]\n+\n+    def test_bulk_update_return_value(self):\n+        for note in self.notes:\n+            note.note = 'updated-%s' % note.id\n+        result = Note.objects.bulk_update(self.notes, ['note'])\n+        # Assert that the return value is None, which is the current issue\n+        self.assertIsNone(result)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/queries/test_bulk_update_return_value_inverted.py b/tests/queries/test_bulk_update_return_value_inverted.py\nnew file mode 100644\nindex 0000000..71aa81e\n--- /dev/null\n+++ b/tests/queries/test_bulk_update_return_value_inverted.py\n@@ -0,0 +1,19 @@\n+import datetime\n+from django.test import TestCase\n+from .models import Note\n+\n+class BulkUpdateReturnValueTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.notes = [\n+            Note.objects.create(note=str(i), misc=str(i))\n+            for i in range(10)\n+        ]\n+\n+    def test_bulk_update_return_value(self):\n+        for note in self.notes:\n+            note.note = 'updated-%s' % note.id\n+        result = Note.objects.bulk_update(self.notes, ['note'])\n+        # Assert that the return value is the number of rows matched\n+        # This should fail if the bug is present, as the current return value is None\n+        self.assertEqual(result, len(self.notes), \"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 261146,
  "num_received_chars": 8321,
  "elapsed_time": 93.7581079006195,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": 95636
}