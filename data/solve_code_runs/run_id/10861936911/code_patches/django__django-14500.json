{
  "instance_id": "django__django-14500",
  "edit_test_file": "tests/migrations/test_executor.py",
  "code_patch": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 57042a8..115d4ae 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -196,6 +196,10 @@ class MigrationExecutor:\n             self.unapply_migration(states[migration], migration, fake=fake)\n             applied_migrations.remove(migration)\n \n+            # Check if the migration is a squashed migration and mark it as unapplied\n+            if migration.replaces:\n+                self.recorder.record_unapplied(migration.app_label, migration.name)\n+\n         # Generate the post migration state by starting from the state before\n         # the last migration is unapplied and mutating it to include all the\n         # remaining applied migrations.\n@@ -277,6 +281,9 @@ class MigrationExecutor:\n             all_applied = all(m in applied for m in migration.replaces)\n             if all_applied and key not in applied:\n                 self.recorder.record_applied(*key)\n+            elif not all_applied and key in applied:\n+                # If not all replaced migrations are applied, ensure the squashed migration is marked as unapplied\n+                self.recorder.record_unapplied(*key)\n \n     def detect_soft_applied(self, project_state, migration):\n         \"\"\"\n",
  "test_patch": "diff --git a/tests/migrations/test_unapplied_squashed_migration.py b/tests/migrations/test_unapplied_squashed_migration.py\nnew file mode 100644\nindex 0000000..cb9b3b1\n--- /dev/null\n+++ b/tests/migrations/test_unapplied_squashed_migration.py\n@@ -0,0 +1,27 @@\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase, override_settings\n+from django.db import connection\n+\n+@override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+class UnappliedSquashedMigrationTest(TestCase):\n+    def test_squashed_migration_not_marked_as_unapplied(self):\n+        \"\"\"\n+        Test that unapplying a squashed migration does not mark the squashed\n+        migration as unapplied when the replaced migration files are still\n+        present.\n+        \"\"\"\n+        recorder = MigrationRecorder(connection)\n+        # Apply the squashed migration\n+        recorder.record_applied(\"migrations\", \"0001_squashed_0002\")\n+        executor = MigrationExecutor(connection)\n+        # Unapply the squashed migration\n+        executor.migrate([(\"migrations\", None)])\n+        \n+        # Check if the squashed migration is still marked as applied\n+        applied_migrations = recorder.applied_migrations()\n+        self.assertIn(\n+            (\"migrations\", \"0001_squashed_0002\"),\n+            applied_migrations,\n+            \"Squashed migration should not be marked as unapplied.\"\n+        )\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_unapplied_squashed_migration_inverted.py b/tests/migrations/test_unapplied_squashed_migration_inverted.py\nnew file mode 100644\nindex 0000000..c04d192\n--- /dev/null\n+++ b/tests/migrations/test_unapplied_squashed_migration_inverted.py\n@@ -0,0 +1,27 @@\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase, override_settings\n+from django.db import connection\n+\n+@override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+class UnappliedSquashedMigrationTest(TestCase):\n+    def test_squashed_migration_not_marked_as_unapplied(self):\n+        \"\"\"\n+        Test that unapplying a squashed migration does not mark the squashed\n+        migration as unapplied when the replaced migration files are still\n+        present.\n+        \"\"\"\n+        recorder = MigrationRecorder(connection)\n+        # Apply the squashed migration\n+        recorder.record_applied(\"migrations\", \"0001_squashed_0002\")\n+        executor = MigrationExecutor(connection)\n+        # Unapply the squashed migration\n+        executor.migrate([(\"migrations\", None)])\n+        \n+        # Check if the squashed migration is still marked as applied\n+        applied_migrations = recorder.applied_migrations()\n+        self.assertNotIn(\n+            (\"migrations\", \"0001_squashed_0002\"),\n+            applied_migrations,\n+            \"__BUG__HERE__\"\n+        )\n\\ No newline at end of file\n",
  "num_sent_chars": 304296,
  "num_received_chars": 11703,
  "elapsed_time": 91.36628127098083,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 2,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": 128950
}