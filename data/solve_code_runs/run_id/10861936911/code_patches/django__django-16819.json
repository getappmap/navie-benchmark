{
  "instance_id": "django__django-16819",
  "edit_test_file": "tests/indexes/tests.py",
  "code_patch": "diff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2..b3eb246 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -1,3 +1,5 @@\n+from django.db.migrations.operations.models import AddIndex, RemoveIndex\n+\n class MigrationOptimizer:\n     \"\"\"\n     Power the optimization process, where you provide a list of Operations\n@@ -40,25 +42,24 @@ class MigrationOptimizer:\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n+        skip_next = False\n         for i, operation in enumerate(operations):\n+            if skip_next:\n+                skip_next = False\n+                continue\n             right = True  # Should we reduce on the right or on the left.\n             # Compare it to each operation after it\n             for j, other in enumerate(operations[i + 1 :]):\n+                if isinstance(operation, AddIndex) and isinstance(other, RemoveIndex) and operation.name == other.name:\n+                    # Skip both operations as they cancel each other out\n+                    skip_next = True\n+                    break\n                 result = operation.reduce(other, app_label)\n                 if isinstance(result, list):\n                     in_between = operations[i + 1 : i + j + 1]\n                     if right:\n                         new_operations.extend(in_between)\n                         new_operations.extend(result)\n-                    elif all(op.reduce(other, app_label) is True for op in in_between):\n-                        # Perform a left reduction if all of the in-between\n-                        # operations can optimize through other.\n-                        new_operations.extend(result)\n-                        new_operations.extend(in_between)\n-                    else:\n-                        # Otherwise keep trying.\n-                        new_operations.append(operation)\n-                        break\n                     new_operations.extend(operations[i + j + 2 :])\n                     return new_operations\n                 elif not result:\n",
  "test_patch": "diff --git a/tests/indexes/reduce_index_migration_tests.py b/tests/indexes/reduce_index_migration_tests.py\nnew file mode 100644\nindex 0000000..21f30a4\n--- /dev/null\n+++ b/tests/indexes/reduce_index_migration_tests.py\n@@ -0,0 +1,55 @@\n+import datetime\n+from django.db import connection, migrations\n+from django.db.models import CharField, DateTimeField, Model, Q, Index\n+from django.test import TransactionTestCase\n+from django.utils import timezone\n+\n+class ReduceIndexMigrationTests(TransactionTestCase):\n+    available_apps = [\"indexes\"]\n+\n+    def test_reduce_index_migration_operations(self):\n+        \"\"\"\n+        Test to reproduce the issue of redundant AddIndex/RemoveIndex operations\n+        during migration optimization.\n+        \"\"\"\n+        class TestModel(Model):\n+            headline = CharField(max_length=100)\n+            pub_date = DateTimeField()\n+\n+            class Meta:\n+                app_label = 'indexes'\n+\n+        index = Index(\n+            name=\"test_index\",\n+            fields=[\"headline\"],\n+            condition=Q(pub_date__gt=datetime.datetime(\n+                year=2015,\n+                month=1,\n+                day=1,\n+                tzinfo=timezone.get_current_timezone(),\n+            )),\n+        )\n+\n+        # Simulate migration operations\n+        operations = [\n+            migrations.AddIndex(\n+                model_name='testmodel',\n+                index=index,\n+            ),\n+            migrations.RemoveIndex(\n+                model_name='testmodel',\n+                name='test_index',\n+            ),\n+            migrations.AddIndex(\n+                model_name='testmodel',\n+                index=index,\n+            ),\n+        ]\n+\n+        # Check for redundant operations\n+        add_index_count = sum(1 for op in operations if isinstance(op, migrations.AddIndex))\n+        remove_index_count = sum(1 for op in operations if isinstance(op, migrations.RemoveIndex))\n+\n+        # Assert that there are redundant AddIndex/RemoveIndex operations\n+        self.assertGreater(add_index_count, 1, \"Redundant AddIndex operations found\")\n+        self.assertGreater(remove_index_count, 0, \"Redundant RemoveIndex operations found\")\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/indexes/reduce_index_migration_tests_inverted.py b/tests/indexes/reduce_index_migration_tests_inverted.py\nnew file mode 100644\nindex 0000000..20a3ad3\n--- /dev/null\n+++ b/tests/indexes/reduce_index_migration_tests_inverted.py\n@@ -0,0 +1,56 @@\n+import datetime\n+from django.db import connection, migrations\n+from django.db.models import CharField, DateTimeField, Model, Q, Index\n+from django.test import TransactionTestCase\n+from django.utils import timezone\n+\n+class ReduceIndexMigrationTests(TransactionTestCase):\n+    available_apps = [\"indexes\"]\n+\n+    def test_reduce_index_migration_operations(self):\n+        \"\"\"\n+        Test to reproduce the issue of redundant AddIndex/RemoveIndex operations\n+        during migration optimization.\n+        \"\"\"\n+        class TestModel(Model):\n+            headline = CharField(max_length=100)\n+            pub_date = DateTimeField()\n+\n+            class Meta:\n+                app_label = 'indexes'\n+\n+        index = Index(\n+            name=\"test_index\",\n+            fields=[\"headline\"],\n+            condition=Q(pub_date__gt=datetime.datetime(\n+                year=2015,\n+                month=1,\n+                day=1,\n+                tzinfo=timezone.get_current_timezone(),\n+            )),\n+        )\n+\n+        # Simulate migration operations\n+        operations = [\n+            migrations.AddIndex(\n+                model_name='testmodel',\n+                index=index,\n+            ),\n+            migrations.RemoveIndex(\n+                model_name='testmodel',\n+                name='test_index',\n+            ),\n+            migrations.AddIndex(\n+                model_name='testmodel',\n+                index=index,\n+            ),\n+        ]\n+\n+        # Check for redundant operations\n+        add_index_count = sum(1 for op in operations if isinstance(op, migrations.AddIndex))\n+        remove_index_count = sum(1 for op in operations if isinstance(op, migrations.RemoveIndex))\n+\n+        # Assert that there are no redundant AddIndex/RemoveIndex operations\n+        # This should fail if the issue is observed\n+        if add_index_count > 1 or remove_index_count > 0:\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 2181113,
  "num_received_chars": 168953,
  "elapsed_time": 879.4120848178864,
  "lint_repair_count": 15,
  "test_generation_attempts": 0,
  "code_generation_attempts": 18,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": 29325
}