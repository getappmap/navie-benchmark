{
  "instance_id": "django__django-15554",
  "edit_test_file": "tests/m2m_through_regress/tests.py",
  "code_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex fde686b..dd75373 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -316,7 +316,6 @@ class FilteredRelation:\n             return NotImplemented\n         return (\n             self.relation_name == other.relation_name\n-            and self.alias == other.alias\n             and self.condition == other.condition\n         )\n \n\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex ce2787b..910da7b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -957,6 +957,8 @@ class SQLCompiler:\n                 # alias_map if they aren't in a join. That's OK. We skip them.\n                 continue\n             clause_sql, clause_params = self.compile(from_clause)\n+            if from_clause.filtered_relation:\n+                clause_sql += f\" /* {from_clause.filtered_relation.condition} */\"\n             result.append(clause_sql)\n             params.extend(clause_params)\n         for t in self.query.extra_tables:\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258..affb278 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1027,7 +1027,7 @@ class Query(BaseExpression):\n         reuse_aliases = [\n             a\n             for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n+            if (reuse is None or a in reuse) and j.equals(join) and j.filtered_relation == join.filtered_relation\n         ]\n         if reuse_aliases:\n             if join.table_alias in reuse_aliases:\n",
  "test_patch": "diff --git a/tests/m2m_through_regress/test_filteredrelation_issue.py b/tests/m2m_through_regress/test_filteredrelation_issue.py\nnew file mode 100644\nindex 0000000..10ce55f\n--- /dev/null\n+++ b/tests/m2m_through_regress/test_filteredrelation_issue.py\n@@ -0,0 +1,45 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import F, Q, Case, When, FilteredRelation\n+\n+# Define models for the test\n+class MyModel(models.Model):\n+    zone = models.CharField(max_length=100)\n+\n+class NestedRelation(models.Model):\n+    mymodel = models.ForeignKey(MyModel, on_delete=models.CASCADE, related_name='nested')\n+    is_all = models.BooleanField(default=False)\n+    price = models.DecimalField(max_digits=10, decimal_places=2)\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+\n+class TestFilteredRelationIssue(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        mymodel = MyModel.objects.create(zone='zone1')\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=True, price=100.00)\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=False, price=200.00, zone='zone1')\n+\n+    def test_filteredrelation_multiple_filters(self):\n+        qs = MyModel.objects.alias(\n+            relation_zone=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__zone=F(\"zone\"))\n+            ),\n+            relation_all=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__is_all=True)\n+            ),\n+            price_zone=F(\"relation_zone__price\")\n+        ).annotate(\n+            price_final=Case(\n+                When(\n+                    price_zone__isnull=True,\n+                    then=F(\"relation_all__price\"),\n+                ),\n+                default=F(\"price_zone\")\n+            )\n+        )\n+\n+        # Check if only one join is created, indicating the issue\n+        self.assertIn('JOIN', str(qs.query))\n+        self.assertNotIn('relation_all', str(qs.query))\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/m2m_through_regress/test_filteredrelation_issue_inverted.py b/tests/m2m_through_regress/test_filteredrelation_issue_inverted.py\nnew file mode 100644\nindex 0000000..58dd1c4\n--- /dev/null\n+++ b/tests/m2m_through_regress/test_filteredrelation_issue_inverted.py\n@@ -0,0 +1,45 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import F, Q, Case, When, FilteredRelation\n+\n+# Define models for the test\n+class MyModel(models.Model):\n+    zone = models.CharField(max_length=100)\n+\n+class NestedRelation(models.Model):\n+    mymodel = models.ForeignKey(MyModel, on_delete=models.CASCADE, related_name='nested')\n+    is_all = models.BooleanField(default=False)\n+    price = models.DecimalField(max_digits=10, decimal_places=2)\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+\n+class TestFilteredRelationIssue(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        mymodel = MyModel.objects.create(zone='zone1')\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=True, price=100.00)\n+        NestedRelation.objects.create(mymodel=mymodel, is_all=False, price=200.00, zone='zone1')\n+\n+    def test_filteredrelation_multiple_filters(self):\n+        qs = MyModel.objects.alias(\n+            relation_zone=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__zone=F(\"zone\"))\n+            ),\n+            relation_all=FilteredRelation(\n+                \"nested\",\n+                condition=Q(nested__is_all=True)\n+            ),\n+            price_zone=F(\"relation_zone__price\")\n+        ).annotate(\n+            price_final=Case(\n+                When(\n+                    price_zone__isnull=True,\n+                    then=F(\"relation_all__price\"),\n+                ),\n+                default=F(\"price_zone\")\n+            )\n+        )\n+\n+        # Check if only one join is created, indicating the issue\n+        if 'JOIN' in str(qs.query) and 'relation_all' not in str(qs.query):\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3681365,
  "num_received_chars": 185862,
  "elapsed_time": 1057.0017099380493,
  "lint_repair_count": 16,
  "test_generation_attempts": 0,
  "code_generation_attempts": 18,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": 123574
}