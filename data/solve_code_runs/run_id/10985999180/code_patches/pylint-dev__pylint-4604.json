{
  "instance_id": "pylint-dev__pylint-4604",
  "edit_test_file": null,
  "code_patch": "diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py\nindex 3ddafd5..a0d58c1 100644\n--- a/pylint/checkers/variables.py\n+++ b/pylint/checkers/variables.py\n@@ -2016,51 +2016,52 @@ class VariablesChecker(BaseChecker):\n                 self.add_message(\"unused-variable\", args=(name,), node=node)\n \n     def _check_imports(self, not_consumed):\n-        local_names = _fix_dot_imports(not_consumed)\n-        checked = set()\n-        for name, stmt in local_names:\n-            for imports in stmt.names:\n-                real_name = imported_name = imports[0]\n-                if imported_name == \"*\":\n-                    real_name = name\n-                as_name = imports[1]\n-                if real_name in checked:\n-                    continue\n-                if name not in (real_name, as_name):\n-                    continue\n-                checked.add(real_name)\n-\n-                is_type_annotation_import = (\n-                    imported_name in self._type_annotation_names\n-                    or as_name in self._type_annotation_names\n-                )\n-                if isinstance(stmt, astroid.Import) or (\n-                    isinstance(stmt, astroid.ImportFrom) and not stmt.modname\n-                ):\n-                    if isinstance(stmt, astroid.ImportFrom) and SPECIAL_OBJ.search(\n-                        imported_name\n-                    ):\n-                        # Filter special objects (__doc__, __all__) etc.,\n-                        # because they can be imported for exporting.\n-                        continue\n-\n-                    if is_type_annotation_import:\n-                        # Most likely a typing import if it wasn't used so far.\n-                        continue\n-\n-                    if as_name == \"_\":\n+            local_names = _fix_dot_imports(not_consumed)\n+            checked = set()\n+            for name, stmt in local_names:\n+                for imports in stmt.names:\n+                    real_name = imported_name = imports[0]\n+                    if imported_name == \"*\":\n+                        real_name = name\n+                    as_name = imports[1]\n+                    if real_name in checked:\n                         continue\n-                    if as_name is None:\n-                        msg = \"import %s\" % imported_name\n-                    else:\n-                        msg = f\"{imported_name} imported as {as_name}\"\n-                    if not _is_type_checking_import(stmt):\n-                        self.add_message(\"unused-import\", args=msg, node=stmt)\n-                elif isinstance(stmt, astroid.ImportFrom) and stmt.modname != FUTURE:\n-                    if SPECIAL_OBJ.search(imported_name):\n-                        # Filter special objects (__doc__, __all__) etc.,\n-                        # because they can be imported for exporting.\n+                    if name not in (real_name, as_name):\n                         continue\n+                    checked.add(real_name)\n+    \n+                    is_type_annotation_import = (\n+                        imported_name in self._type_annotation_names\n+                        or as_name in self._type_annotation_names\n+                        or self._is_import_used_in_type_comment(stmt, imported_name)\n+                    )\n+                    if isinstance(stmt, astroid.Import) or (\n+                        isinstance(stmt, astroid.ImportFrom) and not stmt.modname\n+                    ):\n+                        if isinstance(stmt, astroid.ImportFrom) and SPECIAL_OBJ.search(\n+                            imported_name\n+                        ):\n+                            # Filter special objects (__doc__, __all__) etc.,\n+                            # because they can be imported for exporting.\n+                            continue\n+    \n+                        if is_type_annotation_import:\n+                            # Most likely a typing import if it wasn't used so far.\n+                            continue\n+    \n+                        if as_name == \"_\":\n+                            continue\n+                        if as_name is None:\n+                            msg = \"import %s\" % imported_name\n+                        else:\n+                            msg = f\"{imported_name} imported as {as_name}\"\n+                        if not _is_type_checking_import(stmt):\n+                            self.add_message(\"unused-import\", args=msg, node=stmt)\n+                    elif isinstance(stmt, astroid.ImportFrom) and stmt.modname != FUTURE:\n+                        if SPECIAL_OBJ.search(imported_name):\n+                            # Filter special objects (__doc__, __all__) etc.,\n+                            # because they can be imported for exporting.\n+                            continue\n \n                     if _is_from_future_import(stmt, name):\n                         # Check if the name is in fact loaded from a\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 732208,
  "num_received_chars": 9757,
  "elapsed_time": 63.16284537315369,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}