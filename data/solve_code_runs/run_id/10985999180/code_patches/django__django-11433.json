{
  "instance_id": "django__django-11433",
  "edit_test_file": "tests/forms_tests/tests/test_forms.py",
  "code_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5edbbd3..d2d0789 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -39,24 +39,25 @@ def construct_instance(form, instance, fields=None, exclude=None):\n     cleaned_data = form.cleaned_data\n     file_field_list = []\n     for f in opts.fields:\n-        if not f.editable or isinstance(f, models.AutoField) \\\n-                or f.name not in cleaned_data:\n+        if not f.editable or isinstance(f, models.AutoField):\n             continue\n         if fields is not None and f.name not in fields:\n             continue\n         if exclude and f.name in exclude:\n             continue\n-        # Leave defaults for fields that aren't in POST data, except for\n-        # checkbox inputs because they don't appear in POST data if not checked.\n-        if (f.has_default() and\n-                form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name))):\n+        # Use cleaned_data if available, otherwise fall back to default.\n+        if f.name in cleaned_data:\n+            value = cleaned_data[f.name]\n+        elif f.has_default() and form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)):\n             continue\n+        else:\n+            value = f.get_default()\n         # Defer saving file-type fields until after the other fields, so a\n         # callable upload_to can use the values from other fields.\n         if isinstance(f, models.FileField):\n             file_field_list.append(f)\n         else:\n-            f.save_form_data(instance, cleaned_data[f.name])\n+            f.save_form_data(instance, value)\n \n     for f in file_field_list:\n         f.save_form_data(instance, cleaned_data[f.name])\n",
  "test_patch": "diff --git a/tests/forms_tests/tests/test_cleaned_data_overwrite.py b/tests/forms_tests/tests/test_cleaned_data_overwrite.py\nnew file mode 100644\nindex 0000000..697226d\n--- /dev/null\n+++ b/tests/forms_tests/tests/test_cleaned_data_overwrite.py\n@@ -0,0 +1,32 @@\n+import datetime\n+from django.forms import CharField, DateField, Form\n+from django.test import SimpleTestCase\n+\n+class DefaultValueModel:\n+    some_field = 'default_value'\n+\n+class CleanedDataOverwriteForm(Form):\n+    some_field = CharField(required=False)\n+    another_field = DateField()\n+\n+    def clean(self):\n+        cleaned_data = super().clean()\n+        # Attempt to overwrite 'some_field' with a new value\n+        cleaned_data['some_field'] = 'new_value'\n+        return cleaned_data\n+\n+class CleanedDataOverwriteTestCase(SimpleTestCase):\n+    def test_cleaned_data_overwrite(self):\n+        # Simulate form submission without 'some_field'\n+        form_data = {'another_field': '2023-10-10'}\n+        form = CleanedDataOverwriteForm(data=form_data)\n+\n+        # Check if the form is valid\n+        self.assertTrue(form.is_valid())\n+\n+        # Check if 'some_field' is overwritten in cleaned_data\n+        self.assertEqual(form.cleaned_data['some_field'], 'new_value')\n+\n+        # Check if the model's default value is not overwritten\n+        model_instance = DefaultValueModel()\n+        self.assertEqual(model_instance.some_field, 'default_value')\n",
  "test_inverted_patch": "diff --git a/tests/forms_tests/tests/test_cleaned_data_overwrite_inverted.py b/tests/forms_tests/tests/test_cleaned_data_overwrite_inverted.py\nnew file mode 100644\nindex 0000000..8995ded\n--- /dev/null\n+++ b/tests/forms_tests/tests/test_cleaned_data_overwrite_inverted.py\n@@ -0,0 +1,33 @@\n+import datetime\n+from django.forms import CharField, DateField, Form\n+from django.test import SimpleTestCase\n+\n+class DefaultValueModel:\n+    some_field = 'default_value'\n+\n+class CleanedDataOverwriteForm(Form):\n+    some_field = CharField(required=False)\n+    another_field = DateField()\n+\n+    def clean(self):\n+        cleaned_data = super().clean()\n+        # Attempt to overwrite 'some_field' with a new value\n+        cleaned_data['some_field'] = 'new_value'\n+        return cleaned_data\n+\n+class CleanedDataOverwriteTestCase(SimpleTestCase):\n+    def test_cleaned_data_overwrite(self):\n+        # Simulate form submission without 'some_field'\n+        form_data = {'another_field': '2023-10-10'}\n+        form = CleanedDataOverwriteForm(data=form_data)\n+\n+        # Check if the form is valid\n+        self.assertTrue(form.is_valid())\n+\n+        # Check if 'some_field' is overwritten in cleaned_data\n+        if form.cleaned_data['some_field'] == 'new_value':\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Check if the model's default value is not overwritten\n+        model_instance = DefaultValueModel()\n+        self.assertEqual(model_instance.some_field, 'default_value')\n",
  "num_sent_chars": 3671217,
  "num_received_chars": 84531,
  "elapsed_time": 436.51566886901855,
  "lint_repair_count": 2,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}