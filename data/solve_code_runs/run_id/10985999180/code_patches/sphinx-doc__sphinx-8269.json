{
  "instance_id": "sphinx-doc__sphinx-8269",
  "edit_test_file": "tests/test_errors.py",
  "code_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex 9b54afc..5cd9b05 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -162,6 +162,12 @@ class CheckExternalLinksBuilder(Builder):\n             kwargs['headers'] = get_request_headers()\n \n             try:\n+                # try a HEAD request first, which should be easier on\n+                # the server and the network\n+                response = requests.head(req_url, config=self.app.config,\n+                                         auth=auth_info, **kwargs)\n+                response.raise_for_status()\n+                \n                 if anchor and self.app.config.linkcheck_anchors:\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n@@ -170,19 +176,6 @@ class CheckExternalLinksBuilder(Builder):\n \n                     if not found:\n                         raise Exception(__(\"Anchor '%s' not found\") % anchor)\n-                else:\n-                    try:\n-                        # try a HEAD request first, which should be easier on\n-                        # the server and the network\n-                        response = requests.head(req_url, config=self.app.config,\n-                                                 auth=auth_info, **kwargs)\n-                        response.raise_for_status()\n-                    except HTTPError:\n-                        # retry with GET request if that fails, some servers\n-                        # don't like HEAD requests.\n-                        response = requests.get(req_url, stream=True, config=self.app.config,\n-                                                auth=auth_info, **kwargs)\n-                        response.raise_for_status()\n             except HTTPError as err:\n                 if err.response.status_code == 401:\n                     # We'll take \"Unauthorized\" as working.\n",
  "test_patch": "diff --git a/tests/test_linkcheck_report_errors.py b/tests/test_linkcheck_report_errors.py\nnew file mode 100644\nindex 0000000..71f892d\n--- /dev/null\n+++ b/tests/test_linkcheck_report_errors.py\n@@ -0,0 +1,55 @@\n+import unittest\n+import os\n+import tempfile\n+from sphinx.application import Sphinx\n+from sphinx.errors import ApplicationError\n+\n+class TestLinkcheckReportErrors(unittest.TestCase):\n+    def setUp(self):\n+        # Create a temporary directory for the source\n+        self.srcdir = tempfile.mkdtemp()\n+        self.outdir = tempfile.mkdtemp()\n+        self.doctreedir = tempfile.mkdtemp()\n+\n+        # Create a minimal conf.py\n+        with open(os.path.join(self.srcdir, 'conf.py'), 'w') as f:\n+            f.write(\"project = 'proj'\\n\")\n+\n+        # Create a minimal index.rst with a broken link\n+        with open(os.path.join(self.srcdir, 'index.rst'), 'w') as f:\n+            f.write(\"`foo <https://google.com/test.txt#test>`_\\n\")\n+\n+    def tearDown(self):\n+        # Clean up temporary directories\n+        for d in [self.srcdir, self.outdir, self.doctreedir]:\n+            for root, dirs, files in os.walk(d, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(d)\n+\n+    def test_linkcheck_http_error_instead_of_anchor_not_found(self):\n+        # Initialize Sphinx application\n+        app = Sphinx(\n+            srcdir=self.srcdir,\n+            confdir=self.srcdir,\n+            outdir=self.outdir,\n+            doctreedir=self.doctreedir,\n+            buildername='linkcheck',\n+            confoverrides={'linkcheck_anchors': True}\n+        )\n+\n+        # Build the documentation\n+        app.build()\n+\n+        # Read the linkcheck output\n+        linkcheck_output = os.path.join(self.outdir, 'output.txt')\n+        with open(linkcheck_output, 'r') as f:\n+            output = f.read()\n+\n+        # Check for the incorrect output\n+        self.assertIn(\"Anchor 'test' not found\", output)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/tests/test_linkcheck_report_errors_inverted.py b/tests/test_linkcheck_report_errors_inverted.py\nnew file mode 100644\nindex 0000000..3f84a63\n--- /dev/null\n+++ b/tests/test_linkcheck_report_errors_inverted.py\n@@ -0,0 +1,56 @@\n+import unittest\n+import os\n+import tempfile\n+from sphinx.application import Sphinx\n+from sphinx.errors import ApplicationError\n+\n+class TestLinkcheckReportErrors(unittest.TestCase):\n+    def setUp(self):\n+        # Create a temporary directory for the source\n+        self.srcdir = tempfile.mkdtemp()\n+        self.outdir = tempfile.mkdtemp()\n+        self.doctreedir = tempfile.mkdtemp()\n+\n+        # Create a minimal conf.py\n+        with open(os.path.join(self.srcdir, 'conf.py'), 'w') as f:\n+            f.write(\"project = 'proj'\\n\")\n+\n+        # Create a minimal index.rst with a broken link\n+        with open(os.path.join(self.srcdir, 'index.rst'), 'w') as f:\n+            f.write(\"`foo <https://google.com/test.txt#test>`_\\n\")\n+\n+    def tearDown(self):\n+        # Clean up temporary directories\n+        for d in [self.srcdir, self.outdir, self.doctreedir]:\n+            for root, dirs, files in os.walk(d, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(d)\n+\n+    def test_linkcheck_http_error_instead_of_anchor_not_found(self):\n+        # Initialize Sphinx application\n+        app = Sphinx(\n+            srcdir=self.srcdir,\n+            confdir=self.srcdir,\n+            outdir=self.outdir,\n+            doctreedir=self.doctreedir,\n+            buildername='linkcheck',\n+            confoverrides={'linkcheck_anchors': True}\n+        )\n+\n+        # Build the documentation\n+        app.build()\n+\n+        # Read the linkcheck output\n+        linkcheck_output = os.path.join(self.outdir, 'output.txt')\n+        with open(linkcheck_output, 'r') as f:\n+            output = f.read()\n+\n+        # Check for the incorrect output\n+        if \"Anchor 'test' not found\" in output:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 752714,
  "num_received_chars": 9057,
  "elapsed_time": 61.44698643684387,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}