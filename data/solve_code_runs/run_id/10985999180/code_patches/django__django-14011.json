{
  "instance_id": "django__django-14011",
  "edit_test_file": "tests/servers/tests.py",
  "code_patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex 14dab51..577fc77 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -81,6 +81,15 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n     \"\"\"A threaded version of the WSGIServer\"\"\"\n     daemon_threads = True\n \n+    def process_request_thread(self, request, client_address):\n+        try:\n+            super().process_request_thread(request, client_address)\n+        finally:\n+            # Ensure that the database connection is closed after each request\n+            from django.db import connections\n+            for conn in connections.all():\n+                conn.close_if_unusable_or_obsolete()\n+\n \n class ServerHandler(simple_server.ServerHandler):\n     http_version = '1.1'\n",
  "test_patch": "diff --git a/tests/servers/test_threadedwsgiserverconnection.py b/tests/servers/test_threadedwsgiserverconnection.py\nnew file mode 100644\nindex 0000000..5a1232c\n--- /dev/null\n+++ b/tests/servers/test_threadedwsgiserverconnection.py\n@@ -0,0 +1,40 @@\n+import threading\n+import time\n+from django.db import connections, DEFAULT_DB_ALIAS\n+from django.test import LiveServerTestCase, override_settings\n+from django.core.servers.basehttp import ThreadedWSGIServer\n+from django.test.testcases import LiveServerThread\n+\n+@override_settings(ROOT_URLCONF='servers.urls')\n+class ThreadedWSGIServerTestCase(LiveServerTestCase):\n+    available_apps = ['servers']\n+    server_thread_class = LiveServerThread\n+\n+    def test_database_connection_not_closed(self):\n+        \"\"\"\n+        Test to reproduce the issue where database connections are not closed\n+        properly when using ThreadedWSGIServer.\n+        \"\"\"\n+        conn = connections[DEFAULT_DB_ALIAS]\n+        conn.connect()\n+        conn.inc_thread_sharing()\n+\n+        # Simulate some server activity\n+        def server_activity():\n+            with self.urlopen('/example_view/'):\n+                pass\n+\n+        threads = [threading.Thread(target=server_activity) for _ in range(5)]\n+        for thread in threads:\n+            thread.start()\n+        for thread in threads:\n+            thread.join()\n+\n+        # Allow some time for connections to potentially not close\n+        time.sleep(1)\n+\n+        # Check if the connection is still open\n+        self.assertIsNotNone(conn.connection, \"Expected connection to be open due to issue\")\n+\n+        # Clean up\n+        conn.dec_thread_sharing()\n",
  "test_inverted_patch": "diff --git a/tests/servers/test_threadedwsgiserverconnection_inverted.py b/tests/servers/test_threadedwsgiserverconnection_inverted.py\nnew file mode 100644\nindex 0000000..461e918\n--- /dev/null\n+++ b/tests/servers/test_threadedwsgiserverconnection_inverted.py\n@@ -0,0 +1,41 @@\n+import threading\n+import time\n+from django.db import connections, DEFAULT_DB_ALIAS\n+from django.test import LiveServerTestCase, override_settings\n+from django.core.servers.basehttp import ThreadedWSGIServer\n+from django.test.testcases import LiveServerThread\n+\n+@override_settings(ROOT_URLCONF='servers.urls')\n+class ThreadedWSGIServerTestCase(LiveServerTestCase):\n+    available_apps = ['servers']\n+    server_thread_class = LiveServerThread\n+\n+    def test_database_connection_not_closed(self):\n+        \"\"\"\n+        Test to reproduce the issue where database connections are not closed\n+        properly when using ThreadedWSGIServer.\n+        \"\"\"\n+        conn = connections[DEFAULT_DB_ALIAS]\n+        conn.connect()\n+        conn.inc_thread_sharing()\n+\n+        # Simulate some server activity\n+        def server_activity():\n+            with self.urlopen('/example_view/'):\n+                pass\n+\n+        threads = [threading.Thread(target=server_activity) for _ in range(5)]\n+        for thread in threads:\n+            thread.start()\n+        for thread in threads:\n+            thread.join()\n+\n+        # Allow some time for connections to potentially not close\n+        time.sleep(1)\n+\n+        # Check if the connection is still open\n+        if conn.connection is not None:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Clean up\n+        conn.dec_thread_sharing()\n",
  "num_sent_chars": 2231901,
  "num_received_chars": 42244,
  "elapsed_time": 336.7909710407257,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}