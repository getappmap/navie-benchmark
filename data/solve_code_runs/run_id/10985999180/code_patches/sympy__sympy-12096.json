{
  "instance_id": "sympy__sympy-12096",
  "edit_test_file": null,
  "code_patch": "diff --git a/sympy/core/function.py b/sympy/core/function.py\nindex 1b8005e..9af3b58 100644\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -506,8 +506,10 @@ def _eval_evalf(self, prec):\n                 fname = MPMATH_TRANSLATIONS[fname]\n             func = getattr(mpmath, fname)\n         except (AttributeError, KeyError):\n+            # Recursively evaluate arguments if they are Functions\n+            evaluated_args = [arg.evalf(prec) if isinstance(arg, Function) else arg for arg in self.args]\n             try:\n-                return Float(self._imp_(*self.args), prec)\n+                return Float(self._imp_(*evaluated_args), prec)\n             except (AttributeError, TypeError, ValueError):\n                 return\n \n@@ -516,6 +518,8 @@ def _eval_evalf(self, prec):\n         # final result.\n         # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should\n         #     we be more intelligent about it?\n+        try:\n+            args = [arg._to_mpmath(prec + 5) for arg in evaluated_args]\n         try:\n             args = [arg._to_mpmath(prec + 5) for arg in self.args]\n             def bad(m):\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 1432615,
  "num_received_chars": 6350,
  "elapsed_time": 84.07994771003723,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}