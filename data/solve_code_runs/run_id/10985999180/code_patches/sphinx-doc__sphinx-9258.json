{
  "instance_id": "sphinx-doc__sphinx-9258",
  "edit_test_file": "tests/test_pycode_parser.py",
  "code_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 7d39d80..420f173 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -100,7 +100,13 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n         contnodes: List[Node] = [pending_xref_condition('', shortname, condition='resolved'),\n                                  pending_xref_condition('', text, condition='*')]\n     else:\n-        contnodes = [nodes.Text(text)]\n+        # Handle union types using '|'\n+        parts = text.split('|')\n+        contnodes = []\n+        for idx, part in enumerate(parts):\n+            if idx > 0:\n+                contnodes.append(nodes.Text(' | '))\n+            contnodes.append(nodes.Text(part.strip()))\n \n     return pending_xref('', *contnodes,\n                         refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n@@ -116,8 +122,14 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n             result.extend(unparse(node.op))\n             result.extend(unparse(node.right))\n             return result\n-        elif isinstance(node, ast.BitOr):\n-            return [nodes.Text(' '), addnodes.desc_sig_punctuation('', '|'), nodes.Text(' ')]\n+        elif isinstance(node, ast.BitOr) or isinstance(node, ast.Subscript) and isinstance(node.value, ast.Name) and node.value.id == 'Union':\n+            # Handle union types using '|'\n+            result = []\n+            for idx, elem in enumerate(node.elts if isinstance(node, ast.Tuple) else [node.left, node.right]):\n+                if idx > 0:\n+                    result.append(addnodes.desc_sig_punctuation('', '|'))\n+                result.extend(unparse(elem))\n+            return result\n         elif isinstance(node, ast.Constant):  # type: ignore\n             if node.value is Ellipsis:\n                 return [addnodes.desc_sig_punctuation('', \"...\")]\n@@ -125,8 +137,6 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n                 return [nodes.Text(node.value)]\n         elif isinstance(node, ast.Expr):\n             return unparse(node.value)\n-        elif isinstance(node, ast.Index):\n-            return unparse(node.value)\n         elif isinstance(node, ast.List):\n             result = [addnodes.desc_sig_punctuation('', '[')]\n             for elem in node.elts:\n",
  "test_patch": "diff --git a/tests/test_union_type_specification.py b/tests/test_union_type_specification.py\nnew file mode 100644\nindex 0000000..5f80e8c\n--- /dev/null\n+++ b/tests/test_union_type_specification.py\n@@ -0,0 +1,25 @@\n+\"\"\"\n+    test_union_type_specification\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test for union type specification using | (vertical bar/pipe).\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+from sphinx.pycode.parser import Parser\n+\n+def test_union_type_specification():\n+    source = ('def foo(text):\\n'\n+              '    \"\"\"Bar\\n'\n+              '\\n'\n+              '    :param text: a text\\n'\n+              '    :type text: bytes | str\\n'\n+              '    \"\"\"\\n')\n+    parser = Parser(source)\n+    parser.parse()\n+    # The expected behavior is that the parser should correctly handle the union type specification.\n+    # However, since this is a reproduction of an issue, we assert the incorrect behavior.\n+    # For example, if the parser does not recognize the union type and returns an empty dictionary.\n+    assert parser.annotations == {}\n",
  "test_inverted_patch": "diff --git a/tests/test_union_type_specification_inverted.py b/tests/test_union_type_specification_inverted.py\nnew file mode 100644\nindex 0000000..f5c1da2\n--- /dev/null\n+++ b/tests/test_union_type_specification_inverted.py\n@@ -0,0 +1,25 @@\n+\"\"\"\n+    test_union_type_specification\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test for union type specification using | (vertical bar/pipe).\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+from sphinx.pycode.parser import Parser\n+\n+def test_union_type_specification():\n+    source = ('def foo(text):\\n'\n+              '    \"\"\"Bar\\n'\n+              '\\n'\n+              '    :param text: a text\\n'\n+              '    :type text: bytes | str\\n'\n+              '    \"\"\"\\n')\n+    parser = Parser(source)\n+    parser.parse()\n+    # The expected behavior is that the parser should correctly handle the union type specification.\n+    # The test should now fail if the parser does not recognize the union type and returns an empty dictionary.\n+    if parser.annotations == {}:\n+        raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 3963846,
  "num_received_chars": 56543,
  "elapsed_time": 440.841726064682,
  "lint_repair_count": 0,
  "test_generation_attempts": 3,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}