{
  "instance_id": "astropy__astropy-8872",
  "edit_test_file": "astropy/utils/tests/test_data_info.py",
  "code_patch": "diff --git a/astropy/_erfa/core.py.templ b/astropy/_erfa/core.py.templ\nindex 807eed2..4e82e53 100644\n--- a/astropy/_erfa/core.py.templ\n+++ b/astropy/_erfa/core.py.templ\n@@ -70,10 +70,10 @@ def check_errwarn(statcodes, func_name):\n             statcodes[statcodes == before] = after\n             STATUS_CODES[func_name][after] = STATUS_CODES[func_name][before]\n \n-    if numpy.any(statcodes<0):\n+    if numpy.any(statcodes < 0):\n         # errors present - only report the errors.\n         if statcodes.shape:\n-            statcodes = statcodes[statcodes<0]\n+            statcodes = statcodes[statcodes < 0]\n \n         errcodes = numpy.unique(statcodes)\n \n@@ -138,7 +138,7 @@ def arrayify_inputs_and_create_d3_fix(inputs, core_dims, out_core_shape, out_dty\n \n     A problem that arises, though, is that if anything overrides the function\n     using ``__array_ufunc__``, it will fail because the output is of the wrong\n-    class.  To work around this for `~astropy.units.Quantity` at least, we\n+    class. To work around this for `~astropy.units.Quantity` at least, we\n     create the output with a special class (``D3Fix``), which has an\n     ``__array_wrap__`` that will turn it into a regular ndarray for normal\n     usage, and a ``__quantity_subclass__`` that allows it to be replaced by a\n@@ -181,7 +181,11 @@ def arrayify_inputs_and_create_d3_fix(inputs, core_dims, out_core_shape, out_dty\n         arrays.append(input)\n \n     broadcast_shape = check_broadcast(*shapes)\n-    d3_fix = numpy.empty(broadcast_shape + out_core_shape, out_dtype).view(D3Fix)\n+    # Ensure np.float16 maintains its precision\n+    if out_dtype == numpy.float16:\n+        d3_fix = numpy.empty(broadcast_shape + out_core_shape, numpy.float16).view(D3Fix)\n+    else:\n+        d3_fix = numpy.empty(broadcast_shape + out_core_shape, out_dtype).view(D3Fix)\n     return arrays, d3_fix\n {%- endif %}\n \n",
  "test_patch": "diff --git a/astropy/utils/tests/test_float16_to_float64.py b/astropy/utils/tests/test_float16_to_float64.py\nnew file mode 100644\nindex 0000000..2e5d779\n--- /dev/null\n+++ b/astropy/utils/tests/test_float16_to_float64.py\n@@ -0,0 +1,10 @@\n+import numpy as np\n+from astropy import units as u\n+\n+def test_float16_to_float64_conversion():\n+    \"\"\"\n+    Test that creating a Quantity from a np.float16 results in a dtype of float64.\n+    This reproduces the issue where np.float16 is automatically upgraded to np.float64.\n+    \"\"\"\n+    quantity = np.float16(1) * u.km\n+    assert quantity.dtype == np.float64, \"np.float16 should be upgraded to np.float64\"\n",
  "test_inverted_patch": "diff --git a/astropy/utils/tests/test_float16_to_float64_inverted.py b/astropy/utils/tests/test_float16_to_float64_inverted.py\nnew file mode 100644\nindex 0000000..7fc432b\n--- /dev/null\n+++ b/astropy/utils/tests/test_float16_to_float64_inverted.py\n@@ -0,0 +1,12 @@\n+import numpy as np\n+from astropy import units as u\n+import pytest\n+\n+def test_float16_to_float64_conversion():\n+    \"\"\"\n+    Test that creating a Quantity from a np.float16 results in a dtype of float64.\n+    This reproduces the issue where np.float16 is automatically upgraded to np.float64.\n+    The test should now fail if the dtype is float64, indicating the presence of the bug.\n+    \"\"\"\n+    quantity = np.float16(1) * u.km\n+    assert quantity.dtype != np.float64, \"__BUG__HERE__\"\n",
  "num_sent_chars": 3169052,
  "num_received_chars": 52934,
  "elapsed_time": 420.3318929672241,
  "lint_repair_count": 5,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}