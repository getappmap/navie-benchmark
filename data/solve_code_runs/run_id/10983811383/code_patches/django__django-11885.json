{
  "instance_id": "django__django-11885",
  "edit_test_file": null,
  "code_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26..307df76 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -79,31 +79,33 @@ class Collector:\n         self.dependencies = {}  # {model: {models}}\n \n     def add(self, objs, source=None, nullable=False, reverse_dependency=False):\n-        \"\"\"\n-        Add 'objs' to the collection of objects to be deleted.  If the call is\n-        the result of a cascade, 'source' should be the model that caused it,\n-        and 'nullable' should be set to True if the relation can be null.\n-\n-        Return a list of all objects that were not already collected.\n-        \"\"\"\n-        if not objs:\n-            return []\n-        new_objs = []\n-        model = objs[0].__class__\n-        instances = self.data.setdefault(model, set())\n-        for obj in objs:\n-            if obj not in instances:\n-                new_objs.append(obj)\n-        instances.update(new_objs)\n-        # Nullable relationships can be ignored -- they are nulled out before\n-        # deleting, and therefore do not affect the order in which objects have\n-        # to be deleted.\n-        if source is not None and not nullable:\n-            if reverse_dependency:\n-                source, model = model, source\n-            self.dependencies.setdefault(\n-                source._meta.concrete_model, set()).add(model._meta.concrete_model)\n-        return new_objs\n+            \"\"\"\n+            Add 'objs' to the collection of objects to be deleted.  If the call is\n+            the result of a cascade, 'source' should be the model that caused it,\n+            and 'nullable' should be set to True if the relation can be null.\n+    \n+            Return a list of all objects that were not already collected.\n+            \"\"\"\n+            if not objs:\n+                return []\n+            new_objs = []\n+            model = objs[0].__class__\n+            instances = self.data.setdefault(model, set())\n+            for obj in objs:\n+                if obj not in instances:\n+                    new_objs.append(obj)\n+            instances.update(new_objs)\n+            # Nullable relationships can be ignored -- they are nulled out before\n+            # deleting, and therefore do not affect the order in which objects have\n+            # to be deleted.\n+            if source is not None and not nullable:\n+                if reverse_dependency:\n+                    source, model = model, source\n+                self.dependencies.setdefault(\n+                    source._meta.concrete_model, set()).add(model._meta.concrete_model)\n+                # Collect fast delete conditions\n+                self.collect_fast_delete_conditions(objs, source)\n+            return new_objs\n \n     def add_field_update(self, field, value, objs):\n         \"\"\"\n@@ -172,27 +174,38 @@ class Collector:\n             return [objs]\n \n     def collect(self, objs, source=None, nullable=False, collect_related=True,\n-                source_attr=None, reverse_dependency=False, keep_parents=False):\n-        \"\"\"\n-        Add 'objs' to the collection of objects to be deleted as well as all\n-        parent instances.  'objs' must be a homogeneous iterable collection of\n-        model instances (e.g. a QuerySet).  If 'collect_related' is True,\n-        related objects will be handled by their respective on_delete handler.\n-\n-        If the call is the result of a cascade, 'source' should be the model\n-        that caused it and 'nullable' should be set to True, if the relation\n-        can be null.\n-\n-        If 'reverse_dependency' is True, 'source' will be deleted before the\n-        current model, rather than after. (Needed for cascading to parent\n-        models, the one case in which the cascade follows the forwards\n-        direction of an FK rather than the reverse direction.)\n-\n-        If 'keep_parents' is True, data of parent model's will be not deleted.\n-        \"\"\"\n-        if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n-            return\n+                    source_attr=None, reverse_dependency=False, keep_parents=False):\n+            \"\"\"\n+            Add 'objs' to the collection of objects to be deleted as well as all\n+            parent instances.  'objs' must be a homogeneous iterable collection of\n+            model instances (e.g. a QuerySet).  If 'collect_related' is True,\n+            related objects will be handled by their respective on_delete handler.\n+    \n+            If the call is the result of a cascade, 'source' should be the model\n+            that caused it and 'nullable' should be set to True, if the relation\n+            can be null.\n+    \n+            If 'reverse_dependency' is True, 'source' will be deleted before the\n+            current model, rather than after. (Needed for cascading to parent\n+            models, the one case in which the cascade follows the forwards\n+            direction of an FK rather than the reverse direction.)\n+    \n+            If 'keep_parents' is True, data of parent model's will be not deleted.\n+            \"\"\"\n+            if self.can_fast_delete(objs):\n+                self.fast_deletes.append(objs)\n+                return\n+    \n+            # Collect fast delete conditions\n+            if source and not nullable:\n+                self.collect_fast_delete_conditions(objs, source)\n+    \n+            new_objs = self.add(objs, source, nullable,\n+                                reverse_dependency=reverse_dependency)\n+            if not new_objs:\n+                return\n+    \n+            model = new_objs[0].__class__\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n         if not new_objs:\n@@ -281,25 +294,35 @@ class Collector:\n         self.data = {model: self.data[model] for model in sorted_models}\n \n     def delete(self):\n-        # sort instance collections\n-        for model, instances in self.data.items():\n-            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n-\n-        # if possible, bring the models in an order suitable for databases that\n-        # don't support transactions or cannot defer constraint checks until the\n-        # end of a transaction.\n-        self.sort()\n-        # number of objects deleted for each model label\n-        deleted_counter = Counter()\n-\n-        # Optimize for the case with a single obj and no dependencies\n-        if len(self.data) == 1 and len(instances) == 1:\n-            instance = list(instances)[0]\n-            if self.can_fast_delete(instance):\n-                with transaction.mark_for_rollback_on_error():\n-                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n-                setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+            # sort instance collections\n+            for model, instances in self.data.items():\n+                self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+    \n+            # if possible, bring the models in an order suitable for databases that\n+            # don't support transactions or cannot defer constraint checks until the\n+            # end of a transaction.\n+            self.sort()\n+            # number of objects deleted for each model label\n+            deleted_counter = Counter()\n+    \n+            # Optimize for the case with a single obj and no dependencies\n+            if len(self.data) == 1 and len(instances) == 1:\n+                instance = list(instances)[0]\n+                if self.can_fast_delete(instance):\n+                    with transaction.mark_for_rollback_on_error():\n+                        count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                    setattr(instance, model._meta.pk.attname, None)\n+                    return count, {model._meta.label: count}\n+    \n+            # Collect conditions for fast delete\n+            fast_delete_conditions = self.collect_fast_delete_conditions()\n+    \n+            # Execute fast deletes\n+            for model, conditions in fast_delete_conditions.items():\n+                query = sql.DeleteQuery(model)\n+                pk_list = [obj.pk for obj in self.data[model]]\n+                count = query.delete_batch(pk_list, self.using, conditions=conditions)\n+                deleted_counter[model._meta.label] += count\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 4864484,
  "num_received_chars": 92436,
  "elapsed_time": 527.1842164993286,
  "lint_repair_count": 5,
  "test_generation_attempts": 3,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}