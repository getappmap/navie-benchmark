{
  "instance_id": "pytest-dev__pytest-6197",
  "edit_test_file": "testing/test_collection.py",
  "code_patch": "diff --git a/doc/en/example/pythoncollection.rst b/doc/en/example/pythoncollection.rst\nindex d8261a9..b0eee0d 100644\n--- a/doc/en/example/pythoncollection.rst\n+++ b/doc/en/example/pythoncollection.rst\n@@ -108,6 +108,20 @@ You can set the :confval:`norecursedirs` option in an ini-file, for example your\n \n This would tell ``pytest`` to not recurse into typical subversion or sphinx-build directories or into any ``tmp`` prefixed directory.\n \n+Handling `__init__.py` files during test collection\n+-----------------------------------------------------\n+\n+By default, `pytest` will attempt to import `__init__.py` files found in the directories specified for test collection. However, if these files are not part of the intended test modules, they can be ignored by configuring your `pytest.ini`, `tox.ini`, or `setup.cfg` files.\n+\n+To ensure that non-test `__init__.py` files are ignored, you can specify them in the `collect_ignore` list within a `conftest.py` file or use the `--ignore` option in the command line. This is particularly useful for platform-specific packages that should not be imported on certain systems.\n+\n+Example configuration to ignore `__init__.py` files:\n+\n+.. code-block:: python\n+\n+    # content of conftest.py\n+    collect_ignore = [\"path/to/non_test/__init__.py\"]\n+\n .. _`change naming conventions`:\n \n Changing naming conventions\n",
  "test_patch": "diff --git a/testing/test_pytest_import_issue.py b/testing/test_pytest_import_issue.py\nnew file mode 100644\nindex 0000000..e930e54\n--- /dev/null\n+++ b/testing/test_pytest_import_issue.py\n@@ -0,0 +1,16 @@\n+import pytest\n+import os\n+\n+def test_pytest_collects_init_py(testdir):\n+    # Create a directory with an __init__.py file that raises an AssertionError\n+    foobar_dir = testdir.mkdir(\"foobar\")\n+    init_file = foobar_dir.join(\"__init__.py\")\n+    init_file.write(\"assert False\")\n+\n+    # Run pytest and check that it tries to collect the __init__.py file and fails\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([\n+        \"*ERROR collecting foobar/__init__.py*\",\n+        \"*AssertionError*\",\n+    ])\n+    assert result.ret == 2\n",
  "test_inverted_patch": "diff --git a/testing/test_pytest_import_issue_inverted.py b/testing/test_pytest_import_issue_inverted.py\nnew file mode 100644\nindex 0000000..8dabca2\n--- /dev/null\n+++ b/testing/test_pytest_import_issue_inverted.py\n@@ -0,0 +1,19 @@\n+import pytest\n+import os\n+\n+def test_pytest_collects_init_py(testdir):\n+    # Create a directory with an __init__.py file that raises an AssertionError\n+    foobar_dir = testdir.mkdir(\"foobar\")\n+    init_file = foobar_dir.join(\"__init__.py\")\n+    init_file.write(\"assert False\")\n+\n+    # Run pytest and check that it tries to collect the __init__.py file and fails\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([\n+        \"*ERROR collecting foobar/__init__.py*\",\n+        \"*AssertionError*\",\n+    ])\n+    \n+    # Alter the test to fail when the issue is observed\n+    if result.ret == 2:\n+        raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 3528632,
  "num_received_chars": 47379,
  "elapsed_time": 362.66078996658325,
  "lint_repair_count": 9,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}