{
  "instance_id": "sphinx-doc__sphinx-9320",
  "edit_test_file": "tests/test_setup_command.py",
  "code_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex a40a210..1cdcadb 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,9 +223,10 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', allow_empty)\n         if not d['path']:\n-            sys.exit(1)\n+            print(__('Exiting sphinx-quickstart.'))\n+            sys.exit(0)\n \n     if 'sep' not in d:\n         print()\n",
  "test_patch": "diff --git a/tests/test_quickstart_exit.py b/tests/test_quickstart_exit.py\nnew file mode 100644\nindex 0000000..7f29819\n--- /dev/null\n+++ b/tests/test_quickstart_exit.py\n@@ -0,0 +1,42 @@\n+import os\n+import subprocess\n+import sys\n+import unittest\n+from sphinx.util.osutil import ensuredir\n+\n+class TestSphinxQuickstartExit(unittest.TestCase):\n+    def setUp(self):\n+        # Create a temporary directory for the test\n+        self.test_dir = os.path.join(os.getcwd(), 'test_quickstart_exit')\n+        ensuredir(self.test_dir)\n+        # Create a dummy conf.py to simulate the existing file scenario\n+        with open(os.path.join(self.test_dir, 'conf.py'), 'w') as f:\n+            f.write(\"# Dummy conf.py\")\n+\n+    def tearDown(self):\n+        # Clean up the test directory after the test\n+        if os.path.exists(self.test_dir):\n+            for root, dirs, files in os.walk(self.test_dir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.test_dir)\n+\n+    def test_quickstart_exit_on_enter(self):\n+        # Run sphinx-quickstart in the directory with existing conf.py\n+        process = subprocess.Popen(\n+            [sys.executable, '-m', 'sphinx.cmd.quickstart'],\n+            cwd=self.test_dir,\n+            stdin=subprocess.PIPE,\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE\n+        )\n+        # Simulate pressing 'Enter' at the prompt\n+        out, err = process.communicate(input=b'\\n')\n+        \n+        # Check if the error message is produced\n+        self.assertIn(b\"Please enter a valid path name\", out + err)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/tests/test_quickstart_exit_inverted.py b/tests/test_quickstart_exit_inverted.py\nnew file mode 100644\nindex 0000000..084938a\n--- /dev/null\n+++ b/tests/test_quickstart_exit_inverted.py\n@@ -0,0 +1,43 @@\n+import os\n+import subprocess\n+import sys\n+import unittest\n+from sphinx.util.osutil import ensuredir\n+\n+class TestSphinxQuickstartExit(unittest.TestCase):\n+    def setUp(self):\n+        # Create a temporary directory for the test\n+        self.test_dir = os.path.join(os.getcwd(), 'test_quickstart_exit')\n+        ensuredir(self.test_dir)\n+        # Create a dummy conf.py to simulate the existing file scenario\n+        with open(os.path.join(self.test_dir, 'conf.py'), 'w') as f:\n+            f.write(\"# Dummy conf.py\")\n+\n+    def tearDown(self):\n+        # Clean up the test directory after the test\n+        if os.path.exists(self.test_dir):\n+            for root, dirs, files in os.walk(self.test_dir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.test_dir)\n+\n+    def test_quickstart_exit_on_enter(self):\n+        # Run sphinx-quickstart in the directory with existing conf.py\n+        process = subprocess.Popen(\n+            [sys.executable, '-m', 'sphinx.cmd.quickstart'],\n+            cwd=self.test_dir,\n+            stdin=subprocess.PIPE,\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE\n+        )\n+        # Simulate pressing 'Enter' at the prompt\n+        out, err = process.communicate(input=b'\\n')\n+        \n+        # Check if the error message is produced\n+        if b\"Please enter a valid path name\" in out + err:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 598796,
  "num_received_chars": 4565,
  "elapsed_time": 71.30091094970703,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}