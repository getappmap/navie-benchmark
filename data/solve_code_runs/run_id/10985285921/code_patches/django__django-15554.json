{
  "instance_id": "django__django-15554",
  "edit_test_file": "tests/custom_managers/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258..9a31806 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -809,9 +809,11 @@ class Query(BaseExpression):\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n-            alias = (\n-                filtered_relation.alias if filtered_relation is not None else table_name\n-            )\n+            if filtered_relation is not None:\n+                # Use a unique alias for each FilteredRelation\n+                alias = f\"{filtered_relation.alias}_{len(self.alias_map) + 1}\"\n+            else:\n+                alias = table_name\n             self.table_map[table_name] = [alias]\n         self.alias_refcount[alias] = 1\n         return alias, True\n@@ -1570,7 +1572,8 @@ class Query(BaseExpression):\n         return target_clause\n \n     def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n+        # Ensure each FilteredRelation gets a unique alias based on its condition\n+        filtered_relation.alias = f\"{alias}_{hash(filtered_relation.condition)}\"\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n         relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n             filtered_relation.relation_name\n@@ -1800,7 +1803,8 @@ class Query(BaseExpression):\n         for join in path:\n             if join.filtered_relation:\n                 filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n+                # Ensure unique alias for each FilteredRelation\n+                table_alias = f\"{filtered_relation.alias}_{hash(filtered_relation.condition)}\"\n             else:\n                 filtered_relation = None\n                 table_alias = None\n",
  "test_patch": "diff --git a/tests/custom_managers/test_filtered_relation_multiple_filters.py b/tests/custom_managers/test_filtered_relation_multiple_filters.py\nnew file mode 100644\nindex 0000000..077748a\n--- /dev/null\n+++ b/tests/custom_managers/test_filtered_relation_multiple_filters.py\n@@ -0,0 +1,52 @@\n+from django.db import models\n+from django.db.models import Case, F, FilteredRelation, Q, When\n+from django.test import TestCase\n+\n+# Assuming the models are defined as follows:\n+class NestedRelation(models.Model):\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+    is_all = models.BooleanField(default=False)\n+    price = models.DecimalField(max_digits=10, decimal_places=2)\n+\n+class MyRelation(models.Model):\n+    nested = models.ForeignKey(NestedRelation, on_delete=models.CASCADE)\n+\n+class MyModel(models.Model):\n+    myrelation = models.ForeignKey(MyRelation, on_delete=models.CASCADE)\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+\n+class FilteredRelationMultipleFiltersTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        nested_all = NestedRelation.objects.create(is_all=True, price=100.00)\n+        nested_zone = NestedRelation.objects.create(zone=\"zone1\", is_all=False, price=200.00)\n+        relation_all = MyRelation.objects.create(nested=nested_all)\n+        relation_zone = MyRelation.objects.create(nested=nested_zone)\n+        MyModel.objects.create(myrelation=relation_all, zone=\"zone1\")\n+        MyModel.objects.create(myrelation=relation_zone, zone=\"zone1\")\n+\n+    def test_filtered_relation_different_filters(self):\n+        qs = MyModel.objects.alias(\n+            relation_zone=FilteredRelation(\n+                \"myrelation__nested\",\n+                condition=Q(myrelation__nested__zone=F(\"zone\"))\n+            ),\n+            relation_all=FilteredRelation(\n+                \"myrelation__nested\",\n+                condition=Q(myrelation__nested__is_all=True)\n+            ),\n+            price_zone=F(\"relation_zone__price\")\n+        ).annotate(\n+            price_final=Case(\n+                When(\n+                    price_zone__isnull=True,\n+                    then=F(\"relation_all__price\"),\n+                ),\n+                default=F(\"price_zone\")\n+            )\n+        )\n+\n+        # Check the raw SQL to ensure only one JOIN is generated\n+        raw_sql = str(qs.query)\n+        self.assertIn(\"JOIN\", raw_sql)\n+        self.assertNotIn(\"relation_all\", raw_sql, \"Expected 'relation_all' join to be missing due to the issue.\")\n",
  "test_inverted_patch": "diff --git a/tests/custom_managers/test_filtered_relation_multiple_filters_inverted.py b/tests/custom_managers/test_filtered_relation_multiple_filters_inverted.py\nnew file mode 100644\nindex 0000000..2118b39\n--- /dev/null\n+++ b/tests/custom_managers/test_filtered_relation_multiple_filters_inverted.py\n@@ -0,0 +1,53 @@\n+from django.db import models\n+from django.db.models import Case, F, FilteredRelation, Q, When\n+from django.test import TestCase\n+\n+# Assuming the models are defined as follows:\n+class NestedRelation(models.Model):\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+    is_all = models.BooleanField(default=False)\n+    price = models.DecimalField(max_digits=10, decimal_places=2)\n+\n+class MyRelation(models.Model):\n+    nested = models.ForeignKey(NestedRelation, on_delete=models.CASCADE)\n+\n+class MyModel(models.Model):\n+    myrelation = models.ForeignKey(MyRelation, on_delete=models.CASCADE)\n+    zone = models.CharField(max_length=100, null=True, blank=True)\n+\n+class FilteredRelationMultipleFiltersTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        nested_all = NestedRelation.objects.create(is_all=True, price=100.00)\n+        nested_zone = NestedRelation.objects.create(zone=\"zone1\", is_all=False, price=200.00)\n+        relation_all = MyRelation.objects.create(nested=nested_all)\n+        relation_zone = MyRelation.objects.create(nested=nested_zone)\n+        MyModel.objects.create(myrelation=relation_all, zone=\"zone1\")\n+        MyModel.objects.create(myrelation=relation_zone, zone=\"zone1\")\n+\n+    def test_filtered_relation_different_filters(self):\n+        qs = MyModel.objects.alias(\n+            relation_zone=FilteredRelation(\n+                \"myrelation__nested\",\n+                condition=Q(myrelation__nested__zone=F(\"zone\"))\n+            ),\n+            relation_all=FilteredRelation(\n+                \"myrelation__nested\",\n+                condition=Q(myrelation__nested__is_all=True)\n+            ),\n+            price_zone=F(\"relation_zone__price\")\n+        ).annotate(\n+            price_final=Case(\n+                When(\n+                    price_zone__isnull=True,\n+                    then=F(\"relation_all__price\"),\n+                ),\n+                default=F(\"price_zone\")\n+            )\n+        )\n+\n+        # Check the raw SQL to ensure only one JOIN is generated\n+        raw_sql = str(qs.query)\n+        self.assertIn(\"JOIN\", raw_sql)\n+        if \"relation_all\" not in raw_sql:\n+            raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 4105487,
  "num_received_chars": 147082,
  "elapsed_time": 616.6241524219513,
  "lint_repair_count": 4,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}