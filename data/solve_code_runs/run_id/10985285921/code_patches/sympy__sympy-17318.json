{
  "instance_id": "sympy__sympy-17318",
  "edit_test_file": null,
  "code_patch": "diff --git a/sympy/simplify/sqrtdenest.py b/sympy/simplify/sqrtdenest.py\nindex f0b7653..94924d6 100644\n--- a/sympy/simplify/sqrtdenest.py\n+++ b/sympy/simplify/sqrtdenest.py\n@@ -129,11 +129,15 @@ def sqrtdenest(expr, max_iter=3):\n \n     \"\"\"\n     expr = expand_mul(sympify(expr))\n-    for i in range(max_iter):\n-        z = _sqrtdenest0(expr)\n-        if expr == z:\n-            return expr\n-        expr = z\n+    try:\n+        for i in range(max_iter):\n+            z = _sqrtdenest0(expr)\n+            if expr == z:\n+                return expr\n+            expr = z\n+    except (IndexError, ValueError):\n+        # Return the original expression if denesting fails\n+        return expr\n     return expr\n \n \n@@ -150,69 +154,73 @@ def _sqrt_match(p):\n     [1 + sqrt(2) + sqrt(6), 2, 1 + sqrt(5)]\n     \"\"\"\n     from sympy.simplify.radsimp import split_surds\n-\n-    p = _mexpand(p)\n-    if p.is_Number:\n-        res = (p, S.Zero, S.Zero)\n-    elif p.is_Add:\n-        pargs = sorted(p.args, key=default_sort_key)\n-        if all((x**2).is_Rational for x in pargs):\n-            r, b, a = split_surds(p)\n-            res = a, b, r\n-            return list(res)\n-        # to make the process canonical, the argument is included in the tuple\n-        # so when the max is selected, it will be the largest arg having a\n-        # given depth\n-        v = [(sqrt_depth(x), x, i) for i, x in enumerate(pargs)]\n-        nmax = max(v, key=default_sort_key)\n-        if nmax[0] == 0:\n-            res = []\n-        else:\n-            # select r\n-            depth, _, i = nmax\n-            r = pargs.pop(i)\n-            v.pop(i)\n-            b = S.One\n-            if r.is_Mul:\n-                bv = []\n-                rv = []\n-                for x in r.args:\n-                    if sqrt_depth(x) < depth:\n-                        bv.append(x)\n-                    else:\n-                        rv.append(x)\n-                b = Mul._from_args(bv)\n-                r = Mul._from_args(rv)\n-            # collect terms comtaining r\n-            a1 = []\n-            b1 = [b]\n-            for x in v:\n-                if x[0] < depth:\n-                    a1.append(x[1])\n-                else:\n-                    x1 = x[1]\n-                    if x1 == r:\n-                        b1.append(1)\n+    try:\n+        p = _mexpand(p)\n+        if p.is_Number:\n+            res = (p, S.Zero, S.Zero)\n+\n+        elif p.is_Add:\n+            pargs = sorted(p.args, key=default_sort_key)\n+            if all((x**2).is_Rational for x in pargs):\n+                r, b, a = split_surds(p)\n+                res = a, b, r\n+                return list(res)\n+            # to make the process canonical, the argument is included in the tuple\n+            # so when the max is selected, it will be the largest arg having a\n+            # given depth\n+            v = [(sqrt_depth(x), x, i) for i, x in enumerate(pargs)]\n+            nmax = max(v, key=default_sort_key)\n+            if nmax[0] == 0:\n+                res = []\n+            else:\n+                # select r\n+                depth, _, i = nmax\n+                r = pargs.pop(i)\n+                v.pop(i)\n+                b = S.One\n+                if r.is_Mul:\n+                    bv = []\n+                    rv = []\n+                    for x in r.args:\n+                        if sqrt_depth(x) < depth:\n+                            bv.append(x)\n+                        else:\n+                            rv.append(x)\n+                    b = Mul._from_args(bv)\n+                    r = Mul._from_args(rv)\n+                # collect terms comtaining r\n+                a1 = []\n+                b1 = [b]\n+                for x in v:\n+                    if x[0] < depth:\n+                        a1.append(x[1])\n                     else:\n-                        if x1.is_Mul:\n-                            x1args = list(x1.args)\n-                            if r in x1args:\n-                                x1args.remove(r)\n-                                b1.append(Mul(*x1args))\n+                        x1 = x[1]\n+                        if x1 == r:\n+                            b1.append(1)\n+                        else:\n+                            if x1.is_Mul:\n+                                x1args = list(x1.args)\n+                                if r in x1args:\n+                                    x1args.remove(r)\n+                                    b1.append(Mul(*x1args))\n+                                else:\n+                                    a1.append(x[1])\n                             else:\n                                 a1.append(x[1])\n-                        else:\n-                            a1.append(x[1])\n-            a = Add(*a1)\n-            b = Add(*b1)\n-            res = (a, b, r**2)\n-    else:\n-        b, r = p.as_coeff_Mul()\n-        if is_sqrt(r):\n-            res = (S.Zero, b, r**2)\n+                a = Add(*a1)\n+                b = Add(*b1)\n+                res = (a, b, r**2)\n         else:\n-            res = []\n-    return list(res)\n+            b, r = p.as_coeff_Mul()\n+            if is_sqrt(r):\n+                res = (S.Zero, b, r**2)\n+            else:\n+                res = []\n+        return list(res)\n+    except (IndexError, ValueError):\n+        # Return an empty list if matching fails\n+        return []\n \n \n class SqrtdenestStopIteration(StopIteration):\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 2342332,
  "num_received_chars": 20466,
  "elapsed_time": 222.64404368400574,
  "lint_repair_count": 0,
  "test_generation_attempts": 3,
  "code_generation_attempts": 2,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}