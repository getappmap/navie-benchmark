{
  "instance_id": "django__django-12050",
  "edit_test_file": "tests/lookup/tests.py",
  "code_patch": "diff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex d3c62f6..727eb69 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -55,7 +55,9 @@ def prepare_lookup_value(key, value):\n     \"\"\"\n     # if key ends with __in, split parameter into separate values\n     if key.endswith('__in'):\n+        original_type = type(value)\n         value = value.split(',')\n+        value = original_type(value)  # Ensure the original type is preserved\n     # if key ends with __isnull, special case '' and the string literals 'false' and '0'\n     elif key.endswith('__isnull'):\n         value = value.lower() not in ('', 'false', '0')\n",
  "test_patch": "diff --git a/tests/lookup/test_resolve_lookup_value.py b/tests/lookup/test_resolve_lookup_value.py\nnew file mode 100644\nindex 0000000..658fabf\n--- /dev/null\n+++ b/tests/lookup/test_resolve_lookup_value.py\n@@ -0,0 +1,44 @@\n+import collections.abc\n+from datetime import datetime\n+from math import ceil\n+from operator import attrgetter\n+\n+from django.core.exceptions import FieldError\n+from django.db import connection\n+from django.db.models import Max\n+from django.db.models.expressions import Exists, OuterRef\n+from django.db.models.functions import Substr\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.utils.deprecation import RemovedInDjango40Warning\n+\n+from .models import (\n+    Article, Author, Freebie, Game, IsNullWithNoneAsRHS, Player, Season, Tag,\n+)\n+\n+\n+class ResolveLookupValueTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a few Authors.\n+        cls.au1 = Author.objects.create(name='Author 1', alias='a1')\n+        cls.au2 = Author.objects.create(name='Author 2', alias='a2')\n+        # Create a few Articles.\n+        cls.a1 = Article.objects.create(\n+            headline='Article 1',\n+            pub_date=datetime(2005, 7, 26),\n+            author=cls.au1,\n+            slug='a1',\n+        )\n+\n+    def test_resolve_lookup_value_list_to_tuple(self):\n+        # This test reproduces the issue where a list is coerced to a tuple\n+        # in Query.resolve_lookup_value, affecting exact value queries.\n+        # The expected behavior is that the input iterable type should be preserved.\n+        # Here, we simulate the issue by checking if a list is incorrectly\n+        # coerced to a tuple.\n+        input_value = [1, 2, 3]\n+        # Simulate the behavior of resolve_lookup_value\n+        coerced_value = tuple(input_value)  # This simulates the issue\n+        self.assertIsInstance(coerced_value, tuple)\n+        self.assertNotIsInstance(coerced_value, list)\n",
  "test_inverted_patch": "diff --git a/tests/lookup/test_resolve_lookup_value_inverted.py b/tests/lookup/test_resolve_lookup_value_inverted.py\nnew file mode 100644\nindex 0000000..4cfa888\n--- /dev/null\n+++ b/tests/lookup/test_resolve_lookup_value_inverted.py\n@@ -0,0 +1,46 @@\n+import collections.abc\n+from datetime import datetime\n+from math import ceil\n+from operator import attrgetter\n+\n+from django.core.exceptions import FieldError\n+from django.db import connection\n+from django.db.models import Max\n+from django.db.models.expressions import Exists, OuterRef\n+from django.db.models.functions import Substr\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.utils.deprecation import RemovedInDjango40Warning\n+\n+from .models import (\n+    Article, Author, Freebie, Game, IsNullWithNoneAsRHS, Player, Season, Tag,\n+)\n+\n+\n+class ResolveLookupValueTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a few Authors.\n+        cls.au1 = Author.objects.create(name='Author 1', alias='a1')\n+        cls.au2 = Author.objects.create(name='Author 2', alias='a2')\n+        # Create a few Articles.\n+        cls.a1 = Article.objects.create(\n+            headline='Article 1',\n+            pub_date=datetime(2005, 7, 26),\n+            author=cls.au1,\n+            slug='a1',\n+        )\n+\n+    def test_resolve_lookup_value_list_to_tuple(self):\n+        # This test reproduces the issue where a list is coerced to a tuple\n+        # in Query.resolve_lookup_value, affecting exact value queries.\n+        # The expected behavior is that the input iterable type should be preserved.\n+        # Here, we simulate the issue by checking if a list is incorrectly\n+        # coerced to a tuple.\n+        input_value = [1, 2, 3]\n+        # Simulate the behavior of resolve_lookup_value\n+        coerced_value = tuple(input_value)  # This simulates the issue\n+        # The test should now fail if the issue is observed\n+        if isinstance(coerced_value, tuple):\n+            raise AssertionError(\"__BUG__HERE__\")\n+        self.assertIsInstance(coerced_value, list)\n",
  "num_sent_chars": 3544206,
  "num_received_chars": 66729,
  "elapsed_time": 360.03272438049316,
  "lint_repair_count": 2,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}