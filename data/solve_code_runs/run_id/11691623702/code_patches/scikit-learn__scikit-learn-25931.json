{
  "instance_id": "scikit-learn__scikit-learn-25931",
  "edit_test_file": "sklearn/compose/tests/test_column_transformer.py",
  "code_patch": "diff --git a/sklearn/ensemble/_iforest.py b/sklearn/ensemble/_iforest.py\nindex 4d6c1c3..e10fa69 100644\n--- a/sklearn/ensemble/_iforest.py\n+++ b/sklearn/ensemble/_iforest.py\n@@ -344,8 +344,8 @@ class IsolationForest(OutlierMixin, BaseBagging):\n             self.offset_ = -0.5\n             return self\n \n-        # else, define offset_ wrt contamination parameter\n-        self.offset_ = np.percentile(self.score_samples(X), 100.0 * self.contamination)\n+        # else, define offset_ wrt contamination parameter - skip feature name validation for internal scoring\n+        self.offset_ = np.percentile(self._score_samples(X, check_feature_names=False), 100.0 * self.contamination)\n \n         return self\n \n@@ -430,10 +430,15 @@ class IsolationForest(OutlierMixin, BaseBagging):\n         \"\"\"\n         # code structure from ForestClassifier/predict_proba\n \n+        return self._score_samples(X, check_feature_names=True)\n+\n+    def _score_samples(self, X, check_feature_names=True):\n+        \"\"\"Private score_samples method that optionally skips feature name validation\"\"\"\n         check_is_fitted(self)\n \n         # Check data\n-        X = self._validate_data(X, accept_sparse=\"csr\", dtype=np.float32, reset=False)\n+        reset = False if check_feature_names else \"allow\"\n+        X = self._validate_data(X, accept_sparse=\"csr\", dtype=np.float32, reset=reset)\n \n         # Take the opposite of the scores as bigger is better (here less\n         # abnormal)\n",
  "test_patch": "diff --git a/sklearn/compose/tests/test_isolation_forest_feature_names.py b/sklearn/compose/tests/test_isolation_forest_feature_names.py\nnew file mode 100644\nindex 0000000..5b665b6\n--- /dev/null\n+++ b/sklearn/compose/tests/test_isolation_forest_feature_names.py\n@@ -0,0 +1,8 @@\n+import pytest\n+import pandas as pd\n+from sklearn.ensemble import IsolationForest\n+\n+def test_isolation_forest_feature_names_warning():\n+    X = pd.DataFrame({\"a\": [-1.1, 0.3, 0.5, 100]})\n+    with pytest.warns(UserWarning, match=\"X does not have valid feature names, but IsolationForest was fitted with feature names\"):\n+        IsolationForest(random_state=0, contamination=0.05).fit(X)\n",
  "test_inverted_patch": "diff --git a/sklearn/compose/tests/test_isolation_forest_feature_names_inverted.py b/sklearn/compose/tests/test_isolation_forest_feature_names_inverted.py\nnew file mode 100644\nindex 0000000..2175025\n--- /dev/null\n+++ b/sklearn/compose/tests/test_isolation_forest_feature_names_inverted.py\n@@ -0,0 +1,14 @@\n+import pytest\n+import pandas as pd\n+from sklearn.ensemble import IsolationForest\n+\n+def test_isolation_forest_feature_names_warning():\n+    X = pd.DataFrame({\"a\": [-1.1, 0.3, 0.5, 100]})\n+    try:\n+        with pytest.warns(None) as record:\n+            IsolationForest(random_state=0, contamination=0.05).fit(X)\n+        # Check if the specific warning is present\n+        if any(\"X does not have valid feature names, but IsolationForest was fitted with feature names\" in str(warning.message) for warning in record):\n+            raise AssertionError(\"__BUG__HERE__\")\n+    except AssertionError as e:\n+        raise e\n",
  "num_sent_chars": 1336379,
  "num_received_chars": 17779,
  "elapsed_time": 253.7726855278015,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 2,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}