{
  "instance_id": "matplotlib__matplotlib-26466",
  "edit_test_file": "lib/matplotlib/tests/test_patches.py",
  "code_patch": "diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex d4922fc..e1c4c6c 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -1186,7 +1186,7 @@ class Text(Artist):\n         ----------\n         xy : (float, float)\n         \"\"\"\n-        self.set_x(xy[0])\n+        xy = tuple(xy)  # Create a copy by converting to tuple\n         self.set_y(xy[1])\n \n     def set_x(self, x):\n@@ -1456,14 +1456,14 @@ class _AnnotationBase:\n                  xycoords='data',\n                  annotation_clip=None):\n \n-        self.xy = xy\n+        self.xy = tuple(xy)  # Create a copy by converting to tuple\n         self.xycoords = xycoords\n         self.set_annotation_clip(annotation_clip)\n \n         self._draggable = None\n \n     def _get_xy(self, renderer, xy, coords):\n-        x, y = xy\n+        x, y = tuple(xy)  # Create a copy by converting to tuple\n         xcoord, ycoord = coords if isinstance(coords, tuple) else (coords, coords)\n         if xcoord == 'data':\n             x = float(self.convert_xunits(x))\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_annotation_array_copy.py b/lib/matplotlib/tests/test_annotation_array_copy.py\nnew file mode 100644\nindex 0000000..7428c6a\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_array_copy.py\n@@ -0,0 +1,44 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+\n+def test_annotation_array_copy():\n+    \"\"\"Test that modifying array passed to annotate affects the arrow position.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.set_xlim(-5, 5)\n+    ax.set_ylim(-3, 3)\n+\n+    # Create initial coordinates\n+    xy_0 = np.array((-4, 1))\n+    xy_f = np.array((-1, 1))\n+\n+    # Create annotation with arrow\n+    ann = ax.annotate(text='', xy=xy_0, xytext=xy_f,\n+                     arrowprops=dict(arrowstyle='<->'))\n+\n+    # Store initial arrow coordinates\n+    initial_xy = ann.xy.copy()\n+\n+    # Modify the array - this should affect the arrow position\n+    xy_0[1] = 3\n+\n+    # Get new arrow coordinates\n+    new_xy = ann.xy\n+\n+    # Assert that modifying the array changed the arrow coordinates\n+    assert np.array_equal(initial_xy, np.array((-4, 1)))\n+    assert np.array_equal(new_xy, np.array((-4, 3)))\n+\n+    # Create a second annotation using array.copy() to demonstrate the fix\n+    xy_0_copy = np.array((1, 1))\n+    xy_f_copy = np.array((4, 1))\n+    \n+    ann2 = ax.annotate(text='', xy=xy_0_copy.copy(), xytext=xy_f_copy,\n+                      arrowprops=dict(arrowstyle='<->'))\n+    \n+    initial_xy2 = ann2.xy.copy()\n+    xy_0_copy[1] = 3\n+    new_xy2 = ann2.xy\n+\n+    # Assert that using copy() prevents the position from changing\n+    assert np.array_equal(initial_xy2, new_xy2)\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_annotation_array_copy_inverted.py b/lib/matplotlib/tests/test_annotation_array_copy_inverted.py\nnew file mode 100644\nindex 0000000..8f149f1\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_array_copy_inverted.py\n@@ -0,0 +1,47 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+\n+def test_annotation_array_copy():\n+    \"\"\"Test that modifying array passed to annotate should not affect the arrow position.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.set_xlim(-5, 5)\n+    ax.set_ylim(-3, 3)\n+\n+    # Create initial coordinates\n+    xy_0 = np.array((-4, 1))\n+    xy_f = np.array((-1, 1))\n+\n+    # Create annotation with arrow\n+    ann = ax.annotate(text='', xy=xy_0, xytext=xy_f,\n+                     arrowprops=dict(arrowstyle='<->'))\n+\n+    # Store initial arrow coordinates\n+    initial_xy = ann.xy.copy()\n+\n+    # Modify the array - this should NOT affect the arrow position\n+    xy_0[1] = 3\n+\n+    # Get new arrow coordinates\n+    new_xy = ann.xy\n+\n+    # The test should fail if the arrow position changes when the original array is modified\n+    if not np.array_equal(initial_xy, new_xy):\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Verify the initial position was correct\n+    np.testing.assert_array_equal(initial_xy, np.array((-4, 1)))\n+\n+    # Create a second annotation to demonstrate the expected behavior\n+    xy_0_copy = np.array((1, 1))\n+    xy_f_copy = np.array((4, 1))\n+    \n+    ann2 = ax.annotate(text='', xy=xy_0_copy.copy(), xytext=xy_f_copy,\n+                      arrowprops=dict(arrowstyle='<->'))\n+    \n+    initial_xy2 = ann2.xy.copy()\n+    xy_0_copy[1] = 3\n+    new_xy2 = ann2.xy\n+\n+    # This should pass as we used copy()\n+    np.testing.assert_array_equal(initial_xy2, new_xy2)\n\\ No newline at end of file\n",
  "num_sent_chars": 6075280,
  "num_received_chars": 70384,
  "elapsed_time": 1796.9511659145355,
  "lint_repair_count": 0,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}