{
  "instance_id": "django__django-13109",
  "edit_test_file": "tests/many_to_one/tests.py",
  "code_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611af..0781bde 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1276,7 +1276,7 @@ class ModelChoiceField(ChoiceField):\n             key = self.to_field_name or 'pk'\n             if isinstance(value, self.queryset.model):\n                 value = getattr(value, key)\n-            value = self.queryset.get(**{key: value})\n+            value = self.queryset.model._base_manager.using(self.queryset.db).get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n             raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n         return value\n@@ -1354,14 +1354,14 @@ class ModelMultipleChoiceField(ModelChoiceField):\n             )\n         for pk in value:\n             try:\n-                self.queryset.filter(**{key: pk})\n+                self.queryset.model._base_manager.using(self.queryset.db).filter(**{key: pk})\n             except (ValueError, TypeError):\n                 raise ValidationError(\n                     self.error_messages['invalid_pk_value'],\n                     code='invalid_pk_value',\n                     params={'pk': pk},\n                 )\n-        qs = self.queryset.filter(**{'%s__in' % key: value})\n+        qs = self.queryset.model._base_manager.using(self.queryset.db).filter(**{'%s__in' % key: value})\n         pks = {str(getattr(o, key)) for o in qs}\n         for val in value:\n             if str(val) not in pks:\n",
  "test_patch": "diff --git a/tests/many_to_one/test_foreign_key_base_manager_validation.py b/tests/many_to_one/test_foreign_key_base_manager_validation.py\nnew file mode 100644\nindex 0000000..d3446ea\n--- /dev/null\n+++ b/tests/many_to_one/test_foreign_key_base_manager_validation.py\n@@ -0,0 +1,53 @@\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class ArticleManagerTest(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n+class TestArticle(models.Model):\n+    title = models.CharField(max_length=100)\n+    archived = models.BooleanField(default=False)\n+    objects = ArticleManagerTest()\n+\n+    class Meta:\n+        app_label = 'many_to_one'\n+\n+\n+class TestFavoriteArticle(models.Model):\n+    article = models.ForeignKey(TestArticle, on_delete=models.CASCADE)\n+\n+    class Meta:\n+        app_label = 'many_to_one'\n+\n+\n+class ForeignKeyBaseManagerValidationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create an archived article\n+        cls.archived_article = TestArticle.objects.create(\n+            title='Archived Article',\n+            archived=True\n+        )\n+\n+    def test_foreign_key_validation_with_archived_article(self):\n+        \"\"\"\n+        Test that ForeignKey validation fails when trying to use an archived article,\n+        even though it exists in the database and is accessible via _base_manager.\n+        \"\"\"\n+        # Verify the article exists when using base manager\n+        self.assertTrue(\n+            TestArticle._base_manager.filter(pk=self.archived_article.pk).exists()\n+        )\n+\n+        # Create a favorite article pointing to the archived article\n+        favorite = TestFavoriteArticle(article_id=self.archived_article.pk)\n+\n+        # The validation should raise a ValidationError because it uses\n+        # _default_manager (objects) which filters out archived articles\n+        with self.assertRaises(ValidationError):\n+            favorite.full_clean()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/many_to_one/test_foreign_key_base_manager_validation_inverted.py b/tests/many_to_one/test_foreign_key_base_manager_validation_inverted.py\nnew file mode 100644\nindex 0000000..4f9aef2\n--- /dev/null\n+++ b/tests/many_to_one/test_foreign_key_base_manager_validation_inverted.py\n@@ -0,0 +1,59 @@\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class ArticleManagerTest(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n+class TestArticle(models.Model):\n+    title = models.CharField(max_length=100)\n+    archived = models.BooleanField(default=False)\n+    objects = ArticleManagerTest()\n+\n+    class Meta:\n+        app_label = 'many_to_one'\n+\n+\n+class TestFavoriteArticle(models.Model):\n+    article = models.ForeignKey(TestArticle, on_delete=models.CASCADE)\n+\n+    class Meta:\n+        app_label = 'many_to_one'\n+\n+\n+class ForeignKeyBaseManagerValidationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create an archived article\n+        cls.archived_article = TestArticle.objects.create(\n+            title='Archived Article',\n+            archived=True\n+        )\n+\n+    def test_foreign_key_validation_with_archived_article(self):\n+        \"\"\"\n+        Test that ForeignKey validation should succeed when using an archived article\n+        because it exists in the database and is accessible via _base_manager.\n+        The test will fail if the validation incorrectly uses _default_manager instead\n+        of _base_manager.\n+        \"\"\"\n+        # Verify the article exists when using base manager\n+        self.assertTrue(\n+            TestArticle._base_manager.filter(pk=self.archived_article.pk).exists()\n+        )\n+\n+        # Create a favorite article pointing to the archived article\n+        favorite = TestFavoriteArticle(article_id=self.archived_article.pk)\n+\n+        try:\n+            # This should succeed because the article exists in the database\n+            # and is accessible via _base_manager\n+            favorite.full_clean()\n+        except ValidationError:\n+            # If we get here, it means the validation is incorrectly using\n+            # _default_manager instead of _base_manager\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 5464122,
  "num_received_chars": 82724,
  "elapsed_time": 917.0966637134552,
  "lint_repair_count": 9,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}