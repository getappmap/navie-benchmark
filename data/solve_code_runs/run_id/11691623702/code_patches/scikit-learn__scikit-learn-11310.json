{
  "instance_id": "scikit-learn__scikit-learn-11310",
  "edit_test_file": "sklearn/model_selection/tests/test_validation.py",
  "code_patch": "diff --git a/sklearn/model_selection/_search.py b/sklearn/model_selection/_search.py\nindex 99d6096..4f7ab01 100644\n--- a/sklearn/model_selection/_search.py\n+++ b/sklearn/model_selection/_search.py\n@@ -12,6 +12,7 @@ from __future__ import division\n #         Raghav RV <rvraghav93@gmail.com>\n # License: BSD 3 clause\n \n+import time\n from abc import ABCMeta, abstractmethod\n from collections import Mapping, namedtuple, defaultdict, Sequence, Iterable\n from functools import partial, reduce\n@@ -766,10 +767,15 @@ class BaseSearchCV(six.with_metaclass(ABCMeta, BaseEstimator,\n         if self.refit:\n             self.best_estimator_ = clone(base_estimator).set_params(\n                 **self.best_params_)\n+            \n+            # Time the refit on the entire dataset\n+            refit_start_time = time.time()\n             if y is not None:\n                 self.best_estimator_.fit(X, y, **fit_params)\n             else:\n                 self.best_estimator_.fit(X, **fit_params)\n+            refit_end_time = time.time()\n+            self.refit_time_ = refit_end_time - refit_start_time\n \n         # Store the only scorer not as a dict for single metric evaluation\n         self.scorer_ = scorers if self.multimetric_ else scorers['score']\n@@ -1073,6 +1079,10 @@ class GridSearchCV(BaseSearchCV):\n         For multi-metric evaluation, this attribute holds the validated\n         ``scoring`` dict which maps the scorer key to the scorer callable.\n \n+    refit_time_ : float\n+        Time for refitting the best model on the whole dataset.\n+        Only present when ``refit=True``.\n+\n     n_splits_ : int\n         The number of cross-validation splits (folds/iterations).\n \n",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_refit_time.py b/sklearn/model_selection/tests/test_refit_time.py\nnew file mode 100644\nindex 0000000..c948d18\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_refit_time.py\n@@ -0,0 +1,33 @@\n+import unittest\n+import time\n+from sklearn.datasets import load_iris\n+from sklearn.model_selection import GridSearchCV\n+from sklearn.ensemble import RandomForestClassifier\n+\n+class TestRefitTime(unittest.TestCase):\n+    def test_refit_time(self):\n+        X, y = load_iris(return_X_y=True)\n+\n+        # Initialize GridSearchCV with RandomForestClassifier\n+        rs = GridSearchCV(\n+            estimator=RandomForestClassifier(),\n+            param_grid={'n_estimators': [2, 3, 4, 5]},\n+            n_jobs=1  # Ensure single core for simplicity\n+        )\n+\n+        # Fit the model and time the refit process\n+        start_time = time.time()\n+        rs.fit(X, y)\n+        end_time = time.time()\n+\n+        # Calculate the refit time\n+        refit_time = end_time - start_time\n+\n+        # Check if 'refit_time_' attribute exists\n+        self.assertFalse(hasattr(rs, 'refit_time_'), \"GridSearchCV should not have 'refit_time_' attribute.\")\n+\n+        # Print the calculated refit time for manual verification\n+        print(f\"Calculated refit time: {refit_time}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/sklearn/model_selection/tests/test_refit_time_inverted.py b/sklearn/model_selection/tests/test_refit_time_inverted.py\nnew file mode 100644\nindex 0000000..c7a6220\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_refit_time_inverted.py\n@@ -0,0 +1,34 @@\n+import unittest\n+import time\n+from sklearn.datasets import load_iris\n+from sklearn.model_selection import GridSearchCV\n+from sklearn.ensemble import RandomForestClassifier\n+\n+class TestRefitTime(unittest.TestCase):\n+    def test_refit_time(self):\n+        X, y = load_iris(return_X_y=True)\n+\n+        # Initialize GridSearchCV with RandomForestClassifier\n+        rs = GridSearchCV(\n+            estimator=RandomForestClassifier(),\n+            param_grid={'n_estimators': [2, 3, 4, 5]},\n+            n_jobs=1  # Ensure single core for simplicity\n+        )\n+\n+        # Fit the model and time the refit process\n+        start_time = time.time()\n+        rs.fit(X, y)\n+        end_time = time.time()\n+\n+        # Calculate the refit time\n+        refit_time = end_time - start_time\n+\n+        # Check if 'refit_time_' attribute exists\n+        # Altered to fail when the issue is observed\n+        self.assertTrue(hasattr(rs, 'refit_time_'), \"__BUG__HERE__\")\n+\n+        # Print the calculated refit time for manual verification\n+        print(f\"Calculated refit time: {refit_time}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 1032455,
  "num_received_chars": 12961,
  "elapsed_time": 168.98879981040955,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}