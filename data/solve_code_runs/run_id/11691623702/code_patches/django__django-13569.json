{
  "instance_id": "django__django-13569",
  "edit_test_file": "tests/aggregation/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 04e430a..7f28e13 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -126,9 +126,9 @@ class SQLCompiler:\n             for col in cols:\n                 expressions.append(col)\n         for expr, (sql, params, is_ref) in order_by:\n-            # Skip References to the select clause, as all expressions in the\n-            # select clause are already part of the group by.\n-            if not is_ref:\n+            # Skip References to the select clause and Random() expressions\n+            # as they should not be part of the GROUP BY clause\n+            if not is_ref and not isinstance(expr.get_source_expressions()[0], Random):\n                 expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n",
  "test_patch": "diff --git a/tests/aggregation/test_random_order_aggregation.py b/tests/aggregation/test_random_order_aggregation.py\nnew file mode 100644\nindex 0000000..87f67a1\n--- /dev/null\n+++ b/tests/aggregation/test_random_order_aggregation.py\n@@ -0,0 +1,55 @@\n+from django.test import TestCase\n+from django.db.models import Count\n+from .models import Author, Book, Publisher\n+\n+class RandomOrderAggregationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.author = Author.objects.create(name='Test Author', age=30)\n+        cls.publisher = Publisher.objects.create(name='Test Publisher', num_awards=1)\n+        \n+        # Create a publisher with multiple books\n+        cls.book1 = Book.objects.create(\n+            isbn='111',\n+            name='Test Book 1',\n+            pages=100,\n+            rating=4.0,\n+            price=10.0,\n+            contact=cls.author,\n+            publisher=cls.publisher,\n+            pubdate='2000-01-01'\n+        )\n+        cls.book2 = Book.objects.create(\n+            isbn='222',\n+            name='Test Book 2', \n+            pages=200,\n+            rating=4.0,\n+            price=20.0,\n+            contact=cls.author,\n+            publisher=cls.publisher,\n+            pubdate='2000-01-01'\n+        )\n+\n+    def test_random_order_breaks_aggregation(self):\n+        # First verify normal aggregation works\n+        normal_query = Publisher.objects.annotate(\n+            book_count=Count('book')\n+        ).values('id', 'book_count')\n+        normal_result = list(normal_query)\n+        \n+        # The publisher should have 2 books in a single result\n+        self.assertEqual(len(normal_result), 1)\n+        self.assertEqual(normal_result[0]['book_count'], 2)\n+\n+        # Now try with random ordering\n+        random_query = Publisher.objects.annotate(\n+            book_count=Count('book')\n+        ).order_by('?').values('id', 'book_count')\n+        random_result = list(random_query)\n+\n+        # This should return the same aggregation, but instead returns\n+        # multiple rows with broken counts\n+        self.assertEqual(len(random_result), 2)  # Incorrectly returns 2 rows\n+        self.assertEqual(random_result[0]['book_count'], 1)  # Count is incorrectly split\n+        self.assertEqual(random_result[1]['book_count'], 1)  # Count is incorrectly split\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/aggregation/test_random_order_aggregation_inverted.py b/tests/aggregation/test_random_order_aggregation_inverted.py\nnew file mode 100644\nindex 0000000..305bba4\n--- /dev/null\n+++ b/tests/aggregation/test_random_order_aggregation_inverted.py\n@@ -0,0 +1,54 @@\n+from django.test import TestCase\n+from django.db.models import Count\n+from .models import Author, Book, Publisher\n+\n+class RandomOrderAggregationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.author = Author.objects.create(name='Test Author', age=30)\n+        cls.publisher = Publisher.objects.create(name='Test Publisher', num_awards=1)\n+        \n+        # Create a publisher with multiple books\n+        cls.book1 = Book.objects.create(\n+            isbn='111',\n+            name='Test Book 1',\n+            pages=100,\n+            rating=4.0,\n+            price=10.0,\n+            contact=cls.author,\n+            publisher=cls.publisher,\n+            pubdate='2000-01-01'\n+        )\n+        cls.book2 = Book.objects.create(\n+            isbn='222',\n+            name='Test Book 2', \n+            pages=200,\n+            rating=4.0,\n+            price=20.0,\n+            contact=cls.author,\n+            publisher=cls.publisher,\n+            pubdate='2000-01-01'\n+        )\n+\n+    def test_random_order_breaks_aggregation(self):\n+        # First verify normal aggregation works\n+        normal_query = Publisher.objects.annotate(\n+            book_count=Count('book')\n+        ).values('id', 'book_count')\n+        normal_result = list(normal_query)\n+        \n+        # The publisher should have 2 books in a single result\n+        self.assertEqual(len(normal_result), 1)\n+        self.assertEqual(normal_result[0]['book_count'], 2)\n+\n+        # Now try with random ordering\n+        random_query = Publisher.objects.annotate(\n+            book_count=Count('book')\n+        ).order_by('?').values('id', 'book_count')\n+        random_result = list(random_query)\n+\n+        # Random ordering should not affect the aggregation results\n+        # This should be a single row with count=2, if it's not, raise an error\n+        if len(random_result) != 1 or random_result[0]['book_count'] != 2:\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 762070,
  "num_received_chars": 7102,
  "elapsed_time": 140.27503633499146,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}