{
  "instance_id": "matplotlib__matplotlib-26208",
  "edit_test_file": "lib/matplotlib/tests/test_collections.py",
  "code_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e32..e94329c 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -2494,6 +2494,16 @@ class _AxesBase(martist.Artist):\n         xys = np.asarray(xys)\n         if not np.any(np.isfinite(xys)):\n             return\n+            \n+        # For twin axes, only update the relevant axis limits\n+        if self in self._twinned_axes:\n+            if self._sharex is not None:\n+                updatey = True\n+                updatex = False\n+            elif self._sharey is not None:\n+                updatex = True\n+                updatey = False\n+                \n         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,\n                                          updatex=updatex, updatey=updatey)\n         self.ignore_existing_data_limits = False\n@@ -4410,6 +4420,13 @@ class _AxesBase(martist.Artist):\n                     [0, 0, 1, 1], self.transAxes))\n         self.set_adjustable('datalim')\n         twin.set_adjustable('datalim')\n+        \n+        # Initialize twin's data limits properly\n+        if 'sharex' in kwargs and kwargs['sharex'] is self:\n+            twin.dataLim.intervalx = self.dataLim.intervalx\n+        elif 'sharey' in kwargs and kwargs['sharey'] is self:\n+            twin.dataLim.intervaly = self.dataLim.intervaly\n+            \n         self._twinned_axes.join(self, twin)\n         return twin\n \n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_twinx_stackplot_datalims_bug.py b/lib/matplotlib/tests/test_twinx_stackplot_datalims_bug.py\nnew file mode 100644\nindex 0000000..e1e05f0\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_twinx_stackplot_datalims_bug.py\n@@ -0,0 +1,29 @@\n+import unittest\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+class TestTwinxStackplotDatalimsBug(unittest.TestCase):\n+    def test_datalims_inf_with_twinx_and_stackplot(self):\n+        def print_datalim(*ax):\n+            return [ax_.dataLim.intervaly for ax_ in ax]\n+\n+        df1_index = ['16 May', '17 May']\n+        df1_values = [-22.717708333333402, 26.584999999999937]\n+        df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+        fig, ax1 = plt.subplots()\n+\n+        ax1.stackplot(df1_index, df1_values)\n+        datalim1 = print_datalim(ax1)\n+\n+        ax2 = ax1.twinx()\n+        datalim2 = print_datalim(ax1, ax2)\n+\n+        ax2.plot(df1_index, df2_values)\n+        datalim3 = print_datalim(ax1, ax2)\n+\n+        # Assert that the dataLims of ax1 become inf after plotting on ax2\n+        self.assertTrue(np.isinf(datalim3[0]).all(), \"ax1 dataLims should be inf after plotting on ax2\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_twinx_stackplot_datalims_bug_inverted.py b/lib/matplotlib/tests/test_twinx_stackplot_datalims_bug_inverted.py\nnew file mode 100644\nindex 0000000..9c37fe3\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_twinx_stackplot_datalims_bug_inverted.py\n@@ -0,0 +1,31 @@\n+import unittest\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+class TestTwinxStackplotDatalimsBug(unittest.TestCase):\n+    def test_datalims_inf_with_twinx_and_stackplot(self):\n+        def print_datalim(*ax):\n+            return [ax_.dataLim.intervaly for ax_ in ax]\n+\n+        df1_index = ['16 May', '17 May']\n+        df1_values = [-22.717708333333402, 26.584999999999937]\n+        df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+        fig, ax1 = plt.subplots()\n+\n+        ax1.stackplot(df1_index, df1_values)\n+        datalim1 = print_datalim(ax1)\n+\n+        ax2 = ax1.twinx()\n+        datalim2 = print_datalim(ax1, ax2)\n+\n+        ax2.plot(df1_index, df2_values)\n+        datalim3 = print_datalim(ax1, ax2)\n+\n+        # Assert that the dataLims of ax1 do not become inf after plotting on ax2\n+        # This should fail if the bug is present\n+        if np.isinf(datalim3[0]).all():\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 5647241,
  "num_received_chars": 74458,
  "elapsed_time": 1250.9837732315063,
  "lint_repair_count": 6,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}