{
  "instance_id": "django__django-11066",
  "edit_test_file": "tests/multiple_database/tests.py",
  "code_patch": "diff --git a/django/contrib/contenttypes/management/__init__.py b/django/contrib/contenttypes/management/__init__.py\nindex 2b5f688..563cba2 100644\n--- a/django/contrib/contenttypes/management/__init__.py\n+++ b/django/contrib/contenttypes/management/__init__.py\n@@ -24,7 +24,7 @@ class RenameContentType(migrations.RunPython):\n             content_type.model = new_model\n             try:\n                 with transaction.atomic(using=db):\n-                    content_type.save(update_fields={'model'})\n+                    content_type.save(using=db, update_fields={'model'})\n             except IntegrityError:\n                 # Gracefully fallback if a stale content type causes a\n                 # conflict as remove_stale_contenttypes will take care of\n",
  "test_patch": "diff --git a/tests/multiple_database/test_rename_content_type_db.py b/tests/multiple_database/test_rename_content_type_db.py\nnew file mode 100644\nindex 0000000..05455f3\n--- /dev/null\n+++ b/tests/multiple_database/test_rename_content_type_db.py\n@@ -0,0 +1,51 @@\n+from django.apps import apps\n+from django.contrib.contenttypes.models import ContentType\n+from django.core.management import call_command\n+from django.db import connections, migrations, router\n+from django.test import TestCase, override_settings\n+\n+class TestRouter:\n+    \"\"\"\n+    Router that sends all operations to 'other' database except for ContentType\n+    which it allows on both databases.\n+    \"\"\"\n+    def allow_migrate(self, db, app_label, model_name=None, **hints):\n+        if app_label == 'contenttypes':\n+            return True\n+        return db == 'other'\n+\n+@override_settings(DATABASE_ROUTERS=['multiple_database.test_rename_content_type_db.TestRouter'])\n+class RenameContentTypeRouterTests(TestCase):\n+    databases = {'default', 'other'}\n+\n+    def setUp(self):\n+        # Create a content type on the 'other' database\n+        ContentType.objects.using('other').create(\n+            app_label='multiple_database',\n+            model='old_model'\n+        )\n+\n+    def test_rename_model_content_type_save_database(self):\n+        \"\"\"\n+        Test that RenameContentType operation tries to save content type\n+        on the wrong database.\n+        \"\"\"\n+        # Create a RenameModel operation\n+        operation = migrations.RenameModel('old_model', 'new_model')\n+        \n+        # Create a RenameContentType operation\n+        rename_op = migrations.RunPython.noop\n+        project_state = None\n+        schema_editor = connections['other'].schema_editor()\n+\n+        # This should raise an OperationalError because it tries to save\n+        # to 'default' database which doesn't have the table\n+        with self.assertRaises(Exception):\n+            with schema_editor as editor:\n+                # Simulate the migration operation that would trigger content type rename\n+                operation.database_forwards(\n+                    'multiple_database',\n+                    editor,\n+                    project_state,\n+                    project_state\n+                )\n\\ No newline at end of file\n",
  "test_inverted_patch": null,
  "num_sent_chars": 6353894,
  "num_received_chars": 83390,
  "elapsed_time": 1038.8546113967896,
  "lint_repair_count": 1,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}