{
  "instance_id": "django__django-13028",
  "edit_test_file": "tests/model_forms/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098..334360d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1124,11 +1124,17 @@ class Query(BaseExpression):\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        # Skip filterable check for basic model instances and values\n+        if not isinstance(expression, BaseExpression) and not hasattr(expression, 'get_source_expressions'):\n+            return\n+\n+        # Only check filterable attribute for expressions and complex objects\n+        if isinstance(expression, BaseExpression) and not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n             )\n+\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n",
  "test_patch": "diff --git a/tests/model_forms/test_product_metadata_filterable.py b/tests/model_forms/test_product_metadata_filterable.py\nnew file mode 100644\nindex 0000000..5024675\n--- /dev/null\n+++ b/tests/model_forms/test_product_metadata_filterable.py\n@@ -0,0 +1,46 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.utils import NotSupportedError\n+from django.utils import timezone\n+\n+\n+class MetadataType(models.Model):\n+    label = models.CharField(max_length=255, unique=True)\n+    filterable = models.BooleanField(default=False)\n+\n+    class Meta:\n+        app_label = 'model_forms'\n+\n+\n+class Metadata(models.Model):\n+    id = models.BigAutoField(primary_key=True)\n+    value = models.TextField()\n+    date_created = models.DateTimeField(default=timezone.now)\n+    metadata_type = models.ForeignKey(MetadataType, on_delete=models.CASCADE)\n+\n+    class Meta:\n+        app_label = 'model_forms'\n+\n+\n+class ProductMetadataFilterableTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.metadata_type = MetadataType.objects.create(\n+            label='Brand',\n+            filterable=False\n+        )\n+        cls.metadata = Metadata.objects.create(\n+            value='Test Brand',\n+            metadata_type=cls.metadata_type\n+        )\n+\n+    def test_filter_raises_not_supported_error(self):\n+        \"\"\"\n+        Test that filtering Metadata with a metadata_type raises NotSupportedError\n+        when the metadata_type model has a field named 'filterable'.\n+        \"\"\"\n+        with self.assertRaisesMessage(NotSupportedError, 'MetadataType is disallowed in the filter clause.'):\n+            list(Metadata.objects.filter(\n+                value='Test Brand',\n+                metadata_type=self.metadata_type\n+            ))\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/model_forms/test_product_metadata_filterable_inverted.py b/tests/model_forms/test_product_metadata_filterable_inverted.py\nnew file mode 100644\nindex 0000000..0023ade\n--- /dev/null\n+++ b/tests/model_forms/test_product_metadata_filterable_inverted.py\n@@ -0,0 +1,50 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.utils import NotSupportedError\n+from django.utils import timezone\n+\n+\n+class MetadataType(models.Model):\n+    label = models.CharField(max_length=255, unique=True)\n+    filterable = models.BooleanField(default=False)\n+\n+    class Meta:\n+        app_label = 'model_forms'\n+\n+\n+class Metadata(models.Model):\n+    id = models.BigAutoField(primary_key=True)\n+    value = models.TextField()\n+    date_created = models.DateTimeField(default=timezone.now)\n+    metadata_type = models.ForeignKey(MetadataType, on_delete=models.CASCADE)\n+\n+    class Meta:\n+        app_label = 'model_forms'\n+\n+\n+class ProductMetadataFilterableTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.metadata_type = MetadataType.objects.create(\n+            label='Brand',\n+            filterable=False\n+        )\n+        cls.metadata = Metadata.objects.create(\n+            value='Test Brand',\n+            metadata_type=cls.metadata_type\n+        )\n+\n+    def test_filter_should_not_raise_error(self):\n+        \"\"\"\n+        Test that filtering Metadata with a metadata_type should not raise NotSupportedError\n+        when the metadata_type model has a field named 'filterable'.\n+        \"\"\"\n+        try:\n+            list(Metadata.objects.filter(\n+                value='Test Brand',\n+                metadata_type=self.metadata_type\n+            ))\n+        except NotSupportedError as e:\n+            if 'MetadataType is disallowed in the filter clause.' in str(e):\n+                raise AssertionError('__BUG__HERE__')\n+            raise e\n\\ No newline at end of file\n",
  "num_sent_chars": 753484,
  "num_received_chars": 7219,
  "elapsed_time": 124.19344830513,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}