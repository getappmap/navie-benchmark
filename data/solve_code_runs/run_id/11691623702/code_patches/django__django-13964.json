{
  "instance_id": "django__django-13964",
  "edit_test_file": "tests/basic/tests.py",
  "code_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 2428218..01ea36e 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -919,10 +919,9 @@ class Model(metaclass=ModelBase):\n                 obj = getattr(self, field.name, None)\n                 if not obj:\n                     continue\n-                # A pk may have been assigned manually to a model instance not\n-                # saved to the database (or auto-generated in a case like\n-                # UUIDField), but we allow the save to proceed and rely on the\n-                # database to raise an IntegrityError if applicable. If\n+                # Get the current PK value from the related object, even if it\n+                # hasn't been saved yet. This handles cases where the PK is\n+                # set after the object was assigned to this field.\n                 # constraints aren't supported by the database, there's the\n                 # unavoidable risk of data corruption.\n                 if obj.pk is None:\n@@ -933,12 +932,16 @@ class Model(metaclass=ModelBase):\n                         \"%s() prohibited to prevent data loss due to unsaved \"\n                         \"related object '%s'.\" % (operation_name, field.name)\n                     )\n-                elif getattr(self, field.attname) is None:\n-                    # Use pk from related object if it has been saved after\n-                    # an assignment.\n-                    setattr(self, field.attname, obj.pk)\n+                # Always update the attname with the current PK value, even if\n+                # it was previously set. This ensures we catch cases where the\n+                # PK was set after the object was assigned to this field.\n+                current_pk = obj.pk\n+                if current_pk is not None:\n+                    setattr(self, field.attname, current_pk)\n                 # If the relationship's pk/to_field was changed, clear the\n                 # cached relationship.\n+                if getattr(self, field.attname) != current_pk:\n+                    field.delete_cached_value(self)\n                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):\n                     field.delete_cached_value(self)\n \n",
  "test_patch": "diff --git a/tests/basic/test_fk_non_numeric_pk_assignment.py b/tests/basic/test_fk_non_numeric_pk_assignment.py\nnew file mode 100644\nindex 0000000..b58f065\n--- /dev/null\n+++ b/tests/basic/test_fk_non_numeric_pk_assignment.py\n@@ -0,0 +1,40 @@\n+from django.db import models, transaction\n+from django.test import TestCase\n+\n+\n+class Product(models.Model):\n+    sku = models.CharField(primary_key=True, max_length=50)\n+\n+\n+class Order(models.Model):\n+    product = models.ForeignKey(Product, on_delete=models.CASCADE)\n+\n+\n+class NonNumericPKAssignmentTest(TestCase):\n+    def test_fk_assignment_with_delayed_pk_setting(self):\n+        \"\"\"\n+        Test that assigning an unsaved instance with unset PK to a foreign key,\n+        then setting the PK afterwards leads to incorrect FK value.\n+        \"\"\"\n+        with self.assertRaises(Exception):  # Transaction will fail on commit\n+            with transaction.atomic():\n+                order = Order()\n+                order.product = Product()  # Assign unsaved product without PK\n+                order.product.sku = \"foo\"  # Set PK after assignment\n+                order.product.save()\n+                order.save()\n+\n+                # The order's product_id should be \"foo\", but it's actually empty\n+                self.assertTrue(\n+                    Order.objects.filter(product_id=\"\").exists(),\n+                    \"Order's product_id should be empty string due to the bug\"\n+                )\n+                \n+                # This fails because the order's product_id is \"\" instead of \"foo\"\n+                self.assertFalse(\n+                    Order.objects.filter(product=order.product).exists(),\n+                    \"Order should not be found when querying by the actual product\"\n+                )\n+\n+                # The transaction will fail on commit due to FK constraint violation\n+                # since there is no Product with sku=\"\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/basic/test_fk_non_numeric_pk_assignment_inverted.py b/tests/basic/test_fk_non_numeric_pk_assignment_inverted.py\nnew file mode 100644\nindex 0000000..4b8707c\n--- /dev/null\n+++ b/tests/basic/test_fk_non_numeric_pk_assignment_inverted.py\n@@ -0,0 +1,42 @@\n+from django.db import models, transaction\n+from django.test import TestCase\n+\n+\n+class Product(models.Model):\n+    sku = models.CharField(primary_key=True, max_length=50)\n+\n+\n+class Order(models.Model):\n+    product = models.ForeignKey(Product, on_delete=models.CASCADE)\n+\n+\n+class NonNumericPKAssignmentTest(TestCase):\n+    def test_fk_assignment_with_delayed_pk_setting(self):\n+        \"\"\"\n+        Test that assigning an unsaved instance with unset PK to a foreign key,\n+        then setting the PK afterwards should properly set the FK value.\n+        The test will fail if the bug is present.\n+        \"\"\"\n+        with transaction.atomic():\n+            order = Order()\n+            order.product = Product()  # Assign unsaved product without PK\n+            order.product.sku = \"foo\"  # Set PK after assignment\n+            order.product.save()\n+            order.save()\n+\n+            # This should raise an AssertionError with \"__BUG__HERE__\" message\n+            # when the bug is present (i.e., when product_id is \"\" instead of \"foo\")\n+            if Order.objects.filter(product_id=\"\").exists():\n+                raise AssertionError(\"__BUG__HERE__\")\n+\n+            # Verify that the order is properly linked to the product\n+            saved_order = Order.objects.get(id=order.id)\n+            self.assertEqual(\n+                saved_order.product_id,\n+                \"foo\",\n+                \"Order's product_id should be 'foo'\"\n+            )\n+            self.assertTrue(\n+                Order.objects.filter(product=order.product).exists(),\n+                \"Order should be found when querying by the actual product\"\n+            )\n\\ No newline at end of file\n",
  "num_sent_chars": 3938605,
  "num_received_chars": 97954,
  "elapsed_time": 795.1918122768402,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": true,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}