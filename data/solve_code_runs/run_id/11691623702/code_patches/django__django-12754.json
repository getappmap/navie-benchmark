{
  "instance_id": "django__django-12754",
  "edit_test_file": "tests/migrations/test_autodetector.py",
  "code_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 30616c0..c74bd6a 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -352,6 +352,20 @@ class MigrationAutodetector:\n                             if self.check_dependency(op2, dep):\n                                 dependency_graph[op].add(op2)\n \n+                # Handle field moves between models in inheritance relationships\n+                if isinstance(op, operations.CreateModel):\n+                    model = self.new_apps.get_model(app_label, op.name)\n+                    if model._meta.parents:\n+                        # This is a child model - look for field removals from parents\n+                        for parent_model in model._meta.parents:\n+                            parent_app_label = parent_model._meta.app_label\n+                            if parent_app_label == app_label:\n+                                for op2 in ops:\n+                                    if (isinstance(op2, operations.RemoveField) and\n+                                            op2.model_name_lower == parent_model._meta.model_name.lower()):\n+                                        # Ensure RemoveField from parent comes before CreateModel for child\n+                                        dependency_graph[op].add(op2)\n+\n             # we use a stable sort for deterministic tests & general behavior\n             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n \n",
  "test_patch": "diff --git a/tests/migrations/test_field_migration_subclass.py b/tests/migrations/test_field_migration_subclass.py\nnew file mode 100644\nindex 0000000..c5f8d49\n--- /dev/null\n+++ b/tests/migrations/test_field_migration_subclass.py\n@@ -0,0 +1,55 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+class FieldMigrationSubclassTests(TestCase):\n+    \"\"\"Test field migrations between parent and child models.\"\"\"\n+    \n+    def test_field_move_to_subclass_wrong_order(self):\n+        \"\"\"\n+        Test that moving a field to a subclass model in the same migration \n+        generates operations in the wrong order (CreateModel then RemoveField)\n+        which would cause a FieldError when applied.\n+        \"\"\"\n+        # Initial state - Readable model with title field\n+        before = ProjectState()\n+        before.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+        ))\n+\n+        # Final state - title field moved to Book subclass\n+        after = ProjectState() \n+        after.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ],\n+        ))\n+        after.add_model(ModelState(\n+            \"testapp\", \n+            \"Book\",\n+            [\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+            bases=(\"testapp.Readable\",),\n+        ))\n+\n+        # Get the detected changes\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Assert that the operations are in the wrong order:\n+        # CreateModel Book (with title field) before RemoveField title from Readable\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(len(changes['testapp'][0].operations), 2)\n+        self.assertEqual(changes['testapp'][0].operations[0].__class__.__name__, \"CreateModel\")\n+        self.assertEqual(changes['testapp'][0].operations[1].__class__.__name__, \"RemoveField\")\n+        self.assertEqual(changes['testapp'][0].operations[0].name, \"Book\")\n+        self.assertEqual(changes['testapp'][0].operations[1].name, \"title\")\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_field_migration_subclass_inverted.py b/tests/migrations/test_field_migration_subclass_inverted.py\nnew file mode 100644\nindex 0000000..12388f4\n--- /dev/null\n+++ b/tests/migrations/test_field_migration_subclass_inverted.py\n@@ -0,0 +1,63 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+class FieldMigrationSubclassTests(TestCase):\n+    \"\"\"Test field migrations between parent and child models.\"\"\"\n+    \n+    def test_field_move_to_subclass_wrong_order(self):\n+        \"\"\"\n+        Test that moving a field to a subclass model should generate operations\n+        in the correct order (RemoveField then CreateModel) to avoid FieldError.\n+        The test should fail if operations are in wrong order.\n+        \"\"\"\n+        # Initial state - Readable model with title field\n+        before = ProjectState()\n+        before.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+        ))\n+\n+        # Final state - title field moved to Book subclass\n+        after = ProjectState() \n+        after.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ],\n+        ))\n+        after.add_model(ModelState(\n+            \"testapp\", \n+            \"Book\",\n+            [\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+            bases=(\"testapp.Readable\",),\n+        ))\n+\n+        # Get the detected changes\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Verify changes exist\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(len(changes['testapp'][0].operations), 2)\n+\n+        # Check operation order - should be RemoveField first, then CreateModel\n+        first_op = changes['testapp'][0].operations[0]\n+        second_op = changes['testapp'][0].operations[1]\n+\n+        if first_op.__class__.__name__ == \"CreateModel\" and second_op.__class__.__name__ == \"RemoveField\":\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify the specific operations\n+        self.assertEqual(first_op.__class__.__name__, \"RemoveField\")\n+        self.assertEqual(second_op.__class__.__name__, \"CreateModel\")\n+        self.assertEqual(first_op.name, \"title\")\n+        self.assertEqual(second_op.name, \"Book\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1977423,
  "num_received_chars": 28798,
  "elapsed_time": 286.424334526062,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 4,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}