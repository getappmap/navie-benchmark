{
  "instance_id": "sphinx-doc__sphinx-9461",
  "edit_test_file": "tests/test_ext_autodoc.py",
  "code_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1cecb1f..5bb8e9e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2661,7 +2661,24 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n     @classmethod\n     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                             ) -> bool:\n-        return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n+        \"\"\"Check if the member can be documented as a property.\n+\n+        Supports:\n+        - regular properties (created by @property decorator)\n+        - class properties (created by @classmethod @property decorators, Python 3.9+)\n+        \"\"\"\n+        # Check if it's a regular property\n+        if inspect.isproperty(member):\n+            return isinstance(parent, ClassDocumenter)\n+\n+        # Check if it's a class property (Python 3.9+)\n+        try:\n+            return (hasattr(member, '__isabstractmethod__') and  # type: ignore\n+                   hasattr(member, 'fget') and\n+                   isinstance(member.fget, classmethod) and\n+                   isinstance(parent, ClassDocumenter))\n+        except (AttributeError, TypeError):\n+            return False\n \n     def document_members(self, all_members: bool = False) -> None:\n         pass\n@@ -2676,9 +2693,17 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         if inspect.isabstractmethod(self.object):\n             self.add_line('   :abstractmethod:', sourcename)\n \n-        if safe_getattr(self.object, 'fget', None) and self.config.autodoc_typehints != 'none':\n+        # Handle both regular properties and class properties\n+        fget = None\n+        if safe_getattr(self.object, 'fget', None):\n+            if isinstance(self.object.fget, classmethod):\n+                fget = self.object.fget.__get__(None, self.parent).__func__\n+            else:\n+                fget = self.object.fget\n+\n+        if fget and self.config.autodoc_typehints != 'none':\n             try:\n-                signature = inspect.signature(self.object.fget,\n+                signature = inspect.signature(fget,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n                     objrepr = stringify_typehint(signature.return_annotation)\n",
  "test_patch": "diff --git a/tests/test_ext_autodoc_classproperty.py b/tests/test_ext_autodoc_classproperty.py\nnew file mode 100644\nindex 0000000..c85db73\n--- /dev/null\n+++ b/tests/test_ext_autodoc_classproperty.py\n@@ -0,0 +1,74 @@\n+\"\"\"\n+    test_ext_autodoc_classproperty\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension with class properties.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import pytest\n+from abc import ABC, abstractmethod\n+\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_class_property(app):\n+    from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n+    from sphinx.util.docutils import LoggingReporter\n+    from unittest.mock import Mock\n+\n+    def do_autodoc(app, objtype, name, options=None):\n+        if options is None:\n+            options = {}\n+        app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n+        doccls = app.registry.documenters[objtype]\n+        docoptions = process_documenter_options(doccls, app.config, options)\n+        state = Mock()\n+        state.document.settings.tab_width = 8\n+        bridge = DocumenterBridge(app.env, LoggingReporter(''), docoptions, 1, state)\n+        documenter = doccls(bridge, name)\n+        documenter.generate()\n+        return bridge.result\n+\n+    # Define test classes in target module\n+    class BaseClass(ABC):\n+        @classmethod\n+        @property\n+        def baseclass_class_property(cls):\n+            \"\"\"Docstring for baseclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        @abstractmethod\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Docstring for baseclass_abstract_class_property.\"\"\"\n+            pass\n+\n+    class SubClass(BaseClass):\n+        @classmethod\n+        @property\n+        def subclass_class_property(cls):\n+            \"\"\"Docstring for subclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Implementation of abstract class property.\"\"\"\n+            return \"property\"\n+\n+    # Test that class properties are not documented\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'class', 'BaseClass', options)\n+    \n+    # The class properties should be missing from the documentation\n+    assert '.. py:property:: BaseClass.baseclass_class_property' not in '\\n'.join(actual)\n+    assert '.. py:property:: BaseClass.baseclass_abstract_class_property' not in '\\n'.join(actual)\n+\n+    actual = do_autodoc(app, 'class', 'SubClass', options)\n+    assert '.. py:property:: SubClass.subclass_class_property' not in '\\n'.join(actual)\n+    assert '.. py:property:: SubClass.baseclass_abstract_class_property' not in '\\n'.join(actual)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_ext_autodoc_classproperty_inverted.py b/tests/test_ext_autodoc_classproperty_inverted.py\nnew file mode 100644\nindex 0000000..9290e0e\n--- /dev/null\n+++ b/tests/test_ext_autodoc_classproperty_inverted.py\n@@ -0,0 +1,80 @@\n+\"\"\"\n+    test_ext_autodoc_classproperty\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension with class properties.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import pytest\n+from abc import ABC, abstractmethod\n+\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_class_property(app):\n+    from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n+    from sphinx.util.docutils import LoggingReporter\n+    from unittest.mock import Mock\n+\n+    def do_autodoc(app, objtype, name, options=None):\n+        if options is None:\n+            options = {}\n+        app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n+        doccls = app.registry.documenters[objtype]\n+        docoptions = process_documenter_options(doccls, app.config, options)\n+        state = Mock()\n+        state.document.settings.tab_width = 8\n+        bridge = DocumenterBridge(app.env, LoggingReporter(''), docoptions, 1, state)\n+        documenter = doccls(bridge, name)\n+        documenter.generate()\n+        return bridge.result\n+\n+    # Define test classes in target module\n+    class BaseClass(ABC):\n+        @classmethod\n+        @property\n+        def baseclass_class_property(cls):\n+            \"\"\"Docstring for baseclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        @abstractmethod\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Docstring for baseclass_abstract_class_property.\"\"\"\n+            pass\n+\n+    class SubClass(BaseClass):\n+        @classmethod\n+        @property\n+        def subclass_class_property(cls):\n+            \"\"\"Docstring for subclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Implementation of abstract class property.\"\"\"\n+            return \"property\"\n+\n+    # Test that class properties are documented\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'class', 'BaseClass', options)\n+    result = '\\n'.join(actual)\n+    \n+    # The class properties should be present in the documentation\n+    if '.. py:property:: BaseClass.baseclass_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    if '.. py:property:: BaseClass.baseclass_abstract_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    actual = do_autodoc(app, 'class', 'SubClass', options)\n+    result = '\\n'.join(actual)\n+    if '.. py:property:: SubClass.subclass_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    if '.. py:property:: SubClass.baseclass_abstract_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3270441,
  "num_received_chars": 61125,
  "elapsed_time": 798.349508523941,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}