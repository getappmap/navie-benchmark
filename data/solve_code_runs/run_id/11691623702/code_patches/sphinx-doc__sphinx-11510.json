{
  "instance_id": "sphinx-doc__sphinx-11510",
  "edit_test_file": "tests/test_application.py",
  "code_patch": "diff --git a/sphinx/application.py b/sphinx/application.py\nindex 6ae2a35..17c6a64 100644\n--- a/sphinx/application.py\n+++ b/sphinx/application.py\n@@ -133,6 +133,8 @@ class Sphinx:\n \n     warningiserror: bool\n     _warncount: int\n+    # Cache for storing modified source content from source-read event\n+    _source_read_cache: dict[str, str]\n \n     def __init__(self, srcdir: str | os.PathLike[str], confdir: str | os.PathLike[str] | None,\n                  outdir: str | os.PathLike[str], doctreedir: str | os.PathLike[str],\n@@ -146,6 +148,7 @@ class Sphinx:\n         self.verbosity = verbosity\n         self.extensions: dict[str, Extension] = {}\n         self.registry = SphinxComponentRegistry()\n+        self._source_read_cache = {}\n \n         # validate provided directories\n         self.srcdir = Path(srcdir).resolve()\n@@ -361,6 +364,9 @@ class Sphinx:\n                 os.unlink(envfile)\n             self.events.emit('build-finished', err)\n             raise\n+        finally:\n+            # Clear the source read cache after build is complete\n+            self._source_read_cache.clear()\n \n         if self._warncount and self.keep_going:\n             self.statuscode = 1\n@@ -468,9 +474,19 @@ class Sphinx:\n         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks\n \n         .. versionchanged:: 3.1\n-\n            Added *allowed_exceptions* to specify path-through exceptions\n         \"\"\"\n+        results = self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)\n+\n+        # Handle source-read event specially to cache modified content\n+        if event == 'source-read' and len(args) >= 2:\n+            docname = args[0]\n+            source = args[1]\n+            if isinstance(source, list) and len(source) > 0:\n+                # Cache the modified source content\n+                self._source_read_cache[docname] = source[0]\n+\n+        return results\n         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)\n \n     def emit_firstresult(self, event: str, *args: Any,\n",
  "test_patch": "diff --git a/tests/test_source_read_include.py b/tests/test_source_read_include.py\nnew file mode 100644\nindex 0000000..92d74f9\n--- /dev/null\n+++ b/tests/test_source_read_include.py\n@@ -0,0 +1,80 @@\n+\"\"\"Test source-read event handling with included files.\"\"\"\n+\n+import os\n+from io import StringIO\n+from pathlib import Path\n+from textwrap import dedent\n+\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html')\n+def test_source_read_include_replacement(tmp_path, monkeypatch):\n+    \"\"\"Test that source-read event properly handles included files.\n+    \n+    This test verifies the issue where source-read event does not properly\n+    modify content from included files, even though the handler is called\n+    for them.\n+    \"\"\"\n+    # Given\n+    srcdir = tmp_path / 'src'\n+    srcdir.mkdir()\n+\n+    # Create the test files\n+    (srcdir / 'conf.py').write_text(dedent('''\n+        extensions = ['test_extension']\n+    '''))\n+\n+    (srcdir / 'index.rst').write_text(dedent('''\n+        Test Document\n+        ============\n+\n+        .. include:: included.rst\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    (srcdir / 'included.rst').write_text(dedent('''\n+        Included Content\n+        ===============\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    # Create the test extension\n+    (srcdir / 'test_extension.py').write_text(dedent('''\n+        def source_read_handler(app, docname, source):\n+            result = source[0]\n+            result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+            source[0] = result\n+\n+        def setup(app):\n+            app.connect('source-read', source_read_handler)\n+            return {\n+                'version': '1.0',\n+                'parallel_read_safe': True,\n+                'parallel_write_safe': True\n+            }\n+    '''))\n+\n+    # When\n+    monkeypatch.syspath_prepend(srcdir)\n+    app = SphinxTestApp(\n+        srcdir=srcdir,\n+        status=StringIO(),\n+        warning=StringIO()\n+    )\n+    app.build()\n+\n+    # Then\n+    output_file = Path(app.outdir) / 'index.html'\n+    content = output_file.read_text()\n+\n+    # Verify that &REPLACE_ME; still appears in the output from the included file,\n+    # demonstrating the issue\n+    assert '&amp;REPLACE_ME;' in content, \\\n+        \"The replacement did not fail as expected - issue not reproduced\"\n+\n+    # Clean up\n+    app.cleanup()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_source_read_include_inverted.py b/tests/test_source_read_include_inverted.py\nnew file mode 100644\nindex 0000000..ec7f069\n--- /dev/null\n+++ b/tests/test_source_read_include_inverted.py\n@@ -0,0 +1,80 @@\n+\"\"\"Test source-read event handling with included files.\"\"\"\n+\n+import os\n+from io import StringIO\n+from pathlib import Path\n+from textwrap import dedent\n+\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html')\n+def test_source_read_include_replacement(tmp_path, monkeypatch):\n+    \"\"\"Test that source-read event properly handles included files.\n+    \n+    This test verifies the issue where source-read event does not properly\n+    modify content from included files, even though the handler is called\n+    for them.\n+    \"\"\"\n+    # Given\n+    srcdir = tmp_path / 'src'\n+    srcdir.mkdir()\n+\n+    # Create the test files\n+    (srcdir / 'conf.py').write_text(dedent('''\n+        extensions = ['test_extension']\n+    '''))\n+\n+    (srcdir / 'index.rst').write_text(dedent('''\n+        Test Document\n+        ============\n+\n+        .. include:: included.rst\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    (srcdir / 'included.rst').write_text(dedent('''\n+        Included Content\n+        ===============\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    # Create the test extension\n+    (srcdir / 'test_extension.py').write_text(dedent('''\n+        def source_read_handler(app, docname, source):\n+            result = source[0]\n+            result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+            source[0] = result\n+\n+        def setup(app):\n+            app.connect('source-read', source_read_handler)\n+            return {\n+                'version': '1.0',\n+                'parallel_read_safe': True,\n+                'parallel_write_safe': True\n+            }\n+    '''))\n+\n+    # When\n+    monkeypatch.syspath_prepend(srcdir)\n+    app = SphinxTestApp(\n+        srcdir=srcdir,\n+        status=StringIO(),\n+        warning=StringIO()\n+    )\n+    app.build()\n+\n+    # Then\n+    output_file = Path(app.outdir) / 'index.html'\n+    content = output_file.read_text()\n+\n+    # Verify that all &REPLACE_ME; instances have been replaced\n+    if '&amp;REPLACE_ME;' in content:\n+        app.cleanup()\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Clean up\n+    app.cleanup()\n\\ No newline at end of file\n",
  "num_sent_chars": 4577201,
  "num_received_chars": 79266,
  "elapsed_time": 987.3902707099915,
  "lint_repair_count": 5,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}