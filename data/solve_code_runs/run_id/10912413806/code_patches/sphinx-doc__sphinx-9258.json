{
  "instance_id": "sphinx-doc__sphinx-9258",
  "edit_test_file": "tests/test_util_typing.py",
  "code_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 7d39d80..b07e929 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -123,6 +123,11 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n                 return [addnodes.desc_sig_punctuation('', \"...\")]\n             else:\n                 return [nodes.Text(node.value)]\n+        elif isinstance(node, ast.BinOp) and isinstance(node.op, ast.BitOr):\n+            # Handle union types using '|'\n+            left = unparse(node.left)\n+            right = unparse(node.right)\n+            return left + [addnodes.desc_sig_punctuation('', '|')] + right\n         elif isinstance(node, ast.Expr):\n             return unparse(node.value)\n         elif isinstance(node, ast.Index):\n@@ -285,21 +290,27 @@ class PyXrefMixin:\n     def make_xref(self, rolename: str, domain: str, target: str,\n                   innernode: Type[TextlikeNode] = nodes.emphasis,\n                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n-        result = super().make_xref(rolename, domain, target,  # type: ignore\n-                                   innernode, contnode, env)\n-        result['refspecific'] = True\n-        result['py:module'] = env.ref_context.get('py:module')\n-        result['py:class'] = env.ref_context.get('py:class')\n-        if target.startswith(('.', '~')):\n-            prefix, result['reftarget'] = target[0], target[1:]\n-            if prefix == '.':\n-                text = target[1:]\n-            elif prefix == '~':\n-                text = target.split('.')[-1]\n-            for node in result.traverse(nodes.Text):\n-                node.parent[node.parent.index(node)] = nodes.Text(text)\n-                break\n-        return result\n+        # Split target by '|' for union types and create xrefs for each\n+        targets = target.split('|')\n+        xrefs = []\n+        for sub_target in targets:\n+            sub_target = sub_target.strip()\n+            result = super().make_xref(rolename, domain, sub_target,  # type: ignore\n+                                       innernode, contnode, env)\n+            result['refspecific'] = True\n+            result['py:module'] = env.ref_context.get('py:module')\n+            result['py:class'] = env.ref_context.get('py:class')\n+            if sub_target.startswith(('.', '~')):\n+                prefix, result['reftarget'] = sub_target[0], sub_target[1:]\n+                if prefix == '.':\n+                    text = sub_target[1:]\n+                elif prefix == '~':\n+                    text = sub_target.split('.')[-1]\n+                for node in result.traverse(nodes.Text):\n+                    node.parent[node.parent.index(node)] = nodes.Text(text)\n+                    break\n+            xrefs.append(result)\n+        return xrefs\n \n     def make_xrefs(self, rolename: str, domain: str, target: str,\n                    innernode: Type[TextlikeNode] = nodes.emphasis,\n",
  "test_patch": "diff --git a/tests/test_ext_union_types.py b/tests/test_ext_union_types.py\nnew file mode 100644\nindex 0000000..991096d\n--- /dev/null\n+++ b/tests/test_ext_union_types.py\n@@ -0,0 +1,22 @@\n+import unittest\n+from sphinx.util.typing import restify\n+\n+class TestUnionTypeSpecification(unittest.TestCase):\n+    def test_union_type_specification_with_pipe(self):\n+        # This test is designed to reproduce the issue with union type specification using '|'\n+        # The expected behavior is that the restify function should not correctly handle the '|'\n+        # syntax for union types, which is the issue we want to reproduce.\n+\n+        # Define a type hint using the '|' syntax\n+        try:\n+            type_hint = bytes | str  # type: ignore\n+            # Attempt to restify the type hint\n+            result = restify(type_hint)\n+            # Check if the result is incorrect as expected\n+            self.assertNotEqual(result, \":class:`bytes` | :class:`str`\")\n+        except TypeError as e:\n+            # Assert that a TypeError is raised, which is the expected issue\n+            self.assertEqual(str(e), \"unsupported operand type(s) for |: 'type' and 'type'\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_ext_union_types_inverted.py b/tests/test_ext_union_types_inverted.py\nnew file mode 100644\nindex 0000000..f6d034f\n--- /dev/null\n+++ b/tests/test_ext_union_types_inverted.py\n@@ -0,0 +1,22 @@\n+import unittest\n+from sphinx.util.typing import restify\n+\n+class TestUnionTypeSpecification(unittest.TestCase):\n+    def test_union_type_specification_with_pipe(self):\n+        # This test is designed to reproduce the issue with union type specification using '|'\n+        # The expected behavior is that the restify function should correctly handle the '|'\n+        # syntax for union types, which is the issue we want to reproduce.\n+\n+        # Define a type hint using the '|' syntax\n+        try:\n+            type_hint = bytes | str  # type: ignore\n+            # Attempt to restify the type hint\n+            result = restify(type_hint)\n+            # Check if the result is correct as expected\n+            self.assertEqual(result, \":class:`bytes` | :class:`str`\")\n+        except TypeError as e:\n+            # Raise an error if a TypeError is raised, which indicates the bug\n+            self.fail(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 1607892,
  "num_received_chars": 53287,
  "elapsed_time": 612.7960340976715,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}