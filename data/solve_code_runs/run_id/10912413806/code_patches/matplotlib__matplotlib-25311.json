{
  "instance_id": "matplotlib__matplotlib-25311",
  "edit_test_file": null,
  "code_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb..61ad733 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -71,8 +71,21 @@ class DraggableLegend(DraggableOffsetBox):\n         _api.check_in_list([\"loc\", \"bbox\"], update=update)\n         self._update = update\n \n+        # Remove direct reference to non-pickleable objects\n+        self._use_blit = use_blit\n+\n         super().__init__(legend, legend._legend_box, use_blit=use_blit)\n \n+    def __getstate__(self):\n+        # Return a state that excludes non-pickleable objects\n+        state = self.__dict__.copy()\n+        del state['legend']\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the state\n+        self.__dict__.update(state)\n+\n     def finalize_offset(self):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n@@ -1173,7 +1186,7 @@ class Legend(Artist):\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\n-\n+    \n         Parameters\n         ----------\n         state : bool\n@@ -1183,10 +1196,10 @@ class Legend(Artist):\n             :ref:`func-animation`.\n         update : {'loc', 'bbox'}, optional\n             The legend parameter to be changed when dragged:\n-\n+    \n             - 'loc': update the *loc* parameter of the legend\n             - 'bbox': update the *bbox_to_anchor* parameter of the legend\n-\n+    \n         Returns\n         -------\n         `.DraggableLegend` or *None*\n@@ -1202,7 +1215,23 @@ class Legend(Artist):\n             if self._draggable is not None:\n                 self._draggable.disconnect()\n             self._draggable = None\n+    \n+        # Store the draggable state for pickling\n+        self._draggable_state = state\n         return self._draggable\n+    \n+    def __getstate__(self):\n+        # Return a state that includes the draggable state\n+        state = self.__dict__.copy()\n+        state['_draggable'] = None  # Exclude non-pickleable DraggableLegend\n+        return state\n+    \n+    def __setstate__(self, state):\n+        # Restore the state\n+        self.__dict__.update(state)\n+        # Reapply the draggable state\n+        if self._draggable_state:\n+            self.set_draggable(True)\n \n     def get_draggable(self):\n         \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 2828240,
  "num_received_chars": 55038,
  "elapsed_time": 544.6710600852966,
  "lint_repair_count": 1,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}