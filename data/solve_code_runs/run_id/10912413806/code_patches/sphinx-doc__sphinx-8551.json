{
  "instance_id": "sphinx-doc__sphinx-8551",
  "edit_test_file": "tests/test_pycode.py",
  "code_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 79d7e4f..b4fe5f6 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -86,8 +86,10 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n         reftype = 'class'\n \n     if env:\n+        # Prioritize current module and class context for resolution\n         kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+                  'py:class': env.ref_context.get('py:class'),\n+                  'refspecific': True}  # Ensure specific reference resolution\n     else:\n         kwargs = {}\n \n",
  "test_patch": "diff --git a/tests/test_cross_reference_warnings.py b/tests/test_cross_reference_warnings.py\nnew file mode 100644\nindex 0000000..03e3da3\n--- /dev/null\n+++ b/tests/test_cross_reference_warnings.py\n@@ -0,0 +1,115 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import ApplicationError\n+from io import StringIO\n+import os\n+\n+class TestCrossReferenceWarnings(unittest.TestCase):\n+    def setUp(self):\n+        self.srcdir = os.path.abspath('source')\n+        self.outdir = os.path.abspath('build')\n+        self.doctreedir = os.path.abspath('build/doctrees')\n+        self.confdir = self.srcdir\n+\n+        # Create necessary directories\n+        os.makedirs(self.srcdir, exist_ok=True)\n+        os.makedirs(self.outdir, exist_ok=True)\n+        os.makedirs(self.doctreedir, exist_ok=True)\n+\n+        # Create a minimal conf.py\n+        with open(os.path.join(self.srcdir, 'conf.py'), 'w') as f:\n+            f.write(\"extensions = []\\n\")\n+\n+        # Create the index.rst file with the content that reproduces the issue\n+        with open(os.path.join(self.srcdir, 'index.rst'), 'w') as f:\n+            f.write(\"\"\"\n+.. py:class:: mod.A\n+.. py:class:: mod.submod.A\n+\n+.. py:function:: f()\n+\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param mod.A a:\n+    :param mod.submod.A b:\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a:\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod.submod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a: BUG: links to mod.A instead of mod.submod.A\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\"\"\")\n+\n+    def test_cross_reference_warnings(self):\n+        # Capture the warnings\n+        warning_stream = StringIO()\n+        app = Sphinx(\n+            srcdir=self.srcdir,\n+            confdir=self.confdir,\n+            outdir=self.outdir,\n+            doctreedir=self.doctreedir,\n+            buildername='html',\n+            warning=warning_stream\n+        )\n+\n+        try:\n+            app.build()\n+        except ApplicationError as e:\n+            self.fail(f\"Sphinx build failed with ApplicationError: {e}\")\n+\n+        warnings = warning_stream.getvalue()\n+        self.assertIn(\"more than one target found for cross-reference 'A'\", warnings)\n+\n+    def tearDown(self):\n+        # Clean up the created directories and files\n+        if os.path.exists(self.srcdir):\n+            for root, dirs, files in os.walk(self.srcdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.srcdir)\n+        if os.path.exists(self.outdir):\n+            for root, dirs, files in os.walk(self.outdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.outdir)\n+        if os.path.exists(self.doctreedir):\n+            for root, dirs, files in os.walk(self.doctreedir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.doctreedir)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_cross_reference_warnings_inverted.py b/tests/test_cross_reference_warnings_inverted.py\nnew file mode 100644\nindex 0000000..8a84290\n--- /dev/null\n+++ b/tests/test_cross_reference_warnings_inverted.py\n@@ -0,0 +1,117 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import ApplicationError\n+from io import StringIO\n+import os\n+\n+class TestCrossReferenceWarnings(unittest.TestCase):\n+    def setUp(self):\n+        self.srcdir = os.path.abspath('source')\n+        self.outdir = os.path.abspath('build')\n+        self.doctreedir = os.path.abspath('build/doctrees')\n+        self.confdir = self.srcdir\n+\n+        # Create necessary directories\n+        os.makedirs(self.srcdir, exist_ok=True)\n+        os.makedirs(self.outdir, exist_ok=True)\n+        os.makedirs(self.doctreedir, exist_ok=True)\n+\n+        # Create a minimal conf.py\n+        with open(os.path.join(self.srcdir, 'conf.py'), 'w') as f:\n+            f.write(\"extensions = []\\n\")\n+\n+        # Create the index.rst file with the content that reproduces the issue\n+        with open(os.path.join(self.srcdir, 'index.rst'), 'w') as f:\n+            f.write(\"\"\"\n+.. py:class:: mod.A\n+.. py:class:: mod.submod.A\n+\n+.. py:function:: f()\n+\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param mod.A a:\n+    :param mod.submod.A b:\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a:\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod.submod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a: BUG: links to mod.A instead of mod.submod.A\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\"\"\")\n+\n+    def test_cross_reference_warnings(self):\n+        # Capture the warnings\n+        warning_stream = StringIO()\n+        app = Sphinx(\n+            srcdir=self.srcdir,\n+            confdir=self.confdir,\n+            outdir=self.outdir,\n+            doctreedir=self.doctreedir,\n+            buildername='html',\n+            warning=warning_stream\n+        )\n+\n+        try:\n+            app.build()\n+        except ApplicationError as e:\n+            self.fail(f\"Sphinx build failed with ApplicationError: {e}\")\n+\n+        warnings = warning_stream.getvalue()\n+        # Alter the test to fail when the issue is observed\n+        if \"more than one target found for cross-reference 'A'\" in warnings:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+    def tearDown(self):\n+        # Clean up the created directories and files\n+        if os.path.exists(self.srcdir):\n+            for root, dirs, files in os.walk(self.srcdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.srcdir)\n+        if os.path.exists(self.outdir):\n+            for root, dirs, files in os.walk(self.outdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.outdir)\n+        if os.path.exists(self.doctreedir):\n+            for root, dirs, files in os.walk(self.doctreedir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.doctreedir)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 1738954,
  "num_received_chars": 44272,
  "elapsed_time": 530.0386962890625,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}