{
  "instance_id": "django__django-11283",
  "edit_test_file": "tests/auth_tests/test_migrations.py",
  "code_patch": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649..7803451 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -22,12 +22,23 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             permissions_query = permissions_query | Q(codename=codename, name=name)\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        # Check for existing permissions to avoid duplicates\n+        existing_perm_query = permissions_query & Q(content_type=proxy_content_type if reverse else concrete_content_type)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Only update permissions that exist in the old content type and don't exist in the new one\n+        perms_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        ).exclude(\n+            Q(codename__in=Permission.objects.filter(\n+                permissions_query,\n+                content_type=new_content_type\n+            ).values_list('codename', flat=True))\n+        )\n+        \n+        perms_to_update.update(content_type=new_content_type)\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/auth_tests/test_proxy_permissions.py b/tests/auth_tests/test_proxy_permissions.py\nnew file mode 100644\nindex 0000000..d09d4cb\n--- /dev/null\n+++ b/tests/auth_tests/test_proxy_permissions.py\n@@ -0,0 +1,55 @@\n+from importlib import import_module\n+\n+from django.apps import apps\n+from django.contrib.auth.models import Permission\n+from django.contrib.contenttypes.models import ContentType\n+from django.db import IntegrityError\n+from django.test import TestCase\n+\n+from .models import Proxy\n+\n+update_proxy_permissions = import_module('django.contrib.auth.migrations.0011_update_proxy_permissions')\n+\n+\n+class ProxyModelPermissionClashTests(TestCase):\n+    \"\"\"\n+    Tests for proxy model permissions when a model is recreated as a proxy model,\n+    which can cause permission clashes during migration 0011_update_proxy_permissions.\n+    \"\"\"\n+    available_apps = [\n+        'auth_tests',\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ]\n+\n+    def setUp(self):\n+        \"\"\"\n+        Create proxy permissions with content_type to the concrete model\n+        rather than the proxy model (as they were before Django 2.2 and\n+        migration 11).\n+        \"\"\"\n+        Permission.objects.all().delete()\n+        self.concrete_content_type = ContentType.objects.get_for_model(Proxy)\n+        \n+        # Create permission for concrete model\n+        self.concrete_permission = Permission.objects.create(\n+            content_type=self.concrete_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+\n+        # Create duplicate permission that would exist if model was recreated as proxy\n+        self.proxy_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=self.proxy_content_type,\n+            codename='add_proxy', \n+            name='Can add proxy',\n+        )\n+\n+    def test_proxy_model_permissions_clash(self):\n+        \"\"\"\n+        Running the 0011 migration should raise an IntegrityError when trying to\n+        update permissions for a model that was recreated as a proxy model.\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/auth_tests/test_proxy_permissions_inverted.py b/tests/auth_tests/test_proxy_permissions_inverted.py\nnew file mode 100644\nindex 0000000..ddcd24e\n--- /dev/null\n+++ b/tests/auth_tests/test_proxy_permissions_inverted.py\n@@ -0,0 +1,60 @@\n+from importlib import import_module\n+\n+from django.apps import apps\n+from django.contrib.auth.models import Permission\n+from django.contrib.contenttypes.models import ContentType\n+from django.db import IntegrityError\n+from django.test import TestCase\n+\n+from .models import Proxy\n+\n+update_proxy_permissions = import_module('django.contrib.auth.migrations.0011_update_proxy_permissions')\n+\n+\n+class ProxyModelPermissionClashTests(TestCase):\n+    \"\"\"\n+    Tests for proxy model permissions when a model is recreated as a proxy model,\n+    which can cause permission clashes during migration 0011_update_proxy_permissions.\n+    \"\"\"\n+    available_apps = [\n+        'auth_tests',\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ]\n+\n+    def setUp(self):\n+        \"\"\"\n+        Create proxy permissions with content_type to the concrete model\n+        rather than the proxy model (as they were before Django 2.2 and\n+        migration 11).\n+        \"\"\"\n+        Permission.objects.all().delete()\n+        self.concrete_content_type = ContentType.objects.get_for_model(Proxy)\n+        \n+        # Create permission for concrete model\n+        self.concrete_permission = Permission.objects.create(\n+            content_type=self.concrete_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+\n+        # Create duplicate permission that would exist if model was recreated as proxy\n+        self.proxy_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=self.proxy_content_type,\n+            codename='add_proxy', \n+            name='Can add proxy',\n+        )\n+\n+    def test_proxy_model_permissions_clash(self):\n+        \"\"\"\n+        Running the 0011 migration should fail when trying to update permissions\n+        for a model that was recreated as a proxy model.\n+        \"\"\"\n+        try:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        except IntegrityError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # If we get here without an IntegrityError, something is wrong\n+        self.fail(\"Expected IntegrityError was not raised\")\n\\ No newline at end of file\n",
  "num_sent_chars": 2153138,
  "num_received_chars": 34020,
  "elapsed_time": 402.2224614620209,
  "lint_repair_count": 0,
  "test_generation_attempts": 2,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}