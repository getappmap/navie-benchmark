{
  "instance_id": "sympy__sympy-14024",
  "edit_test_file": "sympy/simplify/tests/test_simplify.py",
  "code_patch": "diff --git a/sympy/simplify/fu.py b/sympy/simplify/fu.py\nindex 16e1c28..931d72e 100644\n--- a/sympy/simplify/fu.py\n+++ b/sympy/simplify/fu.py\n@@ -220,9 +220,59 @@\n def TR0(rv):\n     \"\"\"Simplification of rational polynomials, trying to simplify\n     the expression, e.g. combine things like 3*x + 2*x, etc....\n+    \n+    Special handling is included for expressions of the form (-a)**x * a**(-x)\n+    to ensure consistent behavior between symbolic and numeric evaluation.\n     \"\"\"\n-    # although it would be nice to use cancel, it doesn't work\n-    # with noncommutatives\n+    from sympy import Mul, Pow, Symbol, Integer\n+    from sympy.core.numbers import One, NegativeOne\n+\n+    def is_valid_power_simplification(base, exp):\n+        \"\"\"Check if (-a)**x * a**(-x) can be simplified to (-1)**x\"\"\"\n+        if base.is_positive is True:\n+            if exp.is_integer:\n+                return True\n+            # For non-integer exponents, only simplify if we can guarantee\n+            # the result will be consistent\n+            if base.is_number and exp.is_real:\n+                return True\n+        return False\n+\n+    def handle_negative_power(expr):\n+        \"\"\"Handle expressions of the form (-a)**x * a**(-x)\"\"\"\n+        if not expr.is_Mul:\n+            return expr\n+            \n+        args = expr.args\n+        if len(args) != 2:\n+            return expr\n+            \n+        # Look for (-a)**x * a**(-x) pattern\n+        neg_base = None\n+        pos_base = None\n+        for arg in args:\n+            if not arg.is_Pow:\n+                continue\n+            base, exp = arg.as_base_exp()\n+            if base.could_extract_minus_sign():\n+                neg_base = arg\n+            else:\n+                pos_base = arg\n+                \n+        if neg_base and pos_base:\n+            neg_b, neg_e = neg_base.as_base_exp()\n+            pos_b, pos_e = pos_base.as_base_exp()\n+            \n+            # Check if bases are related by negation and exponents sum to zero\n+            if (-neg_b == pos_b and neg_e + pos_e == 0 and \n+                    is_valid_power_simplification(pos_b, neg_e)):\n+                return Pow(NegativeOne, neg_e)\n+                \n+        return expr\n+\n+    # First handle any negative power patterns\n+    rv = handle_negative_power(rv)\n+    # Then proceed with normal simplification\n     return rv.normal().factor().expand()\n \n \n",
  "code_files": null,
  "test_patch": "diff --git a/sympy/simplify/tests/test_exponent_simplify.py b/sympy/simplify/tests/test_exponent_simplify.py\nnew file mode 100644\nindex 0000000..530d873\n--- /dev/null\n+++ b/sympy/simplify/tests/test_exponent_simplify.py\n@@ -0,0 +1,30 @@\n+from sympy import Symbol, simplify, S, N\n+from sympy.core.basic import Basic\n+from sympy.utilities.pytest import raises\n+\n+def test_negative_base_simplify():\n+    # Test with symbolic positive integer\n+    a = Symbol('a', integer=True, positive=True)\n+    x = Symbol('x')\n+    t = -S(10)/3\n+    \n+    # Expression with symbolic a\n+    e1 = (-a)**x * a**(-x)\n+    f1 = simplify(e1)\n+    n1 = N(e1.subs(x, t))\n+    n2 = N(f1.subs(x, t))\n+    \n+    # Expression with concrete value a=2\n+    a = S(2)\n+    e2 = (-a)**x * a**(-x)\n+    f2 = simplify(e2)\n+    n3 = N(e2.subs(x, t))\n+    n4 = N(f2.subs(x, t))\n+    \n+    # Test that the numerical values are different\n+    # n1 and n2 should be equal (approximately -0.5 + 0.866025403784439*I)\n+    # n3 and n4 should be different:\n+    # n3 \u2248 0.5 - 0.866025403784439*I\n+    # n4 \u2248 -0.5 + 0.866025403784439*I\n+    assert abs(n1 - n2) < 1e-12\n+    assert abs(n3 - n4) > 1\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/simplify/tests/test_exponent_simplify_inverted.py b/sympy/simplify/tests/test_exponent_simplify_inverted.py\nnew file mode 100644\nindex 0000000..86e10a7\n--- /dev/null\n+++ b/sympy/simplify/tests/test_exponent_simplify_inverted.py\n@@ -0,0 +1,31 @@\n+from sympy import Symbol, simplify, S, N\n+from sympy.core.basic import Basic\n+from sympy.utilities.pytest import raises\n+\n+def test_negative_base_simplify():\n+    # Test with symbolic positive integer\n+    a = Symbol('a', integer=True, positive=True)\n+    x = Symbol('x')\n+    t = -S(10)/3\n+    \n+    # Expression with symbolic a\n+    e1 = (-a)**x * a**(-x)\n+    f1 = simplify(e1)\n+    n1 = N(e1.subs(x, t))\n+    n2 = N(f1.subs(x, t))\n+    \n+    # Expression with concrete value a=2\n+    a = S(2)\n+    e2 = (-a)**x * a**(-x)\n+    f2 = simplify(e2)\n+    n3 = N(e2.subs(x, t))\n+    n4 = N(f2.subs(x, t))\n+    \n+    # First check that symbolic case works correctly\n+    assert abs(n1 - n2) < 1e-12\n+    \n+    # Now check that concrete case gives consistent results\n+    # This should fail when the bug is present, as n3 and n4 should be equal\n+    # but aren't due to the inconsistency\n+    if abs(n3 - n4) > 1e-12:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 6562057,
  "num_received_chars": 93766,
  "elapsed_time": 1703.6664335727692,
  "lint_repair_count": 11,
  "test_generation_attempts": 2,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}