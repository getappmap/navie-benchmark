{
  "instance_id": "scikit-learn__scikit-learn-13497",
  "edit_test_file": "sklearn/feature_selection/tests/test_mutual_info.py",
  "code_patch": "diff --git a/sklearn/feature_selection/mutual_info_.py b/sklearn/feature_selection/mutual_info_.py\nindex d5d1b7f..f880d7b 100644\n--- a/sklearn/feature_selection/mutual_info_.py\n+++ b/sklearn/feature_selection/mutual_info_.py\n@@ -247,19 +247,27 @@ def _estimate_mi(X, y, discrete_features='auto', discrete_target=False,\n     X, y = check_X_y(X, y, accept_sparse='csc', y_numeric=not discrete_target)\n     n_samples, n_features = X.shape\n \n-    if discrete_features == 'auto':\n+    # Handle string 'auto' case first\n+    if isinstance(discrete_features, str):\n+        if discrete_features != 'auto':\n+            raise ValueError(\"If string, discrete_features must be 'auto', got %r\"\n+                           % discrete_features)\n         discrete_features = issparse(X)\n \n     if isinstance(discrete_features, bool):\n         discrete_mask = np.empty(n_features, dtype=bool)\n         discrete_mask.fill(discrete_features)\n     else:\n-        discrete_features = np.asarray(discrete_features)\n-        if discrete_features.dtype != 'bool':\n-            discrete_mask = np.zeros(n_features, dtype=bool)\n-            discrete_mask[discrete_features] = True\n-        else:\n-            discrete_mask = discrete_features\n+        try:\n+            discrete_features = np.asarray(discrete_features)\n+            if discrete_features.dtype != 'bool':\n+                discrete_mask = np.zeros(n_features, dtype=bool)\n+                discrete_mask[discrete_features] = True\n+            else:\n+                discrete_mask = discrete_features\n+        except (IndexError, TypeError) as e:\n+            raise ValueError(\"discrete_features must be 'auto', boolean or \"\n+                           \"array-like of indices or boolean mask\")\n \n     continuous_mask = ~discrete_mask\n     if np.any(continuous_mask) and issparse(X):\n",
  "code_files": null,
  "test_patch": "diff --git a/sklearn/feature_selection/tests/test_discrete_features_mi.py b/sklearn/feature_selection/tests/test_discrete_features_mi.py\nnew file mode 100644\nindex 0000000..2cc1bdb\n--- /dev/null\n+++ b/sklearn/feature_selection/tests/test_discrete_features_mi.py\n@@ -0,0 +1,33 @@\n+import numpy as np\n+import warnings\n+from numpy.testing import assert_warns\n+from sklearn.utils import check_random_state\n+from sklearn.feature_selection.mutual_info_ import mutual_info_classif\n+\n+def test_discrete_features_array_comparison():\n+    \"\"\"Test that comparing array of indices with 'auto' in mutual_info_classif raises warning.\n+    \n+    This test demonstrates the issue where discrete_features can be an array of \n+    indices or boolean mask, but is compared directly with string 'auto' which\n+    will cause issues in future numpy versions.\n+    \"\"\"\n+    # Generate sample data\n+    rng = check_random_state(0)\n+    X = rng.rand(100, 3)  # 100 samples, 3 features\n+    y = rng.randint(0, 2, 100)  # Binary target\n+    \n+    # Create array of indices for discrete features\n+    discrete_features = np.array([0, 2])  # Mark first and last features as discrete\n+    \n+    # The comparison of array with string will raise a warning\n+    with warnings.catch_warnings(record=True) as w:\n+        warnings.simplefilter(\"always\")\n+        mutual_info_classif(X, y, discrete_features=discrete_features, random_state=0)\n+        \n+        # Verify we got a warning about array comparison with string\n+        assert len(w) > 0\n+        assert any(issubclass(warning.category, (FutureWarning, DeprecationWarning)) \n+                  for warning in w)\n+        assert any(\"elementwise comparison failed\" in str(warning.message)\n+                  or \"comparing array with string\" in str(warning.message)\n+                  for warning in w)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sklearn/feature_selection/tests/test_discrete_features_mi_inverted.py b/sklearn/feature_selection/tests/test_discrete_features_mi_inverted.py\nnew file mode 100644\nindex 0000000..2029387\n--- /dev/null\n+++ b/sklearn/feature_selection/tests/test_discrete_features_mi_inverted.py\n@@ -0,0 +1,34 @@\n+import numpy as np\n+import warnings\n+from numpy.testing import assert_raises\n+from sklearn.utils import check_random_state\n+from sklearn.feature_selection.mutual_info_ import mutual_info_classif\n+\n+def test_discrete_features_array_comparison():\n+    \"\"\"Test that comparing array of indices with 'auto' in mutual_info_classif raises error.\n+    \n+    This test verifies that comparing discrete_features array with string 'auto' is\n+    not allowed, as it will cause issues in future numpy versions.\n+    \"\"\"\n+    # Generate sample data\n+    rng = check_random_state(0)\n+    X = rng.rand(100, 3)  # 100 samples, 3 features\n+    y = rng.randint(0, 2, 100)  # Binary target\n+    \n+    # Create array of indices for discrete features\n+    discrete_features = np.array([0, 2])  # Mark first and last features as discrete\n+    \n+    # The comparison of array with string should raise an error\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\"error\")  # Convert warnings to errors\n+        try:\n+            mutual_info_classif(X, y, discrete_features=discrete_features, random_state=0)\n+        except (FutureWarning, DeprecationWarning) as e:\n+            if \"elementwise comparison failed\" in str(e) or \"comparing array with string\" in str(e):\n+                raise AssertionError(\"__BUG__HERE__\")\n+            raise  # Re-raise if it's a different warning\n+        except Exception as e:\n+            raise  # Re-raise any other exception\n+        \n+        # If we get here without any warning/error, that's a problem\n+        raise AssertionError(\"Expected warning about array comparison with string was not raised\")\n\\ No newline at end of file\n",
  "num_sent_chars": 4817238,
  "num_received_chars": 50338,
  "elapsed_time": 910.8987364768982,
  "lint_repair_count": 0,
  "test_generation_attempts": 2,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}