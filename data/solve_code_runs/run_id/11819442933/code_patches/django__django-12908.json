{
  "instance_id": "django__django-12908",
  "edit_test_file": "tests/queries/test_qs_combinators.py",
  "code_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eecce..9268ab7 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1140,6 +1140,12 @@ class QuerySet:\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot create distinct fields once a slice has been taken.\"\n+        if self.query.combinator and self.query.annotations:\n+            raise NotSupportedError(\n+                'distinct() is not supported on a combined query with '\n+                'annotations. You must call distinct() before annotate() '\n+                'when using union(), intersection(), or difference().'\n+            )\n         obj = self._chain()\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/queries/test_union_distinct.py b/tests/queries/test_union_distinct.py\nnew file mode 100644\nindex 0000000..068ea34\n--- /dev/null\n+++ b/tests/queries/test_union_distinct.py\n@@ -0,0 +1,36 @@\n+from django.db import models\n+from django.db.models import Value, IntegerField\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class UnionDistinctTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data with duplicate names\n+        Number.objects.bulk_create([\n+            Number(num=1, other_num=1),\n+            Number(num=1, other_num=2),  # Duplicate num=1\n+            Number(num=2, other_num=3),\n+            Number(num=2, other_num=4),  # Duplicate num=2\n+            Number(num=3, other_num=5),\n+        ])\n+\n+    def test_union_annotated_distinct_not_working(self):\n+        \"\"\"\n+        Test that distinct() after union() of annotated querysets doesn't work as expected.\n+        The test passes when the issue is present (distinct not working).\n+        \"\"\"\n+        # Create two querysets with annotations\n+        qs1 = Number.objects.filter(num=1).annotate(rank=Value(0, IntegerField()))\n+        qs2 = Number.objects.filter(num=2).annotate(rank=Value(1, IntegerField()))\n+        \n+        # Union the querysets and try to apply distinct\n+        union_qs = qs1.union(qs2)\n+        result = union_qs.order_by('num').distinct('num')\n+        \n+        # When the issue is present, distinct() won't remove duplicates\n+        # So we'll get more results than we should\n+        # We expect 4 results (2 for num=1 and 2 for num=2) instead of 2\n+        self.assertEqual(result.count(), 4)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/queries/test_union_distinct_inverted.py b/tests/queries/test_union_distinct_inverted.py\nnew file mode 100644\nindex 0000000..2ead365\n--- /dev/null\n+++ b/tests/queries/test_union_distinct_inverted.py\n@@ -0,0 +1,44 @@\n+from django.db import models\n+from django.db.models import Value, IntegerField\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class UnionDistinctTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data with duplicate names\n+        Number.objects.bulk_create([\n+            Number(num=1, other_num=1),\n+            Number(num=1, other_num=2),  # Duplicate num=1\n+            Number(num=2, other_num=3),\n+            Number(num=2, other_num=4),  # Duplicate num=2\n+            Number(num=3, other_num=5),\n+        ])\n+\n+    def test_union_annotated_distinct_should_work(self):\n+        \"\"\"\n+        Test that distinct() after union() of annotated querysets should work correctly.\n+        The test fails when the issue is present (distinct not working).\n+        \"\"\"\n+        # Create two querysets with annotations\n+        qs1 = Number.objects.filter(num=1).annotate(rank=Value(0, IntegerField()))\n+        qs2 = Number.objects.filter(num=2).annotate(rank=Value(1, IntegerField()))\n+        \n+        # Union the querysets and try to apply distinct\n+        union_qs = qs1.union(qs2)\n+        result = union_qs.order_by('num').distinct('num')\n+        \n+        # Count the results\n+        result_count = result.count()\n+        \n+        # When distinct works correctly, we should get exactly one result per num value\n+        # If we get more than 2 results, it means distinct() isn't working\n+        if result_count > 2:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # Additional verification\n+        self.assertEqual(result_count, 2, \n+            \"Expected 2 distinct results (one per num value), but got {}\"\n+            .format(result_count))\n\\ No newline at end of file\n",
  "num_sent_chars": 2315598,
  "num_received_chars": 32007,
  "elapsed_time": 565.8258442878723,
  "lint_repair_count": 2,
  "test_generation_attempts": 1,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}