{
  "instance_id": "django__django-11001",
  "edit_test_file": "tests/expressions/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c39..a2bc493 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -32,7 +32,7 @@ class SQLCompiler:\n         self.select = None\n         self.annotation_col_map = None\n         self.klass_info = None\n-        self.ordering_parts = re.compile(r'(.*)\\s(ASC|DESC)(.*)')\n+        self.ordering_parts = re.compile(r'(.*?)\\s(ASC|DESC)(.*?)$', re.MULTILINE | re.DOTALL)\n         self._meta_ordering = None\n \n     def setup_query(self):\n@@ -353,7 +353,13 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n-            without_ordering = self.ordering_parts.search(sql).group(1)\n+            # Normalize the SQL by removing extra whitespace and newlines\n+            normalized_sql = ' '.join(sql.split())\n+            match = self.ordering_parts.search(normalized_sql)\n+            if match:\n+                without_ordering = match.group(1)\n+            else:\n+                without_ordering = normalized_sql\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n                 continue\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/expressions/test_order_by_rawsql.py b/tests/expressions/test_order_by_rawsql.py\nnew file mode 100644\nindex 0000000..cc7fec8\n--- /dev/null\n+++ b/tests/expressions/test_order_by_rawsql.py\n@@ -0,0 +1,61 @@\n+from django.test import TestCase\n+from django.db.models import F\n+from django.db.models.expressions import RawSQL\n+from .models import Company, Employee\n+\n+class OrderByRawSQLTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data with different statuses and dates\n+        cls.e1 = Employee.objects.create(firstname=\"Joe\", lastname=\"Smith\", salary=20)\n+        cls.e2 = Employee.objects.create(firstname=\"Jane\", lastname=\"Jones\", salary=30)\n+        cls.e3 = Employee.objects.create(firstname=\"Bob\", lastname=\"Brown\", salary=40)\n+        \n+        cls.c1 = Company.objects.create(\n+            name=\"Company 1\",\n+            num_employees=10,\n+            num_chairs=20,\n+            ceo=cls.e1\n+        )\n+        cls.c2 = Company.objects.create(\n+            name=\"Company 2\", \n+            num_employees=20,\n+            num_chairs=30,\n+            ceo=cls.e2\n+        )\n+        cls.c3 = Company.objects.create(\n+            name=\"Company 3\",\n+            num_employees=30,\n+            num_chairs=40,\n+            ceo=cls.e3\n+        )\n+\n+    def test_order_by_multiline_rawsql(self):\n+        \"\"\"\n+        Test that multiple RawSQL order_by() clauses with similar endings\n+        are not incorrectly treated as duplicates and removed.\n+        \"\"\"\n+        # Query using multiple similar multiline RawSQL expressions\n+        qs = Company.objects.order_by(\n+            RawSQL('''\n+                CASE WHEN num_employees > 25\n+                     THEN 2 \n+                     ELSE 1 END''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN num_chairs > 25\n+                     THEN num_chairs\n+                     ELSE NULL END''', []).asc(),\n+            RawSQL('''\n+                CASE WHEN num_chairs <= 25  \n+                     THEN num_chairs\n+                     ELSE NULL END''', []).desc()\n+        )\n+\n+        # The bug causes the second RawSQL to be removed since it ends with\n+        # \"ELSE NULL END\" like the third one. This results in incorrect ordering.\n+        # With the bug, the order will be wrong - verify the incorrect order\n+        # is produced to demonstrate the issue\n+        companies = list(qs)\n+        self.assertEqual(companies[0], self.c3)  # num_employees > 25\n+        self.assertEqual(companies[1], self.c1)  # num_chairs <= 25\n+        self.assertEqual(companies[2], self.c2)  # num_chairs <= 25\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/expressions/test_order_by_rawsql_inverted.py b/tests/expressions/test_order_by_rawsql_inverted.py\nnew file mode 100644\nindex 0000000..68b5492\n--- /dev/null\n+++ b/tests/expressions/test_order_by_rawsql_inverted.py\n@@ -0,0 +1,71 @@\n+from django.test import TestCase\n+from django.db.models import F\n+from django.db.models.expressions import RawSQL\n+from .models import Company, Employee\n+\n+class OrderByRawSQLTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data with different statuses and dates\n+        cls.e1 = Employee.objects.create(firstname=\"Joe\", lastname=\"Smith\", salary=20)\n+        cls.e2 = Employee.objects.create(firstname=\"Jane\", lastname=\"Jones\", salary=30)\n+        cls.e3 = Employee.objects.create(firstname=\"Bob\", lastname=\"Brown\", salary=40)\n+        \n+        cls.c1 = Company.objects.create(\n+            name=\"Company 1\",\n+            num_employees=10,\n+            num_chairs=20,\n+            ceo=cls.e1\n+        )\n+        cls.c2 = Company.objects.create(\n+            name=\"Company 2\", \n+            num_employees=20,\n+            num_chairs=30,\n+            ceo=cls.e2\n+        )\n+        cls.c3 = Company.objects.create(\n+            name=\"Company 3\",\n+            num_employees=30,\n+            num_chairs=40,\n+            ceo=cls.e3\n+        )\n+\n+    def test_order_by_multiline_rawsql(self):\n+        \"\"\"\n+        Test that multiple RawSQL order_by() clauses with similar endings\n+        are not incorrectly treated as duplicates and removed.\n+        \"\"\"\n+        # Query using multiple similar multiline RawSQL expressions\n+        qs = Company.objects.order_by(\n+            RawSQL('''\n+                CASE WHEN num_employees > 25\n+                     THEN 2 \n+                     ELSE 1 END''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN num_chairs > 25\n+                     THEN num_chairs\n+                     ELSE NULL END''', []).asc(),\n+            RawSQL('''\n+                CASE WHEN num_chairs <= 25  \n+                     THEN num_chairs\n+                     ELSE NULL END''', []).desc()\n+        )\n+\n+        # Get the ordered companies\n+        companies = list(qs)\n+\n+        # When the bug is present, the second RawSQL is incorrectly removed\n+        # This means companies with num_chairs > 25 won't be ordered correctly\n+        # The expected correct order should be:\n+        # 1. c3 (num_employees > 25)\n+        # 2. c2 (num_chairs > 25, should be ordered by num_chairs ASC)\n+        # 3. c1 (num_chairs <= 25)\n+        \n+        # Check if c2 is in the correct position (second)\n+        # When the bug is present, c2 will be in the wrong position\n+        if companies[1] != self.c2:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Additional assertions to verify complete ordering\n+        self.assertEqual(companies[0], self.c3)\n+        self.assertEqual(companies[2], self.c1)\n\\ No newline at end of file\n",
  "num_sent_chars": 5586296,
  "num_received_chars": 86690,
  "elapsed_time": 1030.9373383522034,
  "lint_repair_count": 0,
  "test_generation_attempts": 8,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}