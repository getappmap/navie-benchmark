{
  "instance_id": "django__django-16910",
  "edit_test_file": "tests/defer/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc92..50b6a57 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1250,7 +1250,8 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                field_key = (related_field.name, related_field) if related_field.one_to_one else related_field\n+                related_select_mask = select_mask.get(field_key) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1284,6 +1285,10 @@ class SQLCompiler:\n                     opts=model._meta,\n                     from_parent=opts.model,\n                 )\n+                # For reverse one-to-one relations, ensure we respect field selection\n+                if related_field.one_to_one and related_field.remote_field:\n+                    field_select_mask = select_mask.get((related_field.name, related_field)) or {}\n+                    columns = [col for col in columns if col.target in field_select_mask or col.target.primary_key]\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/defer/test_reverse_onetoone_only_select_related.py b/tests/defer/test_reverse_onetoone_only_select_related.py\nnew file mode 100644\nindex 0000000..d3b28a4\n--- /dev/null\n+++ b/tests/defer/test_reverse_onetoone_only_select_related.py\n@@ -0,0 +1,45 @@\n+from django.test import TestCase\n+from django.db import models, connection\n+from django.test.utils import CaptureQueriesContext\n+\n+class Main(models.Model):\n+    main_field_1 = models.CharField(blank=True, max_length=45)\n+    main_field_2 = models.CharField(blank=True, max_length=45)\n+    main_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneSecondary(models.Model):\n+    main = models.OneToOneField(Main, primary_key=True, related_name='secondary', on_delete=models.CASCADE)\n+    secondary_field_1 = models.CharField(blank=True, max_length=45)\n+    secondary_field_2 = models.CharField(blank=True, max_length=45)\n+    secondary_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneOnlySelectRelatedTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        main = Main.objects.create(\n+            main_field_1=\"main1\",\n+            main_field_2=\"main2\",\n+            main_field_3=\"main3\"\n+        )\n+        ReverseOneToOneSecondary.objects.create(\n+            main=main,\n+            secondary_field_1=\"sec1\",\n+            secondary_field_2=\"sec2\",\n+            secondary_field_3=\"sec3\"\n+        )\n+\n+    def test_only_select_related_reverse_onetoone(self):\n+        \"\"\"\n+        Test that only() with select_related() on reverse OneToOne includes all fields.\n+        \"\"\"\n+        with CaptureQueriesContext(connection) as ctx:\n+            list(Main.objects.select_related('secondary').only(\n+                'main_field_1', \n+                'secondary__secondary_field_1'\n+            ))\n+            \n+        sql = ctx.captured_queries[0]['sql'].lower()\n+        \n+        # These fields should be in the query even though only() was used\n+        self.assertIn('secondary_field_2', sql)\n+        self.assertIn('secondary_field_3', sql)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/defer/test_reverse_onetoone_only_select_related_inverted.py b/tests/defer/test_reverse_onetoone_only_select_related_inverted.py\nnew file mode 100644\nindex 0000000..8df579d\n--- /dev/null\n+++ b/tests/defer/test_reverse_onetoone_only_select_related_inverted.py\n@@ -0,0 +1,46 @@\n+from django.test import TestCase\n+from django.db import models, connection\n+from django.test.utils import CaptureQueriesContext\n+\n+class Main(models.Model):\n+    main_field_1 = models.CharField(blank=True, max_length=45)\n+    main_field_2 = models.CharField(blank=True, max_length=45)\n+    main_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneSecondary(models.Model):\n+    main = models.OneToOneField(Main, primary_key=True, related_name='secondary', on_delete=models.CASCADE)\n+    secondary_field_1 = models.CharField(blank=True, max_length=45)\n+    secondary_field_2 = models.CharField(blank=True, max_length=45)\n+    secondary_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneOnlySelectRelatedTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        main = Main.objects.create(\n+            main_field_1=\"main1\",\n+            main_field_2=\"main2\",\n+            main_field_3=\"main3\"\n+        )\n+        ReverseOneToOneSecondary.objects.create(\n+            main=main,\n+            secondary_field_1=\"sec1\",\n+            secondary_field_2=\"sec2\",\n+            secondary_field_3=\"sec3\"\n+        )\n+\n+    def test_only_select_related_reverse_onetoone(self):\n+        \"\"\"\n+        Test that only() with select_related() on reverse OneToOne includes only the specified fields.\n+        The test should fail if additional fields are included in the query.\n+        \"\"\"\n+        with CaptureQueriesContext(connection) as ctx:\n+            list(Main.objects.select_related('secondary').only(\n+                'main_field_1', \n+                'secondary__secondary_field_1'\n+            ))\n+            \n+        sql = ctx.captured_queries[0]['sql'].lower()\n+        \n+        # These fields should NOT be in the query when only() is used\n+        if 'secondary_field_2' in sql or 'secondary_field_3' in sql:\n+            raise AssertionError(\"__BUG__HERE__: Query includes fields that should be excluded by only()\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3387474,
  "num_received_chars": 50897,
  "elapsed_time": 738.0601699352264,
  "lint_repair_count": 0,
  "test_generation_attempts": 3,
  "code_generation_attempts": 5,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}