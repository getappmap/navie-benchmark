{
  "instance_id": "matplotlib__matplotlib-22835",
  "edit_test_file": "lib/matplotlib/tests/test_colors.py",
  "code_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d..2ffd492 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -13,6 +13,7 @@ import numpy as np\n import matplotlib as mpl\n from . import _api, cbook\n from .cm import ScalarMappable\n+from . import colors as mcolors\n from .path import Path\n from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n                          TransformedPatchPath, TransformedPath)\n@@ -1303,10 +1304,25 @@ class Artist:\n                 return \"[]\"\n             normed = self.norm(data)\n             if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n+                if isinstance(self.norm, mcolors.BoundaryNorm):\n+                    # For BoundaryNorm, find the boundaries that bracket the data value\n+                    boundaries = self.norm.boundaries\n+                    idx = np.searchsorted(boundaries, data)\n+                    if idx == 0:\n+                        delta = abs(data - boundaries[0])\n+                    elif idx == len(boundaries):\n+                        delta = abs(data - boundaries[-1])\n+                    else:\n+                        # Use the width of the interval containing the data\n+                        delta = abs(boundaries[idx] - boundaries[idx-1])\n+                else:\n+                    # For other norms, try to use inverse to find neighboring points\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                    except (ValueError, AttributeError):\n+                        delta = 0.000001  # Fallback if inverse fails\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n",
  "code_files": null,
  "test_patch": "diff --git a/lib/matplotlib/tests/test_boundary_norm_cursor.py b/lib/matplotlib/tests/test_boundary_norm_cursor.py\nnew file mode 100644\nindex 0000000..eda9cb0\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_boundary_norm_cursor.py\n@@ -0,0 +1,22 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pytest\n+from matplotlib import colors\n+\n+def test_boundary_norm_cursor_data():\n+    \"\"\"Test that BoundaryNorm raises ValueError when used with format_cursor_data\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(10, 10)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # Create a dummy event with coordinates inside the image\n+    from matplotlib.backend_bases import MouseEvent\n+    x, y = 5, 5  # Center of the 10x10 image\n+    xdisp, ydisp = ax.transData.transform([x, y])\n+    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp)\n+    \n+    # The cursor data retrieval should raise ValueError due to BoundaryNorm not being invertible\n+    with pytest.raises(ValueError, match=\"BoundaryNorm is not invertible\"):\n+        cursor_data = im.get_cursor_data(event)\n+        im.format_cursor_data(cursor_data)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_boundary_norm_cursor_inverted.py b/lib/matplotlib/tests/test_boundary_norm_cursor_inverted.py\nnew file mode 100644\nindex 0000000..b6a8669\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_boundary_norm_cursor_inverted.py\n@@ -0,0 +1,31 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pytest\n+from matplotlib import colors\n+\n+def test_boundary_norm_cursor_data():\n+    \"\"\"Test that BoundaryNorm handles cursor data formatting correctly\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(10, 10)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # Create a dummy event with coordinates inside the image\n+    from matplotlib.backend_bases import MouseEvent\n+    x, y = 5, 5  # Center of the 10x10 image\n+    xdisp, ydisp = ax.transData.transform([x, y])\n+    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp)\n+    \n+    # Get cursor data\n+    cursor_data = im.get_cursor_data(event)\n+    \n+    try:\n+        # This should work, but currently raises ValueError\n+        formatted_data = im.format_cursor_data(cursor_data)\n+    except ValueError as e:\n+        if \"BoundaryNorm is not invertible\" in str(e):\n+            raise ValueError(\"__BUG__HERE__\") from e\n+        raise e\n+\n+    # If we get here without an exception, the test passes\n+    assert formatted_data is not None\n\\ No newline at end of file\n",
  "num_sent_chars": 3236428,
  "num_received_chars": 34903,
  "elapsed_time": 551.4250893592834,
  "lint_repair_count": 1,
  "test_generation_attempts": 1,
  "code_generation_attempts": 4,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}