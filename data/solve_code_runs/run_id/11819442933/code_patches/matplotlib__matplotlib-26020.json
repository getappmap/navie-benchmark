{
  "instance_id": "matplotlib__matplotlib-26020",
  "edit_test_file": "lib/matplotlib/tests/test_figure.py",
  "code_patch": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex ae78eab..0e62ef7 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -27,6 +27,34 @@ import matplotlib\n from matplotlib import _api, _c_internal_utils\n \n \n+def get_axis_from_axes(ax, axis_name):\n+    \"\"\"\n+    Get the axis object from an Axes instance, handling both dictionary-style\n+    and method-style axis access.\n+\n+    Parameters\n+    ----------\n+    ax : `~matplotlib.axes.Axes`\n+        The Axes instance to get the axis from.\n+    axis_name : str\n+        The name of the axis to get (e.g., \"bottom\", \"left\", etc.)\n+\n+    Returns\n+    -------\n+    axis\n+        The requested axis object.\n+\n+    Notes\n+    -----\n+    Some Axes classes implement axis access as a dictionary (ax.axis[\"bottom\"]),\n+    while others implement it as a method (ax.axis()). This function handles\n+    both cases safely.\n+    \"\"\"\n+    try:\n+        return ax.axis[axis_name] if not callable(ax.axis) else ax.axis(axis_name)\n+    except (TypeError, ValueError, KeyError) as e:\n+        raise TypeError(f\"Could not access axis '{axis_name}' from axes {ax}\") from e\n+\n def _get_running_interactive_framework():\n     \"\"\"\n     Return the interactive framework whose event loop is currently running, if\n\ndiff --git a/lib/mpl_toolkits/axes_grid1/axes_grid.py b/lib/mpl_toolkits/axes_grid1/axes_grid.py\nindex 2b1b1d3..4fa8396 100644\n--- a/lib/mpl_toolkits/axes_grid1/axes_grid.py\n+++ b/lib/mpl_toolkits/axes_grid1/axes_grid.py\n@@ -13,8 +13,10 @@ from .mpl_axes import Axes\n def _tick_only(ax, bottom_on, left_on):\n     bottom_off = not bottom_on\n     left_off = not left_on\n-    ax.axis[\"bottom\"].toggle(ticklabels=bottom_off, label=bottom_off)\n-    ax.axis[\"left\"].toggle(ticklabels=left_off, label=left_off)\n+    bottom_axis = cbook.get_axis_from_axes(ax, \"bottom\")\n+    left_axis = cbook.get_axis_from_axes(ax, \"left\")\n+    bottom_axis.toggle(ticklabels=bottom_off, label=bottom_off)\n+    left_axis.toggle(ticklabels=left_off, label=left_off)\n \n \n class CbarAxesBase:\n",
  "code_files": null,
  "test_patch": "diff --git a/lib/matplotlib/tests/test_axes_grid_geoaxes.py b/lib/matplotlib/tests/test_axes_grid_geoaxes.py\nnew file mode 100644\nindex 0000000..956f50a\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_axes_grid_geoaxes.py\n@@ -0,0 +1,13 @@\n+import pytest\n+from matplotlib import pyplot as plt\n+from matplotlib.projections.geo import HammerAxes\n+from mpl_toolkits.axes_grid1 import AxesGrid\n+\n+\n+def test_axes_grid_geoaxes():\n+    \"\"\"Test that creating AxesGrid with GeoAxes raises TypeError.\"\"\"\n+    fig = plt.figure()\n+    axes_class = (HammerAxes, dict())\n+    \n+    with pytest.raises(TypeError, match=\"'method' object is not subscriptable\"):\n+        AxesGrid(fig, 111, nrows_ncols=(1, 1), axes_class=axes_class)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_axes_grid_geoaxes_inverted.py b/lib/matplotlib/tests/test_axes_grid_geoaxes_inverted.py\nnew file mode 100644\nindex 0000000..02ac4eb\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_axes_grid_geoaxes_inverted.py\n@@ -0,0 +1,21 @@\n+import pytest\n+from matplotlib import pyplot as plt\n+from matplotlib.projections.geo import HammerAxes\n+from mpl_toolkits.axes_grid1 import AxesGrid\n+\n+\n+def test_axes_grid_geoaxes():\n+    \"\"\"Test that creating AxesGrid with GeoAxes works correctly.\"\"\"\n+    fig = plt.figure()\n+    axes_class = (HammerAxes, dict())\n+    \n+    try:\n+        AxesGrid(fig, 111, nrows_ncols=(1, 1), axes_class=axes_class)\n+        # If we get here, the bug is not present (no TypeError was raised)\n+    except TypeError as e:\n+        if \"'method' object is not subscriptable\" in str(e):\n+            # The bug is present, so we should fail the test\n+            raise AssertionError(\"__BUG__HERE__\")\n+        else:\n+            # Some other TypeError occurred, we should let it propagate\n+            raise\n\\ No newline at end of file\n",
  "num_sent_chars": 7102606,
  "num_received_chars": 68291,
  "elapsed_time": 1457.5659487247467,
  "lint_repair_count": 7,
  "test_generation_attempts": 7,
  "code_generation_attempts": 6,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}