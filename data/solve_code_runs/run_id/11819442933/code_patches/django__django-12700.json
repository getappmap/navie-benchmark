{
  "instance_id": "django__django-12700",
  "edit_test_file": "tests/view_tests/tests/test_debug.py",
  "code_patch": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d..d92f9b6 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -83,13 +83,15 @@ class SafeExceptionReporterFilter:\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n-        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        value is a dictionary or other iterable, recursively cleanse the values.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)) and not isinstance(value, str):\n+                cleansed = type(value)(self.cleanse_setting(key, item) for item in value)\n             else:\n                 cleansed = value\n         except TypeError:\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/view_tests/tests/test_settings_cleansing.py b/tests/view_tests/tests/test_settings_cleansing.py\nnew file mode 100644\nindex 0000000..7b8e56a\n--- /dev/null\n+++ b/tests/view_tests/tests/test_settings_cleansing.py\n@@ -0,0 +1,56 @@\n+from django.test import SimpleTestCase, override_settings\n+from django.views.debug import SafeExceptionReporterFilter\n+\n+NESTED_SENSITIVE_SETTINGS = {\n+    'MY_SETTING': {\n+        'foo': 'value',\n+        'secret': 'value',\n+        'token': 'value',\n+        'something': [\n+            {'foo': 'value'},\n+            {'secret': 'value'},\n+            {'token': 'value'},\n+        ],\n+        'else': [\n+            [\n+                {'foo': 'value'},\n+                {'secret': 'value'},\n+                {'token': 'value'},\n+            ],\n+            [\n+                {'foo': 'value'},\n+                {'secret': 'value'},\n+                {'token': 'value'},\n+            ],\n+        ]\n+    }\n+}\n+\n+class SettingsCleansedInsufficientlyTests(SimpleTestCase):\n+    \"\"\"\n+    Test that sensitive settings within nested iterables are not properly cleansed.\n+    \"\"\"\n+    @override_settings(**NESTED_SENSITIVE_SETTINGS)\n+    def test_nested_sensitive_settings_not_cleansed(self):\n+        \"\"\"\n+        The SafeExceptionReporterFilter fails to cleanse sensitive values that are\n+        inside lists or other iterables within settings dictionaries.\n+        \"\"\"\n+        reporter_filter = SafeExceptionReporterFilter()\n+        cleansed_settings = reporter_filter.get_safe_settings()\n+        \n+        # The top level sensitive keys should be cleansed\n+        self.assertEqual(cleansed_settings['MY_SETTING']['secret'], reporter_filter.cleansed_substitute)\n+        self.assertEqual(cleansed_settings['MY_SETTING']['token'], reporter_filter.cleansed_substitute)\n+        \n+        # But sensitive values in nested lists remain uncleansed\n+        something = cleansed_settings['MY_SETTING']['something']\n+        self.assertEqual(something[1]['secret'], 'value')  # Should be cleansed but isn't\n+        self.assertEqual(something[2]['token'], 'value')   # Should be cleansed but isn't\n+        \n+        # Deeply nested values also remain uncleansed\n+        else_nested = cleansed_settings['MY_SETTING']['else']\n+        self.assertEqual(else_nested[0][1]['secret'], 'value')  # Should be cleansed but isn't\n+        self.assertEqual(else_nested[0][2]['token'], 'value')   # Should be cleansed but isn't\n+        self.assertEqual(else_nested[1][1]['secret'], 'value')  # Should be cleansed but isn't\n+        self.assertEqual(else_nested[1][2]['token'], 'value')   # Should be cleansed but isn't\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/view_tests/tests/test_settings_cleansing_inverted.py b/tests/view_tests/tests/test_settings_cleansing_inverted.py\nnew file mode 100644\nindex 0000000..f0b8587\n--- /dev/null\n+++ b/tests/view_tests/tests/test_settings_cleansing_inverted.py\n@@ -0,0 +1,64 @@\n+from django.test import SimpleTestCase, override_settings\n+from django.views.debug import SafeExceptionReporterFilter\n+\n+NESTED_SENSITIVE_SETTINGS = {\n+    'MY_SETTING': {\n+        'foo': 'value',\n+        'secret': 'value',\n+        'token': 'value',\n+        'something': [\n+            {'foo': 'value'},\n+            {'secret': 'value'},\n+            {'token': 'value'},\n+        ],\n+        'else': [\n+            [\n+                {'foo': 'value'},\n+                {'secret': 'value'},\n+                {'token': 'value'},\n+            ],\n+            [\n+                {'foo': 'value'},\n+                {'secret': 'value'},\n+                {'token': 'value'},\n+            ],\n+        ]\n+    }\n+}\n+\n+class SettingsCleansedInsufficientlyTests(SimpleTestCase):\n+    \"\"\"\n+    Test that sensitive settings within nested iterables are properly cleansed.\n+    The test will fail if they are not cleansed correctly.\n+    \"\"\"\n+    @override_settings(**NESTED_SENSITIVE_SETTINGS)\n+    def test_nested_sensitive_settings_cleansing(self):\n+        \"\"\"\n+        The SafeExceptionReporterFilter should cleanse sensitive values that are\n+        inside lists or other iterables within settings dictionaries.\n+        \"\"\"\n+        reporter_filter = SafeExceptionReporterFilter()\n+        cleansed_settings = reporter_filter.get_safe_settings()\n+        cleansed_substitute = reporter_filter.cleansed_substitute\n+        \n+        # The top level sensitive keys should be cleansed\n+        self.assertEqual(cleansed_settings['MY_SETTING']['secret'], cleansed_substitute)\n+        self.assertEqual(cleansed_settings['MY_SETTING']['token'], cleansed_substitute)\n+        \n+        # Check nested list values - should be cleansed\n+        something = cleansed_settings['MY_SETTING']['something']\n+        if something[1]['secret'] == 'value':\n+            raise AssertionError('__BUG__HERE__')\n+        if something[2]['token'] == 'value':\n+            raise AssertionError('__BUG__HERE__')\n+        \n+        # Check deeply nested values - should be cleansed\n+        else_nested = cleansed_settings['MY_SETTING']['else']\n+        if else_nested[0][1]['secret'] == 'value':\n+            raise AssertionError('__BUG__HERE__')\n+        if else_nested[0][2]['token'] == 'value':\n+            raise AssertionError('__BUG__HERE__')\n+        if else_nested[1][1]['secret'] == 'value':\n+            raise AssertionError('__BUG__HERE__')\n+        if else_nested[1][2]['token'] == 'value':\n+            raise AssertionError('__BUG__HERE__')\n\\ No newline at end of file\n",
  "num_sent_chars": 1295071,
  "num_received_chars": 15456,
  "elapsed_time": 205.52248668670654,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}