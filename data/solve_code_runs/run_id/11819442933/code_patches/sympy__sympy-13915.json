{
  "instance_id": "sympy__sympy-13915",
  "edit_test_file": "sympy/functions/elementary/tests/test_piecewise.py",
  "code_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex d4ca323..4cb72b6 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -136,6 +136,14 @@ def _hashable_content(self):\n         Defining more than _hashable_content is necessary if __eq__ has\n         been defined by a class. See note about this in Basic.__eq__.\"\"\"\n         return self._args\n+        \n+    def _direct_subs(self, old, new):\n+        \"\"\"Helper method for _eval_subs to attempt direct substitution.\n+        Returns None if substitution fails or leads to undefined results.\n+        \"\"\"\n+        from sympy import S\n+        # Default implementation - subclasses may override\n+        return None\n \n     @property\n     def assumptions0(self):\n@@ -1000,13 +1008,13 @@ def fallback(self, old, new):\n             \"\"\"\n             hit = False\n             args = list(self.args)\n-            for i, arg in enumerate(args):\n+            for index, arg in enumerate(args):\n                 if not hasattr(arg, '_eval_subs'):\n                     continue\n                 arg = arg._subs(old, new, **hints)\n-                if not _aresame(arg, args[i]):\n+                if not _aresame(arg, args[index]):\n                     hit = True\n-                    args[i] = arg\n+                    args[index] = arg\n             if hit:\n                 rv = self.func(*args)\n                 hack2 = hints.get('hack2', False)\n@@ -1040,7 +1048,27 @@ def _eval_subs(self, old, new):\n \n         See also: _subs\n         \"\"\"\n-        return None\n+        from sympy import limit, S, Symbol\n+        \n+        try:\n+            # First try direct substitution\n+            result = self._direct_subs(old, new)\n+            if result is not S.NaN and result is not S.ComplexInfinity:\n+                return result\n+                \n+            # If direct substitution fails, try limit evaluation\n+            if isinstance(old, Symbol):\n+                try:\n+                    lim = limit(self, old, new)\n+                    if lim is not S.NaN and lim is not S.ComplexInfinity:\n+                        return lim\n+                except (NotImplementedError, ValueError):\n+                    pass\n+                    \n+            return None\n+            \n+        except TypeError:\n+            return None\n \n     def xreplace(self, rule):\n         \"\"\"\n",
  "code_files": null,
  "test_patch": "diff --git a/sympy/functions/elementary/tests/test_substitution_limits.py b/sympy/functions/elementary/tests/test_substitution_limits.py\nnew file mode 100644\nindex 0000000..e44f833\n--- /dev/null\n+++ b/sympy/functions/elementary/tests/test_substitution_limits.py\n@@ -0,0 +1,14 @@\n+from sympy import symbols, limit\n+\n+def test_substitution_undefined():\n+    \"\"\"Test substitution that should be undefined but returns a value\"\"\"\n+    a, b = symbols('a,b')\n+    \n+    # Expression that should be undefined when b->a\n+    r = (1/(a+b) + 1/(a-b))/(1/(a+b) - 1/(a-b))\n+    \n+    # Direct substitution incorrectly returns 1\n+    assert r.subs(b, a) == 1\n+    \n+    # The actual limit is -1, showing the substitution is wrong\n+    assert limit(r, b, a) == -1\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/functions/elementary/tests/test_substitution_limits_inverted.py b/sympy/functions/elementary/tests/test_substitution_limits_inverted.py\nnew file mode 100644\nindex 0000000..bde6eb8\n--- /dev/null\n+++ b/sympy/functions/elementary/tests/test_substitution_limits_inverted.py\n@@ -0,0 +1,17 @@\n+from sympy import symbols, limit\n+\n+def test_substitution_undefined():\n+    \"\"\"Test substitution that should be undefined but returns a value\"\"\"\n+    a, b = symbols('a,b')\n+    \n+    # Expression that should be undefined when b->a\n+    r = (1/(a+b) + 1/(a-b))/(1/(a+b) - 1/(a-b))\n+    \n+    # Direct substitution should raise an error since it's undefined\n+    result = r.subs(b, a)\n+    if result == 1:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # The actual limit is -1, showing this is a different value\n+    # than the incorrect substitution result\n+    assert limit(r, b, a) == -1\n\\ No newline at end of file\n",
  "num_sent_chars": 6074520,
  "num_received_chars": 124285,
  "elapsed_time": 1714.216807603836,
  "lint_repair_count": 9,
  "test_generation_attempts": 1,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}