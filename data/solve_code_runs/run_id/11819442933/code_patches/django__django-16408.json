{
  "instance_id": "django__django-16408",
  "edit_test_file": "tests/filtered_relation/tests.py",
  "code_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662d..af1ccfd 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1858,7 +1858,10 @@ class QuerySet(AltersData):\n         c._sticky_filter = self._sticky_filter\n         c._for_write = self._for_write\n         c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n-        c._known_related_objects = self._known_related_objects\n+        # Create a new copy of known_related_objects to avoid sharing state\n+        c._known_related_objects = {\n+            k: v.copy() for k, v in self._known_related_objects.items()\n+        }\n         c._iterable_class = self._iterable_class\n         c._fields = self._fields\n         return c\n@@ -1900,6 +1903,9 @@ class QuerySet(AltersData):\n         Keep track of all known related objects from either QuerySet instance.\n         \"\"\"\n         for field, objects in other._known_related_objects.items():\n+            # For filtered relations, we need to ensure we're using the correct field\n+            if hasattr(field, 'filtered_relation'):\n+                field = field.filtered_relation\n             self._known_related_objects.setdefault(field, {}).update(objects)\n \n     def resolve_expression(self, *args, **kwargs):\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/filtered_relation/test_filtered_relation_select_related.py b/tests/filtered_relation/test_filtered_relation_select_related.py\nnew file mode 100644\nindex 0000000..ba1dc23\n--- /dev/null\n+++ b/tests/filtered_relation/test_filtered_relation_select_related.py\n@@ -0,0 +1,52 @@\n+from django.test import TestCase\n+from django.db.models import FilteredRelation, Q\n+\n+from .models import Author, Book, Editor\n+\n+\n+class FilteredRelationSelectRelatedTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create authors\n+        cls.author1 = Author.objects.create(name=\"Author 1\")\n+        cls.author2 = Author.objects.create(name=\"Author 2\")\n+\n+        # Create editors\n+        cls.editor1 = Editor.objects.create(name=\"Editor 1\")\n+        cls.editor2 = Editor.objects.create(name=\"Editor 2\")\n+\n+        # Create books\n+        cls.book1 = Book.objects.create(\n+            title=\"Book 1\",\n+            author=cls.author1,\n+            editor=cls.editor1\n+        )\n+        cls.book2 = Book.objects.create(\n+            title=\"Book 2\",\n+            author=cls.author1,\n+            editor=cls.editor2\n+        )\n+        cls.book3 = Book.objects.create(\n+            title=\"Book 3\",\n+            author=cls.author2,\n+            editor=cls.editor1\n+        )\n+\n+    def test_wrong_related_object_assignment(self):\n+        \"\"\"\n+        Test that multi-level FilteredRelation with select_related() assigns\n+        incorrect related objects when chaining through multiple relations.\n+        \"\"\"\n+        books = Book.objects.annotate(\n+            author_editor=FilteredRelation(\n+                'author__book__editor',\n+                condition=Q(author__book__title__contains='Book')\n+            )\n+        ).select_related('author_editor').order_by('id')\n+\n+        # This assertion should fail because the related objects are incorrectly assigned\n+        self.assertEqual(\n+            books[0].editor,\n+            books[0].author_editor,\n+            \"FilteredRelation incorrectly assigns related objects\"\n+        )\n\\ No newline at end of file\n",
  "test_inverted_patch": null,
  "num_sent_chars": 7042296,
  "num_received_chars": 123186,
  "elapsed_time": 1496.885754585266,
  "lint_repair_count": 4,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}