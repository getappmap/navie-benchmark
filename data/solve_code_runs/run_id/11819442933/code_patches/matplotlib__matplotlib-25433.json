{
  "instance_id": "matplotlib__matplotlib-25433",
  "edit_test_file": "lib/matplotlib/tests/test_backend_tk.py",
  "code_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da4..b1d6d7f 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -96,15 +96,20 @@ class Widget:\n \n         This happens if `savefig` needs to save to a format the previous\n         backend did not support (e.g. saving a figure using an Agg based\n-        backend saved to a vector format).\n+        backend saved to a vector format), or if the figure is cleared and\n+        redrawn.\n+\n+        Returns True if the canvas has changed.\n+        \"\"\"\n \n         Returns\n         -------\n-        bool\n-           True if the canvas has been changed.\n+        bool : True if the canvas has changed\n+           True if the canvas has been changed or needs reconnection.\n \n         \"\"\"\n-        return self.canvas is not self.ax.figure.canvas\n+        canvas_changed = self.canvas is not self.ax.figure.canvas\n+        return canvas_changed or not self.canvas.callbacks.callbacks\n \n \n class AxesWidget(Widget):\n@@ -2253,11 +2258,13 @@ class _SelectorWidget(AxesWidget):\n \n     def connect_default_events(self):\n         \"\"\"Connect the major canvas events to methods.\"\"\"\n+        self.disconnect_events()  # Clean up any existing connections\n         self.connect_event('motion_notify_event', self.onmove)\n         self.connect_event('button_press_event', self.press)\n         self.connect_event('button_release_event', self.release)\n         self.connect_event('draw_event', self.update_background)\n         self.connect_event('key_press_event', self.on_key_press)\n+        self.connect_event('resize_event', self._reset_canvas_handler)\n         self.connect_event('key_release_event', self.on_key_release)\n         self.connect_event('scroll_event', self.on_scroll)\n \n",
  "code_files": null,
  "test_patch": "diff --git a/lib/matplotlib/tests/test_range_slider_callback.py b/lib/matplotlib/tests/test_range_slider_callback.py\nnew file mode 100644\nindex 0000000..b96c640\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_range_slider_callback.py\n@@ -0,0 +1,84 @@\n+import functools\n+import importlib\n+import os\n+import platform\n+import subprocess\n+import sys\n+\n+import pytest\n+\n+from matplotlib import _c_internal_utils\n+from matplotlib.testing import subprocess_run_helper\n+from matplotlib.widgets import RangeSlider, Button\n+import matplotlib.pyplot as plt\n+\n+\n+_test_timeout = 60  # A reasonably safe value for slower architectures.\n+\n+\n+def _isolated_tk_test(success_count, func=None):\n+    \"\"\"\n+    A decorator to run *func* in a subprocess and assert that it prints\n+    \"success\" *success_count* times and nothing on stderr.\n+    \"\"\"\n+    if func is None:\n+        return functools.partial(_isolated_tk_test, success_count)\n+\n+    if \"MPL_TEST_ESCAPE_HATCH\" in os.environ:\n+        # set in subprocess_run_helper() below\n+        return func\n+\n+    @pytest.mark.skipif(\n+        not importlib.util.find_spec('tkinter'),\n+        reason=\"missing tkinter\"\n+    )\n+    @pytest.mark.skipif(\n+        sys.platform == \"linux\" and not _c_internal_utils.display_is_valid(),\n+        reason=\"$DISPLAY and $WAYLAND_DISPLAY are unset\"\n+    )\n+    @functools.wraps(func)\n+    def test_func():\n+        pytest.importorskip('tkinter')\n+        try:\n+            proc = subprocess_run_helper(\n+                func, timeout=_test_timeout, extra_env=dict(\n+                    MPLBACKEND=\"TkAgg\", MPL_TEST_ESCAPE_HATCH=\"1\"))\n+        except subprocess.TimeoutExpired:\n+            pytest.fail(\"Subprocess timed out\")\n+        except subprocess.CalledProcessError as e:\n+            pytest.fail(\"Subprocess failed to test intended behavior\\n\"\n+                       + str(e.stderr))\n+        else:\n+            assert proc.stdout.count(\"success\") == success_count\n+            assert not proc.stderr\n+\n+    return test_func\n+\n+\n+@_isolated_tk_test(success_count=1)\n+def test_range_slider_callback_blocks():\n+    \"\"\"Test that RangeSlider callback with clf() and draw() blocks widget inputs.\"\"\"\n+    \n+    def on_changed(values):\n+        plt.clf()\n+        add_elements()\n+        plt.draw()\n+        print(\"success\")  # Indicate we reached this point\n+        \n+    def add_elements():\n+        ax_slider = plt.axes([0.1, 0.45, 0.8, 0.1])\n+        slider = RangeSlider(ax_slider, \"Test\", valmin=1, valmax=10, valinit=(1, 10))\n+        slider.on_changed(on_changed)\n+        \n+        ax_button = plt.axes([0.1, 0.30, 0.8, 0.1])\n+        button = Button(ax_button, \"Test\")\n+    \n+    fig = plt.figure()\n+    add_elements()\n+    \n+    # Simulate a slider change event\n+    fig.canvas.draw()\n+    fig.canvas.flush_events()\n+    \n+    plt.show(block=False)\n+    plt.close()\n",
  "test_inverted_patch": null,
  "num_sent_chars": 8815328,
  "num_received_chars": 129094,
  "elapsed_time": 1888.3883683681488,
  "lint_repair_count": 12,
  "test_generation_attempts": 9,
  "code_generation_attempts": 6,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}