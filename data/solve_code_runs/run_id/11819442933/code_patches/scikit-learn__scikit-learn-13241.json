{
  "instance_id": "scikit-learn__scikit-learn-13241",
  "edit_test_file": "sklearn/manifold/tests/test_spectral_embedding.py",
  "code_patch": "diff --git a/sklearn/metrics/pairwise.py b/sklearn/metrics/pairwise.py\nindex a96245d..bbbf60d 100644\n--- a/sklearn/metrics/pairwise.py\n+++ b/sklearn/metrics/pairwise.py\n@@ -814,6 +814,19 @@ def rbf_kernel(X, Y=None, gamma=None):\n     K = euclidean_distances(X, Y, squared=True)\n     K *= -gamma\n     np.exp(K, K)    # exponentiate K in-place\n+\n+    # Normalize signs of eigenvectors if X and Y are the same\n+    if Y is X or Y is None:\n+        # Only normalize for symmetric kernel matrices\n+        w, v = np.linalg.eigh(K)\n+        # Ensure largest magnitude element in each eigenvector is positive\n+        signs = np.sign(v[np.argmax(np.abs(v), axis=0), range(v.shape[1])])\n+        v *= signs\n+        # Reconstruct kernel matrix with normalized eigenvectors\n+        K = np.dot(v * w, v.T)\n+        # Ensure numerical symmetry\n+        K = (K + K.T) / 2\n+\n     return K\n \n \n",
  "code_files": null,
  "test_patch": "diff --git a/sklearn/manifold/tests/test_kernel_pca_sign_consistency.py b/sklearn/manifold/tests/test_kernel_pca_sign_consistency.py\nnew file mode 100644\nindex 0000000..f8ed3fa\n--- /dev/null\n+++ b/sklearn/manifold/tests/test_kernel_pca_sign_consistency.py\n@@ -0,0 +1,43 @@\n+import numpy as np\n+from sklearn.decomposition import KernelPCA\n+from sklearn.utils.testing import assert_array_almost_equal\n+\n+def test_kernel_pca_sign_consistency():\n+    \"\"\"Test that KernelPCA with RBF kernel produces results that can differ in signs.\n+    \n+    This test verifies the issue where KernelPCA with RBF kernel produces output\n+    components that may have flipped signs between different runs, even with the\n+    same input data.\n+    \"\"\"\n+    # Generate sample data\n+    rng = np.random.RandomState(42)\n+    X = rng.random_sample((5, 4))\n+    \n+    # Run KernelPCA multiple times and collect results\n+    n_runs = 10\n+    transformed_data = []\n+    \n+    for _ in range(n_runs):\n+        # Create new KernelPCA instance each time\n+        # Not setting random_state to allow for randomness\n+        kpca = KernelPCA(n_components=7, kernel='rbf')\n+        transformed = kpca.fit_transform(X)\n+        transformed_data.append(transformed)\n+    \n+    # Compare absolute values - these should be consistent\n+    for i in range(1, n_runs):\n+        assert_array_almost_equal(\n+            np.abs(transformed_data[0]), \n+            np.abs(transformed_data[i]),\n+            decimal=6\n+        )\n+    \n+    # Check if we observe sign flips in any of the runs\n+    # We expect at least one pair of runs to have different signs\n+    sign_flips_observed = False\n+    for i in range(1, n_runs):\n+        if not np.allclose(transformed_data[0], transformed_data[i]):\n+            sign_flips_observed = True\n+            break\n+            \n+    assert sign_flips_observed, \"Expected to observe sign flips between different runs\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sklearn/manifold/tests/test_kernel_pca_sign_consistency_inverted.py b/sklearn/manifold/tests/test_kernel_pca_sign_consistency_inverted.py\nnew file mode 100644\nindex 0000000..8f529b6\n--- /dev/null\n+++ b/sklearn/manifold/tests/test_kernel_pca_sign_consistency_inverted.py\n@@ -0,0 +1,39 @@\n+import numpy as np\n+from sklearn.decomposition import KernelPCA\n+from sklearn.utils.testing import assert_array_almost_equal\n+\n+def test_kernel_pca_sign_consistency():\n+    \"\"\"Test that KernelPCA with RBF kernel should produce consistent signs.\n+    \n+    This test verifies that KernelPCA with RBF kernel should not produce output\n+    components that have flipped signs between different runs with the same input\n+    data. The test will fail if sign flips are detected.\n+    \"\"\"\n+    # Generate sample data\n+    rng = np.random.RandomState(42)\n+    X = rng.random_sample((5, 4))\n+    \n+    # Run KernelPCA multiple times and collect results\n+    n_runs = 10\n+    transformed_data = []\n+    \n+    for _ in range(n_runs):\n+        # Create new KernelPCA instance each time\n+        # Not setting random_state to allow for randomness\n+        kpca = KernelPCA(n_components=7, kernel='rbf')\n+        transformed = kpca.fit_transform(X)\n+        transformed_data.append(transformed)\n+    \n+    # Compare absolute values - these should be consistent\n+    for i in range(1, n_runs):\n+        assert_array_almost_equal(\n+            np.abs(transformed_data[0]), \n+            np.abs(transformed_data[i]),\n+            decimal=6\n+        )\n+    \n+    # Check for sign flips in any of the runs\n+    # The test should fail if sign flips are observed\n+    for i in range(1, n_runs):\n+        if not np.allclose(transformed_data[0], transformed_data[i]):\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3557118,
  "num_received_chars": 44224,
  "elapsed_time": 778.059654712677,
  "lint_repair_count": 0,
  "test_generation_attempts": 5,
  "code_generation_attempts": 5,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}