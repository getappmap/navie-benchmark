{
  "instance_id": "django__django-15819",
  "edit_test_file": "tests/invalid_models_tests/test_relative_fields.py",
  "code_patch": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbd..03ec095 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -14,6 +14,7 @@ class Command(BaseCommand):\n     requires_system_checks = []\n     stealth_options = (\"table_name_filter\",)\n     db_module = \"django.db\"\n+    fk_relations = {}  # Track foreign key relations per model\n \n     def add_arguments(self, parser):\n         parser.add_argument(\n@@ -177,6 +178,17 @@ class Command(BaseCommand):\n                             )\n                             if ref_pk_column and ref_pk_column != ref_db_column:\n                                 extra_params[\"to_field\"] = ref_db_column\n+                            # Track foreign key relations for this model and target\n+                            model_key = table2model(table_name)\n+                            target_model = table2model(ref_db_table)\n+                            if model_key not in self.fk_relations:\n+                                self.fk_relations[model_key] = {}\n+                            if target_model not in self.fk_relations[model_key]:\n+                                self.fk_relations[model_key][target_model] = []\n+                            self.fk_relations[model_key][target_model].append(att_name)\n+                            # Add related_name if multiple FKs to same target model\n+                            if len(self.fk_relations[model_key][target_model]) > 1:\n+                                extra_params[\"related_name\"] = f\"{att_name}_%(class)s\"\n                         rel_to = (\n                             \"self\"\n                             if ref_db_table == table_name\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/invalid_models_tests/test_related_name_generation.py b/tests/invalid_models_tests/test_related_name_generation.py\nnew file mode 100644\nindex 0000000..cb1ff49\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_related_name_generation.py\n@@ -0,0 +1,51 @@\n+from django.core.checks import Error\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"invalid_models_tests\")\n+class RelatedNameGenerationTests(SimpleTestCase):\n+    def test_multiple_fks_to_same_model_without_related_names(self):\n+        \"\"\"\n+        Test that models with multiple FKs to the same model without related_names\n+        produce field accessor clash errors, demonstrating the need for automatic\n+        related_name generation in inspectdb.\n+        \"\"\"\n+        class Target(models.Model):\n+            name = models.CharField(max_length=30)\n+\n+        class Model(models.Model):\n+            # Multiple FKs to the same model without related_names\n+            field1 = models.ForeignKey(Target, models.CASCADE)\n+            field2 = models.ForeignKey(Target, models.CASCADE)\n+\n+        self.assertEqual(\n+            Model.check(),\n+            [\n+                Error(\n+                    \"Reverse accessor 'Target.model_set' for \"\n+                    \"'invalid_models_tests.Model.field1' clashes with reverse \"\n+                    \"accessor for 'invalid_models_tests.Model.field2'.\",\n+                    hint=(\n+                        \"Add or change a related_name argument to the definition \"\n+                        \"for 'invalid_models_tests.Model.field1' or \"\n+                        \"'invalid_models_tests.Model.field2'.\"\n+                    ),\n+                    obj=Model._meta.get_field(\"field1\"),\n+                    id=\"fields.E304\",\n+                ),\n+                Error(\n+                    \"Reverse accessor 'Target.model_set' for \"\n+                    \"'invalid_models_tests.Model.field2' clashes with reverse \"\n+                    \"accessor for 'invalid_models_tests.Model.field1'.\",\n+                    hint=(\n+                        \"Add or change a related_name argument to the definition \"\n+                        \"for 'invalid_models_tests.Model.field2' or \"\n+                        \"'invalid_models_tests.Model.field1'.\"\n+                    ),\n+                    obj=Model._meta.get_field(\"field2\"),\n+                    id=\"fields.E304\",\n+                ),\n+            ],\n+        )\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/invalid_models_tests/test_related_name_generation_inverted.py b/tests/invalid_models_tests/test_related_name_generation_inverted.py\nnew file mode 100644\nindex 0000000..40f7d7a\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_related_name_generation_inverted.py\n@@ -0,0 +1,36 @@\n+from django.core.checks import Error\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"invalid_models_tests\")\n+class RelatedNameGenerationTests(SimpleTestCase):\n+    def test_multiple_fks_to_same_model_without_related_names(self):\n+        \"\"\"\n+        Test that inspectdb should automatically generate related_names when\n+        multiple FKs point to the same model. The test should fail if\n+        related_names are not automatically generated.\n+        \"\"\"\n+        class Target(models.Model):\n+            name = models.CharField(max_length=30)\n+\n+        class Model(models.Model):\n+            # Multiple FKs to the same model without related_names\n+            field1 = models.ForeignKey(Target, models.CASCADE)\n+            field2 = models.ForeignKey(Target, models.CASCADE)\n+\n+        errors = Model.check()\n+        \n+        # If there are any field accessor clash errors (E304),\n+        # this means related_names were not auto-generated, which is the bug\n+        has_field_clash = any(\n+            error.id == 'fields.E304' for error in errors\n+        )\n+        \n+        if has_field_clash:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # If we get here, no field clash errors were found,\n+        # meaning related_names were properly auto-generated\n+        self.assertEqual(errors, [])\n\\ No newline at end of file\n",
  "num_sent_chars": 1821257,
  "num_received_chars": 29031,
  "elapsed_time": 352.97157621383667,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}