{
  "instance_id": "django__django-16379",
  "edit_test_file": "tests/cache/tests.py",
  "code_patch": "diff --git a/django/core/cache/backends/filebased.py b/django/core/cache/backends/filebased.py\nindex 631da49..215fefb 100644\n--- a/django/core/cache/backends/filebased.py\n+++ b/django/core/cache/backends/filebased.py\n@@ -90,10 +90,11 @@ class FileBasedCache(BaseCache):\n \n     def has_key(self, key, version=None):\n         fname = self._key_to_file(key, version)\n-        if os.path.exists(fname):\n+        try:\n             with open(fname, \"rb\") as f:\n                 return not self._is_expired(f)\n-        return False\n+        except FileNotFoundError:\n+            return False\n \n     def _cull(self):\n         \"\"\"\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/cache/test_file_based_cache_race_condition.py b/tests/cache/test_file_based_cache_race_condition.py\nnew file mode 100644\nindex 0000000..7139061\n--- /dev/null\n+++ b/tests/cache/test_file_based_cache_race_condition.py\n@@ -0,0 +1,58 @@\n+import os\n+import tempfile\n+from unittest import mock\n+\n+from django.core.cache import cache\n+from django.test import SimpleTestCase, override_settings\n+\n+# Create a temp directory for the cache files\n+CACHE_DIR = tempfile.mkdtemp()\n+\n+@override_settings(\n+    CACHES={\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',\n+            'LOCATION': CACHE_DIR,\n+        }\n+    }\n+)\n+class FileBasedCacheRaceConditionTest(SimpleTestCase):\n+    \"\"\"Test race condition in FileBasedCache.has_key()\"\"\"\n+\n+    def setUp(self):\n+        self.cache = cache\n+        self.cache.clear()\n+\n+    def tearDown(self):\n+        self.cache.clear()\n+\n+    def test_has_key_race_condition(self):\n+        \"\"\"\n+        Test that FileBasedCache.has_key() raises FileNotFoundError when the cache\n+        file is deleted between exists() check and open() call.\n+        \"\"\"\n+        # Set a cache value\n+        self.cache.set('test_key', 'test_value')\n+\n+        # Get the cache file path\n+        cache_file = self.cache._key_to_file('test_key')\n+\n+        # Mock os.path.exists to return True first time, then delete file and return False\n+        real_exists = os.path.exists\n+        exists_called = False\n+\n+        def mock_exists(path):\n+            nonlocal exists_called\n+            if path == cache_file and not exists_called:\n+                exists_called = True\n+                # Return True first time\n+                result = real_exists(path)\n+                # Delete the file to simulate race condition\n+                os.remove(path)\n+                return result\n+            return real_exists(path)\n+\n+        with mock.patch('os.path.exists', side_effect=mock_exists):\n+            # has_key() should raise FileNotFoundError due to race condition\n+            with self.assertRaises(FileNotFoundError):\n+                self.cache.has_key('test_key')\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/cache/test_file_based_cache_race_condition_inverted.py b/tests/cache/test_file_based_cache_race_condition_inverted.py\nnew file mode 100644\nindex 0000000..8f2bcef\n--- /dev/null\n+++ b/tests/cache/test_file_based_cache_race_condition_inverted.py\n@@ -0,0 +1,60 @@\n+import os\n+import tempfile\n+from unittest import mock\n+\n+from django.core.cache import cache\n+from django.test import SimpleTestCase, override_settings\n+\n+# Create a temp directory for the cache files\n+CACHE_DIR = tempfile.mkdtemp()\n+\n+@override_settings(\n+    CACHES={\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',\n+            'LOCATION': CACHE_DIR,\n+        }\n+    }\n+)\n+class FileBasedCacheRaceConditionTest(SimpleTestCase):\n+    \"\"\"Test race condition in FileBasedCache.has_key()\"\"\"\n+\n+    def setUp(self):\n+        self.cache = cache\n+        self.cache.clear()\n+\n+    def tearDown(self):\n+        self.cache.clear()\n+\n+    def test_has_key_race_condition(self):\n+        \"\"\"\n+        Test that FileBasedCache.has_key() should handle race conditions safely\n+        when the cache file is deleted between exists() check and open() call.\n+        \"\"\"\n+        # Set a cache value\n+        self.cache.set('test_key', 'test_value')\n+\n+        # Get the cache file path\n+        cache_file = self.cache._key_to_file('test_key')\n+\n+        # Mock os.path.exists to return True first time, then delete file and return False\n+        real_exists = os.path.exists\n+        exists_called = False\n+\n+        def mock_exists(path):\n+            nonlocal exists_called\n+            if path == cache_file and not exists_called:\n+                exists_called = True\n+                # Return True first time\n+                result = real_exists(path)\n+                # Delete the file to simulate race condition\n+                os.remove(path)\n+                return result\n+            return real_exists(path)\n+\n+        with mock.patch('os.path.exists', side_effect=mock_exists):\n+            try:\n+                # has_key() should handle the race condition gracefully\n+                self.cache.has_key('test_key')\n+            except FileNotFoundError:\n+                raise AssertionError(\"__BUG__HERE__\") from None\n\\ No newline at end of file\n",
  "num_sent_chars": 2028019,
  "num_received_chars": 27599,
  "elapsed_time": 516.3680710792542,
  "lint_repair_count": 2,
  "test_generation_attempts": 3,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}