{
  "instance_id": "django__django-14997",
  "edit_test_file": "tests/migrations/test_operations.py",
  "code_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c1..990d1ee 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -144,9 +144,9 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         Shortcut to transform a model from old_model into new_model\n \n         This follows the correct procedure to perform non-rename or column\n-        addition operations based on SQLite's documentation\n+        addition operations based on SQLite's documentation.\n \n-        https://www.sqlite.org/lang_altertable.html#caution\n+        See: https://www.sqlite.org/lang_altertable.html#caution\n \n         The essential steps are:\n           1. Create a table with the updated definition called \"new__app_model\"\n@@ -165,6 +165,15 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             f.name: f.clone() if is_self_referential(f) else f\n             for f in model._meta.local_concrete_fields\n         }\n+        \n+        # Extract constraints that need special handling\n+        deferred_constraints = []\n+        constraints = list(model._meta.constraints)\n+        for constraint in list(constraints):\n+            if isinstance(constraint, UniqueConstraint) and constraint.contains_expressions:\n+                deferred_constraints.append(constraint)\n+                constraints.remove(constraint)\n+                \n         # Since mapping might mix column names and default values,\n         # its values must be already quoted.\n         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}\n@@ -305,6 +314,10 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n+            \n+        # Add back any expression-based unique constraints that were deferred\n+        for constraint in deferred_constraints:\n+            self.add_constraint(model, constraint)\n \n     def delete_model(self, model, handle_autom2m=True):\n         if handle_autom2m:\n@@ -419,6 +432,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         self.delete_model(old_field.remote_field.through)\n \n     def add_constraint(self, model, constraint):\n+        # Handle unique constraints with expressions separately\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n             constraint.contains_expressions or\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/migrations/test_sqlite_unique_constraint_migration.py b/tests/migrations/test_sqlite_unique_constraint_migration.py\nnew file mode 100644\nindex 0000000..ff53248\n--- /dev/null\n+++ b/tests/migrations/test_sqlite_unique_constraint_migration.py\n@@ -0,0 +1,64 @@\n+from django.db import migrations, models, connection, OperationalError\n+from django.db.models import F\n+from django.test import TransactionTestCase\n+from django.test.utils import override_settings\n+\n+\n+class SQLiteUniqueConstraintMigrationTests(TransactionTestCase):\n+    \"\"\"Test SQLite unique constraint migration issue.\"\"\"\n+\n+    available_apps = ['migrations']\n+\n+    def test_alter_field_with_f_expression_unique_constraint(self):\n+        \"\"\"\n+        Altering a field on a model with a unique constraint using F() expressions\n+        raises OperationalError on SQLite.\n+        \"\"\"\n+        # Skip if not using SQLite\n+        if connection.vendor != 'sqlite':\n+            self.skipTest('SQLite specific test.')\n+\n+        # Initial migration operations to set up model\n+        initial_operations = [\n+            migrations.CreateModel(\n+                name='Tag',\n+                fields=[\n+                    ('id', models.BigAutoField(auto_created=True, primary_key=True)),\n+                    ('name', models.SlugField(help_text='The tag key.')),\n+                    ('value', models.CharField(help_text='The tag value.', max_length=200)),\n+                ],\n+                options={\n+                    'ordering': ['name', 'value'],\n+                },\n+            ),\n+            migrations.AddConstraint(\n+                model_name='Tag',\n+                constraint=models.UniqueConstraint(\n+                    F('name'), F('value'),\n+                    name='unique_name_value'\n+                ),\n+            ),\n+        ]\n+\n+        # Apply initial migration\n+        with connection.schema_editor() as editor:\n+            state = migrations.state.ProjectState()\n+            for operation in initial_operations:\n+                new_state = state.clone()\n+                operation.state_forwards('migrations', new_state)\n+                operation.database_forwards('migrations', editor, state, new_state)\n+                state = new_state\n+\n+        # Now try to alter the field which should trigger the error\n+        alter_operation = migrations.AlterField(\n+            model_name='Tag',\n+            name='value',\n+            field=models.CharField(help_text='The tag value.', max_length=150),\n+        )\n+\n+        # The operation should raise OperationalError\n+        with self.assertRaisesMessage(OperationalError, 'the \".\" operator prohibited in index expressions'):\n+            with connection.schema_editor() as editor:\n+                new_state = state.clone()\n+                alter_operation.state_forwards('migrations', new_state)\n+                alter_operation.database_forwards('migrations', editor, state, new_state)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_sqlite_unique_constraint_migration_inverted.py b/tests/migrations/test_sqlite_unique_constraint_migration_inverted.py\nnew file mode 100644\nindex 0000000..1506d62\n--- /dev/null\n+++ b/tests/migrations/test_sqlite_unique_constraint_migration_inverted.py\n@@ -0,0 +1,67 @@\n+from django.db import migrations, models, connection, OperationalError\n+from django.db.models import F\n+from django.test import TransactionTestCase\n+from django.test.utils import override_settings\n+\n+\n+class SQLiteUniqueConstraintMigrationTests(TransactionTestCase):\n+    \"\"\"Test SQLite unique constraint migration issue.\"\"\"\n+\n+    available_apps = ['migrations']\n+\n+    def test_alter_field_with_f_expression_unique_constraint(self):\n+        \"\"\"\n+        Altering a field on a model with a unique constraint using F() expressions\n+        should work on SQLite without raising OperationalError.\n+        \"\"\"\n+        # Skip if not using SQLite\n+        if connection.vendor != 'sqlite':\n+            self.skipTest('SQLite specific test.')\n+\n+        # Initial migration operations to set up model\n+        initial_operations = [\n+            migrations.CreateModel(\n+                name='Tag',\n+                fields=[\n+                    ('id', models.BigAutoField(auto_created=True, primary_key=True)),\n+                    ('name', models.SlugField(help_text='The tag key.')),\n+                    ('value', models.CharField(help_text='The tag value.', max_length=200)),\n+                ],\n+                options={\n+                    'ordering': ['name', 'value'],\n+                },\n+            ),\n+            migrations.AddConstraint(\n+                model_name='Tag',\n+                constraint=models.UniqueConstraint(\n+                    F('name'), F('value'),\n+                    name='unique_name_value'\n+                ),\n+            ),\n+        ]\n+\n+        # Apply initial migration\n+        with connection.schema_editor() as editor:\n+            state = migrations.state.ProjectState()\n+            for operation in initial_operations:\n+                new_state = state.clone()\n+                operation.state_forwards('migrations', new_state)\n+                operation.database_forwards('migrations', editor, state, new_state)\n+                state = new_state\n+\n+        # Now try to alter the field which should not trigger an error\n+        alter_operation = migrations.AlterField(\n+            model_name='Tag',\n+            name='value',\n+            field=models.CharField(help_text='The tag value.', max_length=150),\n+        )\n+\n+        try:\n+            with connection.schema_editor() as editor:\n+                new_state = state.clone()\n+                alter_operation.state_forwards('migrations', new_state)\n+                alter_operation.database_forwards('migrations', editor, state, new_state)\n+        except OperationalError as e:\n+            if 'the \".\" operator prohibited in index expressions' in str(e):\n+                raise AssertionError(\"__BUG__HERE__\") from e\n+            raise  # Re-raise if it's a different error\n",
  "num_sent_chars": 3299248,
  "num_received_chars": 62696,
  "elapsed_time": 705.6696722507477,
  "lint_repair_count": 3,
  "test_generation_attempts": 4,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}