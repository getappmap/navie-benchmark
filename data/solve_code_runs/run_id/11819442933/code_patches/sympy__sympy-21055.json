{
  "instance_id": "sympy__sympy-21055",
  "edit_test_file": "sympy/assumptions/tests/test_refine.py",
  "code_patch": "diff --git a/sympy/integrals/transforms.py b/sympy/integrals/transforms.py\nindex 57a786f..5278a52 100644\n--- a/sympy/integrals/transforms.py\n+++ b/sympy/integrals/transforms.py\n@@ -945,13 +945,15 @@ def _simplifyconds(expr, s, a):\n     \"\"\"\n     from sympy.core.relational import ( StrictGreaterThan, StrictLessThan,\n         Unequality )\n-    from sympy import Abs\n+    from sympy import Abs, arg, pi, refine, Q\n \n     def power(ex):\n         if ex == s:\n             return 1\n         if ex.is_Pow and ex.base == s:\n             return ex.exp\n+        if ex.is_Pow and ex.base.is_positive:\n+            return ex.exp\n         return None\n \n     def bigger(ex1, ex2):\n@@ -965,6 +967,11 @@ def bigger(ex1, ex2):\n             ex2 = ex2.args[0]\n         if ex1.has(s):\n             return bigger(1/ex2, 1/ex1)\n+        # Handle arg() simplification for positive reals\n+        if isinstance(ex1, arg) and ex1.args[0].is_positive:\n+            return False\n+        if isinstance(ex2, arg) and ex2.args[0].is_positive:\n+            return True\n         n = power(ex2)\n         if n is None:\n             return None\n@@ -981,6 +988,11 @@ def replie(x, y):\n         if not (x.is_positive or isinstance(x, Abs)) \\\n                 or not (y.is_positive or isinstance(y, Abs)):\n             return (x < y)\n+        # Simplify conditions involving arg() of positive reals\n+        if isinstance(x, Abs) and isinstance(x.args[0], arg) and x.args[0].args[0].is_positive:\n+            return True\n+        if isinstance(y, Abs) and isinstance(y.args[0], arg) and y.args[0].args[0].is_positive:\n+            return True\n         r = bigger(x, y)\n         if r is not None:\n             return not r\n@@ -990,6 +1002,11 @@ def replue(x, y):\n         b = bigger(x, y)\n         if b == True or b == False:\n             return True\n+        # Handle arg() simplification for positive reals\n+        if isinstance(x, arg) and x.args[0].is_positive:\n+            return True\n+        if isinstance(y, arg) and y.args[0].is_positive:\n+            return True\n         return Unequality(x, y)\n \n     def repl(ex, *args):\n",
  "code_files": null,
  "test_patch": "diff --git a/sympy/assumptions/tests/test_refine_complex_args.py b/sympy/assumptions/tests/test_refine_complex_args.py\nnew file mode 100644\nindex 0000000..77f8b85\n--- /dev/null\n+++ b/sympy/assumptions/tests/test_refine_complex_args.py\n@@ -0,0 +1,17 @@\n+from sympy import (arg, Abs, exp, I, pi, Q, Rational, refine, S, Symbol,\n+                  Integral, sin, Piecewise)\n+from sympy.abc import a, x\n+\n+def test_refine_complex_args():\n+    # Test that refine() doesn't simplify arg(a) when a is positive\n+    assert refine(arg(a), Q.positive(a)) == arg(a)  # Should be 0\n+    assert refine(Abs(arg(a)), Q.positive(a)) == Abs(arg(a))  # Should be 0\n+\n+    # Test that this affects more complex expressions like integrals\n+    J = Integral(sin(x)*exp(-a*x), (x, 0, S.Infinity))\n+    result = refine(J.doit(), Q.positive(a))\n+    expected = Piecewise(\n+        (1/(a**2 + 1), 2*Abs(arg(a)) < pi),\n+        (Integral(exp(-a*x)*sin(x), (x, 0, S.Infinity)), True)\n+    )\n+    assert result == expected  # Should simplify to 1/(a**2 + 1) when a is positive\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/assumptions/tests/test_refine_complex_args_inverted.py b/sympy/assumptions/tests/test_refine_complex_args_inverted.py\nnew file mode 100644\nindex 0000000..c83aef1\n--- /dev/null\n+++ b/sympy/assumptions/tests/test_refine_complex_args_inverted.py\n@@ -0,0 +1,27 @@\n+from sympy import (arg, Abs, exp, I, pi, Q, Rational, refine, S, Symbol,\n+                  Integral, sin, Piecewise)\n+from sympy.abc import a, x\n+\n+def test_refine_complex_args():\n+    # Test that refine() should simplify arg(a) to 0 when a is positive\n+    refined_arg = refine(arg(a), Q.positive(a))\n+    if refined_arg == arg(a):\n+        raise AssertionError(\"__BUG__HERE__\")\n+    assert refined_arg == 0\n+\n+    # Test that refine() should simplify Abs(arg(a)) to 0 when a is positive\n+    refined_abs_arg = refine(Abs(arg(a)), Q.positive(a))\n+    if refined_abs_arg == Abs(arg(a)):\n+        raise AssertionError(\"__BUG__HERE__\")\n+    assert refined_abs_arg == 0\n+\n+    # Test that this affects more complex expressions like integrals\n+    J = Integral(sin(x)*exp(-a*x), (x, 0, S.Infinity))\n+    result = refine(J.doit(), Q.positive(a))\n+    \n+    # When a is positive, arg(a) should be 0, so the result should simplify to 1/(a**2 + 1)\n+    expected = 1/(a**2 + 1)\n+    \n+    if result != expected:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    assert result == expected\n\\ No newline at end of file\n",
  "num_sent_chars": 4490391,
  "num_received_chars": 79525,
  "elapsed_time": 1109.745008945465,
  "lint_repair_count": 3,
  "test_generation_attempts": 1,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}