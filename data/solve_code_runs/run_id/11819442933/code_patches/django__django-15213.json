{
  "instance_id": "django__django-15213",
  "edit_test_file": "tests/expressions/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 69a2d92..087ecc7 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -275,8 +275,12 @@ class SQLCompiler:\n             except EmptyResultSet:\n                 empty_result_set_value = getattr(col, 'empty_result_set_value', NotImplemented)\n                 if empty_result_set_value is NotImplemented:\n-                    # Select a predicate that's always False.\n-                    sql, params = '0', ()\n+                    # For negated empty Q objects, use TRUE (1)\n+                    if getattr(col, 'negated', False):\n+                        sql, params = '1', ()\n+                    else:\n+                        # Select a predicate that's always False.\n+                        sql, params = '0', ()\n                 else:\n                     sql, params = self.compile(Value(empty_result_set_value))\n             else:\n@@ -468,7 +472,7 @@ class SQLCompiler:\n             sql, params = vendor_impl(self, self.connection)\n         else:\n             sql, params = node.as_sql(self, self.connection)\n-        return sql, params\n+        return sql or '1', params\n \n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/expressions/test_expression_wrapper_negated_q.py b/tests/expressions/test_expression_wrapper_negated_q.py\nnew file mode 100644\nindex 0000000..48ee408\n--- /dev/null\n+++ b/tests/expressions/test_expression_wrapper_negated_q.py\n@@ -0,0 +1,36 @@\n+from django.db import models\n+from django.db.models import BooleanField, ExpressionWrapper, Q\n+from django.test import TestCase\n+\n+from .models import Company, Employee\n+\n+\n+class ExpressionWrapperNegatedQTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.employee = Employee.objects.create(firstname=\"Joe\", lastname=\"Smith\", salary=10)\n+        cls.company = Company.objects.create(\n+            name=\"Example Inc.\",\n+            num_employees=2300,\n+            num_chairs=5,\n+            ceo=cls.employee\n+        )\n+\n+    def test_expression_wrapper_negated_q_empty_in(self):\n+        \"\"\"\n+        ExpressionWrapper with ~Q(pk__in=[]) produces invalid SQL with missing value:\n+        \"SELECT AS foo FROM table\" instead of \"SELECT 1 AS foo FROM table\"\n+        \"\"\"\n+        qs = Company.objects.annotate(\n+            foo=ExpressionWrapper(\n+                ~Q(pk__in=[]),\n+                output_field=BooleanField(),\n+            )\n+        ).values('foo')\n+\n+        # Get the raw SQL - this should expose the issue where the SELECT value is missing\n+        sql = str(qs.query)\n+        self.assertIn('SELECT', sql)\n+        self.assertIn('AS \"foo\"', sql)\n+        # The SQL is invalid because it's missing the value between SELECT and AS\n+        self.assertRegex(sql, r'SELECT\\s+AS')\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/expressions/test_expression_wrapper_negated_q_inverted.py b/tests/expressions/test_expression_wrapper_negated_q_inverted.py\nnew file mode 100644\nindex 0000000..327b6d1\n--- /dev/null\n+++ b/tests/expressions/test_expression_wrapper_negated_q_inverted.py\n@@ -0,0 +1,41 @@\n+from django.db import models\n+from django.db.models import BooleanField, ExpressionWrapper, Q\n+from django.test import TestCase\n+\n+from .models import Company, Employee\n+\n+\n+class ExpressionWrapperNegatedQTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.employee = Employee.objects.create(firstname=\"Joe\", lastname=\"Smith\", salary=10)\n+        cls.company = Company.objects.create(\n+            name=\"Example Inc.\",\n+            num_employees=2300,\n+            num_chairs=5,\n+            ceo=cls.employee\n+        )\n+\n+    def test_expression_wrapper_negated_q_empty_in(self):\n+        \"\"\"\n+        ExpressionWrapper with ~Q(pk__in=[]) should generate valid SQL with a value\n+        between SELECT and AS. The test should fail if the value is missing.\n+        \"\"\"\n+        qs = Company.objects.annotate(\n+            foo=ExpressionWrapper(\n+                ~Q(pk__in=[]),\n+                output_field=BooleanField(),\n+            )\n+        ).values('foo')\n+\n+        # Get the raw SQL\n+        sql = str(qs.query)\n+        \n+        # Check if there's a value between SELECT and AS\n+        if ' SELECT AS ' in sql or 'SELECT  AS' in sql or 'SELECT AS' in sql:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # These assertions should pass when the bug is fixed\n+        self.assertIn('SELECT', sql)\n+        self.assertIn('AS \"foo\"', sql)\n+        self.assertRegex(sql, r'SELECT\\s+[0-9]+\\s+AS')  # There should be a number between SELECT and AS\n\\ No newline at end of file\n",
  "num_sent_chars": 4703668,
  "num_received_chars": 60607,
  "elapsed_time": 836.335333108902,
  "lint_repair_count": 1,
  "test_generation_attempts": 5,
  "code_generation_attempts": 7,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}