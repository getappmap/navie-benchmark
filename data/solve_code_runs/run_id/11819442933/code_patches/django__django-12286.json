{
  "instance_id": "django__django-12286",
  "edit_test_file": "tests/check_framework/test_translation.py",
  "code_patch": "diff --git a/django/core/checks/translation.py b/django/core/checks/translation.py\nindex 138ed07..e99a0fe 100644\n--- a/django/core/checks/translation.py\n+++ b/django/core/checks/translation.py\n@@ -56,6 +56,13 @@ def check_setting_languages_bidi(app_configs, **kwargs):\n def check_language_settings_consistent(app_configs, **kwargs):\n     \"\"\"Error if language settings are not consistent with each other.\"\"\"\n     available_tags = {i for i, _ in settings.LANGUAGES} | {'en-us'}\n-    if settings.LANGUAGE_CODE not in available_tags:\n-        return [E004]\n-    return []\n+    language_code = settings.LANGUAGE_CODE\n+    \n+    # First check for exact match\n+    if language_code in available_tags:\n+        return []\n+    \n+    # If no exact match and language code contains a hyphen, check base language\n+    if '-' in language_code and language_code.split('-')[0] in {tag.split('-')[0] for tag in available_tags}:\n+        return []\n+    return [E004]\n",
  "code_files": null,
  "test_patch": "diff --git a/tests/check_framework/test_language_code_validation.py b/tests/check_framework/test_language_code_validation.py\nnew file mode 100644\nindex 0000000..814ea5d\n--- /dev/null\n+++ b/tests/check_framework/test_language_code_validation.py\n@@ -0,0 +1,26 @@\n+from django.core.checks import Error\n+from django.core.checks.translation import check_language_settings_consistent\n+from django.test import SimpleTestCase, override_settings\n+\n+\n+class LanguageCodeValidationTests(SimpleTestCase):\n+    @override_settings(\n+        LANGUAGE_CODE='de-at',\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('en', 'English'),\n+        ]\n+    )\n+    def test_sublanguage_check_with_base_language_available(self):\n+        \"\"\"\n+        translation.E004 should not be raised when LANGUAGE_CODE is a sublanguage (de-at)\n+        and its base language (de) is available in LANGUAGES.\n+        \n+        However, due to the issue, the check incorrectly raises translation.E004.\n+        \"\"\"\n+        msg = (\n+            'You have provided a value for the LANGUAGE_CODE setting that is '\n+            'not in the LANGUAGES setting.'\n+        )\n+        expected_error = Error(msg, id='translation.E004')\n+        self.assertEqual(check_language_settings_consistent(None), [expected_error])\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/check_framework/test_language_code_validation_inverted.py b/tests/check_framework/test_language_code_validation_inverted.py\nnew file mode 100644\nindex 0000000..4a2da62\n--- /dev/null\n+++ b/tests/check_framework/test_language_code_validation_inverted.py\n@@ -0,0 +1,32 @@\n+from django.core.checks import Error\n+from django.core.checks.translation import check_language_settings_consistent\n+from django.test import SimpleTestCase, override_settings\n+\n+\n+class LanguageCodeValidationTests(SimpleTestCase):\n+    @override_settings(\n+        LANGUAGE_CODE='de-at',\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('en', 'English'),\n+        ]\n+    )\n+    def test_sublanguage_check_with_base_language_available(self):\n+        \"\"\"\n+        When LANGUAGE_CODE is a sublanguage (de-at) and its base language (de) is\n+        available in LANGUAGES, no error should be raised.\n+        \n+        This test will fail with \"__BUG__HERE__\" when the bug is present (i.e., when\n+        translation.E004 is incorrectly raised).\n+        \"\"\"\n+        result = check_language_settings_consistent(None)\n+        \n+        # The check should return an empty list (no errors)\n+        # If we get any errors, particularly translation.E004, that's the bug\n+        if result:\n+            for error in result:\n+                if error.id == 'translation.E004':\n+                    raise AssertionError('__BUG__HERE__')\n+        \n+        # Additional verification that we got an empty list\n+        self.assertEqual(result, [])\n\\ No newline at end of file\n",
  "num_sent_chars": 1230722,
  "num_received_chars": 11570,
  "elapsed_time": 169.2821807861328,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}