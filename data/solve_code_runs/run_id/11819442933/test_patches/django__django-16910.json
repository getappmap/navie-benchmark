{
  "edit_test_file": "tests/defer/tests.py",
  "test_patch": "diff --git a/tests/defer/test_reverse_onetoone_only_select_related.py b/tests/defer/test_reverse_onetoone_only_select_related.py\nnew file mode 100644\nindex 0000000..d3b28a4\n--- /dev/null\n+++ b/tests/defer/test_reverse_onetoone_only_select_related.py\n@@ -0,0 +1,45 @@\n+from django.test import TestCase\n+from django.db import models, connection\n+from django.test.utils import CaptureQueriesContext\n+\n+class Main(models.Model):\n+    main_field_1 = models.CharField(blank=True, max_length=45)\n+    main_field_2 = models.CharField(blank=True, max_length=45)\n+    main_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneSecondary(models.Model):\n+    main = models.OneToOneField(Main, primary_key=True, related_name='secondary', on_delete=models.CASCADE)\n+    secondary_field_1 = models.CharField(blank=True, max_length=45)\n+    secondary_field_2 = models.CharField(blank=True, max_length=45)\n+    secondary_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneOnlySelectRelatedTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        main = Main.objects.create(\n+            main_field_1=\"main1\",\n+            main_field_2=\"main2\",\n+            main_field_3=\"main3\"\n+        )\n+        ReverseOneToOneSecondary.objects.create(\n+            main=main,\n+            secondary_field_1=\"sec1\",\n+            secondary_field_2=\"sec2\",\n+            secondary_field_3=\"sec3\"\n+        )\n+\n+    def test_only_select_related_reverse_onetoone(self):\n+        \"\"\"\n+        Test that only() with select_related() on reverse OneToOne includes all fields.\n+        \"\"\"\n+        with CaptureQueriesContext(connection) as ctx:\n+            list(Main.objects.select_related('secondary').only(\n+                'main_field_1', \n+                'secondary__secondary_field_1'\n+            ))\n+            \n+        sql = ctx.captured_queries[0]['sql'].lower()\n+        \n+        # These fields should be in the query even though only() was used\n+        self.assertIn('secondary_field_2', sql)\n+        self.assertIn('secondary_field_3', sql)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/defer/test_reverse_onetoone_only_select_related_inverted.py b/tests/defer/test_reverse_onetoone_only_select_related_inverted.py\nnew file mode 100644\nindex 0000000..8df579d\n--- /dev/null\n+++ b/tests/defer/test_reverse_onetoone_only_select_related_inverted.py\n@@ -0,0 +1,46 @@\n+from django.test import TestCase\n+from django.db import models, connection\n+from django.test.utils import CaptureQueriesContext\n+\n+class Main(models.Model):\n+    main_field_1 = models.CharField(blank=True, max_length=45)\n+    main_field_2 = models.CharField(blank=True, max_length=45)\n+    main_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneSecondary(models.Model):\n+    main = models.OneToOneField(Main, primary_key=True, related_name='secondary', on_delete=models.CASCADE)\n+    secondary_field_1 = models.CharField(blank=True, max_length=45)\n+    secondary_field_2 = models.CharField(blank=True, max_length=45)\n+    secondary_field_3 = models.CharField(blank=True, max_length=45)\n+\n+class ReverseOneToOneOnlySelectRelatedTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        main = Main.objects.create(\n+            main_field_1=\"main1\",\n+            main_field_2=\"main2\",\n+            main_field_3=\"main3\"\n+        )\n+        ReverseOneToOneSecondary.objects.create(\n+            main=main,\n+            secondary_field_1=\"sec1\",\n+            secondary_field_2=\"sec2\",\n+            secondary_field_3=\"sec3\"\n+        )\n+\n+    def test_only_select_related_reverse_onetoone(self):\n+        \"\"\"\n+        Test that only() with select_related() on reverse OneToOne includes only the specified fields.\n+        The test should fail if additional fields are included in the query.\n+        \"\"\"\n+        with CaptureQueriesContext(connection) as ctx:\n+            list(Main.objects.select_related('secondary').only(\n+                'main_field_1', \n+                'secondary__secondary_field_1'\n+            ))\n+            \n+        sql = ctx.captured_queries[0]['sql'].lower()\n+        \n+        # These fields should NOT be in the query when only() is used\n+        if 'secondary_field_2' in sql or 'secondary_field_3' in sql:\n+            raise AssertionError(\"__BUG__HERE__: Query includes fields that should be excluded by only()\")\n\\ No newline at end of file\n"
}