{
  "edit_test_file": "tests/migrations/test_operations.py",
  "test_patch": "diff --git a/tests/migrations/test_sqlite_unique_constraint_migration.py b/tests/migrations/test_sqlite_unique_constraint_migration.py\nnew file mode 100644\nindex 0000000..ff53248\n--- /dev/null\n+++ b/tests/migrations/test_sqlite_unique_constraint_migration.py\n@@ -0,0 +1,64 @@\n+from django.db import migrations, models, connection, OperationalError\n+from django.db.models import F\n+from django.test import TransactionTestCase\n+from django.test.utils import override_settings\n+\n+\n+class SQLiteUniqueConstraintMigrationTests(TransactionTestCase):\n+    \"\"\"Test SQLite unique constraint migration issue.\"\"\"\n+\n+    available_apps = ['migrations']\n+\n+    def test_alter_field_with_f_expression_unique_constraint(self):\n+        \"\"\"\n+        Altering a field on a model with a unique constraint using F() expressions\n+        raises OperationalError on SQLite.\n+        \"\"\"\n+        # Skip if not using SQLite\n+        if connection.vendor != 'sqlite':\n+            self.skipTest('SQLite specific test.')\n+\n+        # Initial migration operations to set up model\n+        initial_operations = [\n+            migrations.CreateModel(\n+                name='Tag',\n+                fields=[\n+                    ('id', models.BigAutoField(auto_created=True, primary_key=True)),\n+                    ('name', models.SlugField(help_text='The tag key.')),\n+                    ('value', models.CharField(help_text='The tag value.', max_length=200)),\n+                ],\n+                options={\n+                    'ordering': ['name', 'value'],\n+                },\n+            ),\n+            migrations.AddConstraint(\n+                model_name='Tag',\n+                constraint=models.UniqueConstraint(\n+                    F('name'), F('value'),\n+                    name='unique_name_value'\n+                ),\n+            ),\n+        ]\n+\n+        # Apply initial migration\n+        with connection.schema_editor() as editor:\n+            state = migrations.state.ProjectState()\n+            for operation in initial_operations:\n+                new_state = state.clone()\n+                operation.state_forwards('migrations', new_state)\n+                operation.database_forwards('migrations', editor, state, new_state)\n+                state = new_state\n+\n+        # Now try to alter the field which should trigger the error\n+        alter_operation = migrations.AlterField(\n+            model_name='Tag',\n+            name='value',\n+            field=models.CharField(help_text='The tag value.', max_length=150),\n+        )\n+\n+        # The operation should raise OperationalError\n+        with self.assertRaisesMessage(OperationalError, 'the \".\" operator prohibited in index expressions'):\n+            with connection.schema_editor() as editor:\n+                new_state = state.clone()\n+                alter_operation.state_forwards('migrations', new_state)\n+                alter_operation.database_forwards('migrations', editor, state, new_state)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/migrations/test_sqlite_unique_constraint_migration_inverted.py b/tests/migrations/test_sqlite_unique_constraint_migration_inverted.py\nnew file mode 100644\nindex 0000000..1506d62\n--- /dev/null\n+++ b/tests/migrations/test_sqlite_unique_constraint_migration_inverted.py\n@@ -0,0 +1,67 @@\n+from django.db import migrations, models, connection, OperationalError\n+from django.db.models import F\n+from django.test import TransactionTestCase\n+from django.test.utils import override_settings\n+\n+\n+class SQLiteUniqueConstraintMigrationTests(TransactionTestCase):\n+    \"\"\"Test SQLite unique constraint migration issue.\"\"\"\n+\n+    available_apps = ['migrations']\n+\n+    def test_alter_field_with_f_expression_unique_constraint(self):\n+        \"\"\"\n+        Altering a field on a model with a unique constraint using F() expressions\n+        should work on SQLite without raising OperationalError.\n+        \"\"\"\n+        # Skip if not using SQLite\n+        if connection.vendor != 'sqlite':\n+            self.skipTest('SQLite specific test.')\n+\n+        # Initial migration operations to set up model\n+        initial_operations = [\n+            migrations.CreateModel(\n+                name='Tag',\n+                fields=[\n+                    ('id', models.BigAutoField(auto_created=True, primary_key=True)),\n+                    ('name', models.SlugField(help_text='The tag key.')),\n+                    ('value', models.CharField(help_text='The tag value.', max_length=200)),\n+                ],\n+                options={\n+                    'ordering': ['name', 'value'],\n+                },\n+            ),\n+            migrations.AddConstraint(\n+                model_name='Tag',\n+                constraint=models.UniqueConstraint(\n+                    F('name'), F('value'),\n+                    name='unique_name_value'\n+                ),\n+            ),\n+        ]\n+\n+        # Apply initial migration\n+        with connection.schema_editor() as editor:\n+            state = migrations.state.ProjectState()\n+            for operation in initial_operations:\n+                new_state = state.clone()\n+                operation.state_forwards('migrations', new_state)\n+                operation.database_forwards('migrations', editor, state, new_state)\n+                state = new_state\n+\n+        # Now try to alter the field which should not trigger an error\n+        alter_operation = migrations.AlterField(\n+            model_name='Tag',\n+            name='value',\n+            field=models.CharField(help_text='The tag value.', max_length=150),\n+        )\n+\n+        try:\n+            with connection.schema_editor() as editor:\n+                new_state = state.clone()\n+                alter_operation.state_forwards('migrations', new_state)\n+                alter_operation.database_forwards('migrations', editor, state, new_state)\n+        except OperationalError as e:\n+            if 'the \".\" operator prohibited in index expressions' in str(e):\n+                raise AssertionError(\"__BUG__HERE__\") from e\n+            raise  # Re-raise if it's a different error\n"
}