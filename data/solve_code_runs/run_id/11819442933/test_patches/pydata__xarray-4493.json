{
  "edit_test_file": "xarray/tests/test_distributed.py",
  "test_patch": "diff --git a/xarray/tests/test_dataset_chunking.py b/xarray/tests/test_dataset_chunking.py\nnew file mode 100644\nindex 0000000..e860365\n--- /dev/null\n+++ b/xarray/tests/test_dataset_chunking.py\n@@ -0,0 +1,30 @@\n+import numpy as np\n+import pytest\n+\n+import xarray as xr\n+from xarray.tests import requires_dask\n+\n+dask = pytest.importorskip(\"dask\")\n+da = pytest.importorskip(\"dask.array\")\n+\n+\n+@requires_dask\n+def test_update_loses_chunks():\n+    # Create a chunked DataArray\n+    foo = xr.DataArray(np.random.randn(3, 3), dims=(\"x\", \"y\")).chunk()\n+    ds = xr.Dataset({\"foo\": foo, \"bar\": (\"x\", [1, 2, 3])})\n+    \n+    # Verify initial state is chunked\n+    assert isinstance(ds.foo.data, da.Array)\n+    \n+    # Create update dictionary with sliced data\n+    update_dict = {\"foo\": ((\"x\", \"y\"), ds.foo[1:, :]), \"bar\": (\"x\", ds.bar[1:])}\n+    \n+    # Verify the data in update_dict is still chunked\n+    assert isinstance(update_dict[\"foo\"][1].data, da.Array)\n+    \n+    # Perform the update\n+    ds.update(update_dict)\n+    \n+    # Verify that chunking was lost after update\n+    assert isinstance(ds.foo.data, np.ndarray)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/xarray/tests/test_dataset_chunking_inverted.py b/xarray/tests/test_dataset_chunking_inverted.py\nnew file mode 100644\nindex 0000000..68ffe21\n--- /dev/null\n+++ b/xarray/tests/test_dataset_chunking_inverted.py\n@@ -0,0 +1,31 @@\n+import numpy as np\n+import pytest\n+\n+import xarray as xr\n+from xarray.tests import requires_dask\n+\n+dask = pytest.importorskip(\"dask\")\n+da = pytest.importorskip(\"dask.array\")\n+\n+\n+@requires_dask\n+def test_update_should_preserve_chunks():\n+    # Create a chunked DataArray\n+    foo = xr.DataArray(np.random.randn(3, 3), dims=(\"x\", \"y\")).chunk()\n+    ds = xr.Dataset({\"foo\": foo, \"bar\": (\"x\", [1, 2, 3])})\n+    \n+    # Verify initial state is chunked\n+    assert isinstance(ds.foo.data, da.Array)\n+    \n+    # Create update dictionary with sliced data\n+    update_dict = {\"foo\": ((\"x\", \"y\"), ds.foo[1:, :]), \"bar\": (\"x\", ds.bar[1:])}\n+    \n+    # Verify the data in update_dict is still chunked\n+    assert isinstance(update_dict[\"foo\"][1].data, da.Array)\n+    \n+    # Perform the update\n+    ds.update(update_dict)\n+    \n+    # This should now fail when chunking is lost\n+    if not isinstance(ds.foo.data, da.Array):\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n"
}