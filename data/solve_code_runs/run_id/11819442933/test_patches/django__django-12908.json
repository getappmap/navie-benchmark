{
  "edit_test_file": "tests/queries/test_qs_combinators.py",
  "test_patch": "diff --git a/tests/queries/test_union_distinct.py b/tests/queries/test_union_distinct.py\nnew file mode 100644\nindex 0000000..068ea34\n--- /dev/null\n+++ b/tests/queries/test_union_distinct.py\n@@ -0,0 +1,36 @@\n+from django.db import models\n+from django.db.models import Value, IntegerField\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class UnionDistinctTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data with duplicate names\n+        Number.objects.bulk_create([\n+            Number(num=1, other_num=1),\n+            Number(num=1, other_num=2),  # Duplicate num=1\n+            Number(num=2, other_num=3),\n+            Number(num=2, other_num=4),  # Duplicate num=2\n+            Number(num=3, other_num=5),\n+        ])\n+\n+    def test_union_annotated_distinct_not_working(self):\n+        \"\"\"\n+        Test that distinct() after union() of annotated querysets doesn't work as expected.\n+        The test passes when the issue is present (distinct not working).\n+        \"\"\"\n+        # Create two querysets with annotations\n+        qs1 = Number.objects.filter(num=1).annotate(rank=Value(0, IntegerField()))\n+        qs2 = Number.objects.filter(num=2).annotate(rank=Value(1, IntegerField()))\n+        \n+        # Union the querysets and try to apply distinct\n+        union_qs = qs1.union(qs2)\n+        result = union_qs.order_by('num').distinct('num')\n+        \n+        # When the issue is present, distinct() won't remove duplicates\n+        # So we'll get more results than we should\n+        # We expect 4 results (2 for num=1 and 2 for num=2) instead of 2\n+        self.assertEqual(result.count(), 4)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/queries/test_union_distinct_inverted.py b/tests/queries/test_union_distinct_inverted.py\nnew file mode 100644\nindex 0000000..2ead365\n--- /dev/null\n+++ b/tests/queries/test_union_distinct_inverted.py\n@@ -0,0 +1,44 @@\n+from django.db import models\n+from django.db.models import Value, IntegerField\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class UnionDistinctTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data with duplicate names\n+        Number.objects.bulk_create([\n+            Number(num=1, other_num=1),\n+            Number(num=1, other_num=2),  # Duplicate num=1\n+            Number(num=2, other_num=3),\n+            Number(num=2, other_num=4),  # Duplicate num=2\n+            Number(num=3, other_num=5),\n+        ])\n+\n+    def test_union_annotated_distinct_should_work(self):\n+        \"\"\"\n+        Test that distinct() after union() of annotated querysets should work correctly.\n+        The test fails when the issue is present (distinct not working).\n+        \"\"\"\n+        # Create two querysets with annotations\n+        qs1 = Number.objects.filter(num=1).annotate(rank=Value(0, IntegerField()))\n+        qs2 = Number.objects.filter(num=2).annotate(rank=Value(1, IntegerField()))\n+        \n+        # Union the querysets and try to apply distinct\n+        union_qs = qs1.union(qs2)\n+        result = union_qs.order_by('num').distinct('num')\n+        \n+        # Count the results\n+        result_count = result.count()\n+        \n+        # When distinct works correctly, we should get exactly one result per num value\n+        # If we get more than 2 results, it means distinct() isn't working\n+        if result_count > 2:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # Additional verification\n+        self.assertEqual(result_count, 2, \n+            \"Expected 2 distinct results (one per num value), but got {}\"\n+            .format(result_count))\n\\ No newline at end of file\n"
}