{
  "edit_test_file": "tests/invalid_models_tests/test_relative_fields.py",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_related_name_generation.py b/tests/invalid_models_tests/test_related_name_generation.py\nnew file mode 100644\nindex 0000000..cb1ff49\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_related_name_generation.py\n@@ -0,0 +1,51 @@\n+from django.core.checks import Error\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"invalid_models_tests\")\n+class RelatedNameGenerationTests(SimpleTestCase):\n+    def test_multiple_fks_to_same_model_without_related_names(self):\n+        \"\"\"\n+        Test that models with multiple FKs to the same model without related_names\n+        produce field accessor clash errors, demonstrating the need for automatic\n+        related_name generation in inspectdb.\n+        \"\"\"\n+        class Target(models.Model):\n+            name = models.CharField(max_length=30)\n+\n+        class Model(models.Model):\n+            # Multiple FKs to the same model without related_names\n+            field1 = models.ForeignKey(Target, models.CASCADE)\n+            field2 = models.ForeignKey(Target, models.CASCADE)\n+\n+        self.assertEqual(\n+            Model.check(),\n+            [\n+                Error(\n+                    \"Reverse accessor 'Target.model_set' for \"\n+                    \"'invalid_models_tests.Model.field1' clashes with reverse \"\n+                    \"accessor for 'invalid_models_tests.Model.field2'.\",\n+                    hint=(\n+                        \"Add or change a related_name argument to the definition \"\n+                        \"for 'invalid_models_tests.Model.field1' or \"\n+                        \"'invalid_models_tests.Model.field2'.\"\n+                    ),\n+                    obj=Model._meta.get_field(\"field1\"),\n+                    id=\"fields.E304\",\n+                ),\n+                Error(\n+                    \"Reverse accessor 'Target.model_set' for \"\n+                    \"'invalid_models_tests.Model.field2' clashes with reverse \"\n+                    \"accessor for 'invalid_models_tests.Model.field1'.\",\n+                    hint=(\n+                        \"Add or change a related_name argument to the definition \"\n+                        \"for 'invalid_models_tests.Model.field2' or \"\n+                        \"'invalid_models_tests.Model.field1'.\"\n+                    ),\n+                    obj=Model._meta.get_field(\"field2\"),\n+                    id=\"fields.E304\",\n+                ),\n+            ],\n+        )\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/invalid_models_tests/test_related_name_generation_inverted.py b/tests/invalid_models_tests/test_related_name_generation_inverted.py\nnew file mode 100644\nindex 0000000..40f7d7a\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_related_name_generation_inverted.py\n@@ -0,0 +1,36 @@\n+from django.core.checks import Error\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"invalid_models_tests\")\n+class RelatedNameGenerationTests(SimpleTestCase):\n+    def test_multiple_fks_to_same_model_without_related_names(self):\n+        \"\"\"\n+        Test that inspectdb should automatically generate related_names when\n+        multiple FKs point to the same model. The test should fail if\n+        related_names are not automatically generated.\n+        \"\"\"\n+        class Target(models.Model):\n+            name = models.CharField(max_length=30)\n+\n+        class Model(models.Model):\n+            # Multiple FKs to the same model without related_names\n+            field1 = models.ForeignKey(Target, models.CASCADE)\n+            field2 = models.ForeignKey(Target, models.CASCADE)\n+\n+        errors = Model.check()\n+        \n+        # If there are any field accessor clash errors (E304),\n+        # this means related_names were not auto-generated, which is the bug\n+        has_field_clash = any(\n+            error.id == 'fields.E304' for error in errors\n+        )\n+        \n+        if has_field_clash:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # If we get here, no field clash errors were found,\n+        # meaning related_names were properly auto-generated\n+        self.assertEqual(errors, [])\n\\ No newline at end of file\n"
}