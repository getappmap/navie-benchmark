{
  "edit_test_file": "testing/python/approx.py",
  "test_patch": "diff --git a/testing/python/test_iterable_assertions.py b/testing/python/test_iterable_assertions.py\nnew file mode 100644\nindex 0000000..498e95b\n--- /dev/null\n+++ b/testing/python/test_iterable_assertions.py\n@@ -0,0 +1,31 @@\n+import pytest\n+\n+def is_even(n):\n+    return n % 2 == 0\n+\n+def test_all_assertion_message():\n+    \"\"\"\n+    Test that demonstrates the less useful error message when using all() with a generator expression\n+    compared to a for loop.\n+    \"\"\"\n+    even_stevens = list(range(1, 100, 2))  # List of odd numbers\n+    \n+    # Capture the assertion error message when using all() with generator expression\n+    with pytest.raises(AssertionError) as excinfo:\n+        assert all(is_even(number) for number in even_stevens)\n+    \n+    # The error message should be less informative, only showing the generator object\n+    error_msg = str(excinfo.value)\n+    assert \"generator object\" in error_msg\n+    assert \"where False = all(\" in error_msg\n+    assert \"is_even(1)\" not in error_msg  # Should not show the actual failing value\n+\n+    # Capture the assertion error message when using a for loop\n+    with pytest.raises(AssertionError) as excinfo:\n+        for number in even_stevens:\n+            assert is_even(number)\n+            break  # Only need to test first failure\n+    \n+    # The error message should be more informative, showing the actual failing value\n+    error_msg = str(excinfo.value)\n+    assert \"is_even(1)\" in error_msg  # Shows the actual failing value\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/testing/python/test_iterable_assertions_inverted.py b/testing/python/test_iterable_assertions_inverted.py\nnew file mode 100644\nindex 0000000..8a1a4f2\n--- /dev/null\n+++ b/testing/python/test_iterable_assertions_inverted.py\n@@ -0,0 +1,54 @@\n+import pytest\n+\n+def is_even(n):\n+    return n % 2 == 0\n+\n+def test_all_assertion_message():\n+    \"\"\"\n+    Test that demonstrates the issue with all() error messages.\n+    This test will FAIL when the issue is observed (poor error messages with generator expressions).\n+    \"\"\"\n+    even_stevens = list(range(1, 100, 2))  # List of odd numbers\n+    \n+    # Capture the assertion error message when using all() with generator expression\n+    with pytest.raises(AssertionError) as excinfo:\n+        assert all(is_even(number) for number in even_stevens)\n+    \n+    error_msg = str(excinfo.value)\n+    \n+    # If we see the less informative error message (the issue),\n+    # we want the test to fail with our specific message\n+    if \"generator object\" in error_msg and \"where False = all(\" in error_msg:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # The error message should contain the actual failing value\n+    # (which it currently doesn't - that's the bug)\n+    assert \"is_even(1)\" in error_msg, (\n+        \"Error message should show the actual failing value\"\n+    )\n+    \n+    # The error message should not contain the less informative generator object text\n+    assert \"generator object\" not in error_msg, (\n+        \"Error message should not show generic generator object\"\n+    )\n+    \n+    # The error message should not contain the generic all() failure\n+    assert \"where False = all(\" not in error_msg, (\n+        \"Error message should not show generic all() failure\"\n+    )\n+\n+def test_for_loop_assertion_message():\n+    \"\"\"\n+    Reference test showing the desired error message format using a for loop.\n+    \"\"\"\n+    even_stevens = list(range(1, 100, 2))\n+    \n+    with pytest.raises(AssertionError) as excinfo:\n+        for number in even_stevens:\n+            assert is_even(number)\n+            break  # Only need to test first failure\n+    \n+    error_msg = str(excinfo.value)\n+    assert \"is_even(1)\" in error_msg, (\n+        \"For loop assertion should show the actual failing value\"\n+    )\n\\ No newline at end of file\n"
}