{
  "edit_test_file": "lib/matplotlib/tests/test_backend_tk.py",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_range_slider_callback.py b/lib/matplotlib/tests/test_range_slider_callback.py\nnew file mode 100644\nindex 0000000..b96c640\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_range_slider_callback.py\n@@ -0,0 +1,84 @@\n+import functools\n+import importlib\n+import os\n+import platform\n+import subprocess\n+import sys\n+\n+import pytest\n+\n+from matplotlib import _c_internal_utils\n+from matplotlib.testing import subprocess_run_helper\n+from matplotlib.widgets import RangeSlider, Button\n+import matplotlib.pyplot as plt\n+\n+\n+_test_timeout = 60  # A reasonably safe value for slower architectures.\n+\n+\n+def _isolated_tk_test(success_count, func=None):\n+    \"\"\"\n+    A decorator to run *func* in a subprocess and assert that it prints\n+    \"success\" *success_count* times and nothing on stderr.\n+    \"\"\"\n+    if func is None:\n+        return functools.partial(_isolated_tk_test, success_count)\n+\n+    if \"MPL_TEST_ESCAPE_HATCH\" in os.environ:\n+        # set in subprocess_run_helper() below\n+        return func\n+\n+    @pytest.mark.skipif(\n+        not importlib.util.find_spec('tkinter'),\n+        reason=\"missing tkinter\"\n+    )\n+    @pytest.mark.skipif(\n+        sys.platform == \"linux\" and not _c_internal_utils.display_is_valid(),\n+        reason=\"$DISPLAY and $WAYLAND_DISPLAY are unset\"\n+    )\n+    @functools.wraps(func)\n+    def test_func():\n+        pytest.importorskip('tkinter')\n+        try:\n+            proc = subprocess_run_helper(\n+                func, timeout=_test_timeout, extra_env=dict(\n+                    MPLBACKEND=\"TkAgg\", MPL_TEST_ESCAPE_HATCH=\"1\"))\n+        except subprocess.TimeoutExpired:\n+            pytest.fail(\"Subprocess timed out\")\n+        except subprocess.CalledProcessError as e:\n+            pytest.fail(\"Subprocess failed to test intended behavior\\n\"\n+                       + str(e.stderr))\n+        else:\n+            assert proc.stdout.count(\"success\") == success_count\n+            assert not proc.stderr\n+\n+    return test_func\n+\n+\n+@_isolated_tk_test(success_count=1)\n+def test_range_slider_callback_blocks():\n+    \"\"\"Test that RangeSlider callback with clf() and draw() blocks widget inputs.\"\"\"\n+    \n+    def on_changed(values):\n+        plt.clf()\n+        add_elements()\n+        plt.draw()\n+        print(\"success\")  # Indicate we reached this point\n+        \n+    def add_elements():\n+        ax_slider = plt.axes([0.1, 0.45, 0.8, 0.1])\n+        slider = RangeSlider(ax_slider, \"Test\", valmin=1, valmax=10, valinit=(1, 10))\n+        slider.on_changed(on_changed)\n+        \n+        ax_button = plt.axes([0.1, 0.30, 0.8, 0.1])\n+        button = Button(ax_button, \"Test\")\n+    \n+    fig = plt.figure()\n+    add_elements()\n+    \n+    # Simulate a slider change event\n+    fig.canvas.draw()\n+    fig.canvas.flush_events()\n+    \n+    plt.show(block=False)\n+    plt.close()\n",
  "inverted_patch": null
}