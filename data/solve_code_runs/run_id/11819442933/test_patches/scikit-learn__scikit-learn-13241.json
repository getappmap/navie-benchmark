{
  "edit_test_file": "sklearn/manifold/tests/test_spectral_embedding.py",
  "test_patch": "diff --git a/sklearn/manifold/tests/test_kernel_pca_sign_consistency.py b/sklearn/manifold/tests/test_kernel_pca_sign_consistency.py\nnew file mode 100644\nindex 0000000..f8ed3fa\n--- /dev/null\n+++ b/sklearn/manifold/tests/test_kernel_pca_sign_consistency.py\n@@ -0,0 +1,43 @@\n+import numpy as np\n+from sklearn.decomposition import KernelPCA\n+from sklearn.utils.testing import assert_array_almost_equal\n+\n+def test_kernel_pca_sign_consistency():\n+    \"\"\"Test that KernelPCA with RBF kernel produces results that can differ in signs.\n+    \n+    This test verifies the issue where KernelPCA with RBF kernel produces output\n+    components that may have flipped signs between different runs, even with the\n+    same input data.\n+    \"\"\"\n+    # Generate sample data\n+    rng = np.random.RandomState(42)\n+    X = rng.random_sample((5, 4))\n+    \n+    # Run KernelPCA multiple times and collect results\n+    n_runs = 10\n+    transformed_data = []\n+    \n+    for _ in range(n_runs):\n+        # Create new KernelPCA instance each time\n+        # Not setting random_state to allow for randomness\n+        kpca = KernelPCA(n_components=7, kernel='rbf')\n+        transformed = kpca.fit_transform(X)\n+        transformed_data.append(transformed)\n+    \n+    # Compare absolute values - these should be consistent\n+    for i in range(1, n_runs):\n+        assert_array_almost_equal(\n+            np.abs(transformed_data[0]), \n+            np.abs(transformed_data[i]),\n+            decimal=6\n+        )\n+    \n+    # Check if we observe sign flips in any of the runs\n+    # We expect at least one pair of runs to have different signs\n+    sign_flips_observed = False\n+    for i in range(1, n_runs):\n+        if not np.allclose(transformed_data[0], transformed_data[i]):\n+            sign_flips_observed = True\n+            break\n+            \n+    assert sign_flips_observed, \"Expected to observe sign flips between different runs\"\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/sklearn/manifold/tests/test_kernel_pca_sign_consistency_inverted.py b/sklearn/manifold/tests/test_kernel_pca_sign_consistency_inverted.py\nnew file mode 100644\nindex 0000000..8f529b6\n--- /dev/null\n+++ b/sklearn/manifold/tests/test_kernel_pca_sign_consistency_inverted.py\n@@ -0,0 +1,39 @@\n+import numpy as np\n+from sklearn.decomposition import KernelPCA\n+from sklearn.utils.testing import assert_array_almost_equal\n+\n+def test_kernel_pca_sign_consistency():\n+    \"\"\"Test that KernelPCA with RBF kernel should produce consistent signs.\n+    \n+    This test verifies that KernelPCA with RBF kernel should not produce output\n+    components that have flipped signs between different runs with the same input\n+    data. The test will fail if sign flips are detected.\n+    \"\"\"\n+    # Generate sample data\n+    rng = np.random.RandomState(42)\n+    X = rng.random_sample((5, 4))\n+    \n+    # Run KernelPCA multiple times and collect results\n+    n_runs = 10\n+    transformed_data = []\n+    \n+    for _ in range(n_runs):\n+        # Create new KernelPCA instance each time\n+        # Not setting random_state to allow for randomness\n+        kpca = KernelPCA(n_components=7, kernel='rbf')\n+        transformed = kpca.fit_transform(X)\n+        transformed_data.append(transformed)\n+    \n+    # Compare absolute values - these should be consistent\n+    for i in range(1, n_runs):\n+        assert_array_almost_equal(\n+            np.abs(transformed_data[0]), \n+            np.abs(transformed_data[i]),\n+            decimal=6\n+        )\n+    \n+    # Check for sign flips in any of the runs\n+    # The test should fail if sign flips are observed\n+    for i in range(1, n_runs):\n+        if not np.allclose(transformed_data[0], transformed_data[i]):\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n"
}