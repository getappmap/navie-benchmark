{
  "instance_id": "matplotlib__matplotlib-14623",
  "edit_test_file": "lib/matplotlib/tests/test_ticker.py",
  "code_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6..4e211af 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3627,25 +3627,32 @@ class _AxesBase(martist.Artist):\n             top = old_top\n \n         if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+            # For log scale, validate values but preserve inversion intent\n+            if bottom <= 0 or top <= 0:\n+                # If either limit is invalid, try to preserve the axis direction\n+                bottom_valid = bottom if bottom > 0 else old_bottom\n+                top_valid = top if top > 0 else old_top\n+                if bottom <= 0:\n+                    cbook._warn_external(\n+                        'Attempted to set non-positive bottom ylim on a '\n+                        'log-scaled axis.\\nInvalid limit will be ignored.')\n+                if top <= 0:\n+                    cbook._warn_external(\n+                        'Attempted to set non-positive top ylim on a '\n+                        'log-scaled axis.\\nInvalid limit will be ignored.')\n+                bottom, top = bottom_valid, top_valid\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+        # Store the intended direction before nonsingular adjustment\n+        is_inverted = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        # Restore the intended direction if it was changed\n+        if is_inverted and bottom < top:\n+            bottom, top = top, bottom\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_invert_log_scale.py b/lib/matplotlib/tests/test_invert_log_scale.py\nnew file mode 100644\nindex 0000000..ebd5eea\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_invert_log_scale.py\n@@ -0,0 +1,25 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import unittest\n+\n+class TestInvertLogScale(unittest.TestCase):\n+    def test_invert_log_scale(self):\n+        y = np.linspace(1000e2, 1, 100)\n+        x = np.exp(-np.linspace(0, 1, y.size))\n+\n+        for yscale in ('linear', 'log'):\n+            fig, ax = plt.subplots()\n+            ax.plot(x, y)\n+            ax.set_yscale(yscale)\n+            ax.set_ylim(y.max(), y.min())\n+\n+            # Check if the y-axis is inverted\n+            y_limits = ax.get_ylim()\n+            if yscale == 'linear':\n+                self.assertEqual(y_limits, (y.max(), y.min()))\n+            else:\n+                # For log scale, the axis should not be inverted, reproducing the issue\n+                self.assertNotEqual(y_limits, (y.max(), y.min()))\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_invert_log_scale_inverted.py b/lib/matplotlib/tests/test_invert_log_scale_inverted.py\nnew file mode 100644\nindex 0000000..5234826\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_invert_log_scale_inverted.py\n@@ -0,0 +1,27 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import unittest\n+\n+class TestInvertLogScale(unittest.TestCase):\n+    def test_invert_log_scale(self):\n+        y = np.linspace(1000e2, 1, 100)\n+        x = np.exp(-np.linspace(0, 1, y.size))\n+\n+        for yscale in ('linear', 'log'):\n+            fig, ax = plt.subplots()\n+            ax.plot(x, y)\n+            ax.set_yscale(yscale)\n+            ax.set_ylim(y.max(), y.min())\n+\n+            # Check if the y-axis is inverted\n+            y_limits = ax.get_ylim()\n+            if yscale == 'linear':\n+                self.assertEqual(y_limits, (y.max(), y.min()))\n+            else:\n+                # For log scale, the axis should be inverted, but it is not\n+                # This should now fail when the bug is observed\n+                if y_limits != (y.max(), y.min()):\n+                    raise AssertionError(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 740036,
  "num_received_chars": 8613,
  "elapsed_time": 110.21927785873413,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}