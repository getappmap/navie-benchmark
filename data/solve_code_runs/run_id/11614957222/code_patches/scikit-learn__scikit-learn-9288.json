{
  "instance_id": "scikit-learn__scikit-learn-9288",
  "edit_test_file": "sklearn/cluster/tests/test_k_means.py",
  "code_patch": "diff --git a/sklearn/cluster/k_means_.py b/sklearn/cluster/k_means_.py\nindex b7fbdf7..46ded99 100644\n--- a/sklearn/cluster/k_means_.py\n+++ b/sklearn/cluster/k_means_.py\n@@ -361,25 +361,26 @@ def k_means(X, n_clusters, sample_weight=None, init='k-means++',\n         raise ValueError(\"Algorithm must be 'auto', 'full' or 'elkan', got\"\n                          \" %s\" % str(algorithm))\n     if effective_n_jobs(n_jobs) == 1:\n-        # For a single thread, less memory is needed if we just store one set\n-        # of the best results (as opposed to one set per run per thread).\n-        for it in range(n_init):\n-            # run a k-means once\n-            labels, inertia, centers, n_iter_ = kmeans_single(\n-                X, sample_weight, n_clusters, max_iter=max_iter, init=init,\n-                verbose=verbose, precompute_distances=precompute_distances,\n-                tol=tol, x_squared_norms=x_squared_norms,\n-                random_state=random_state)\n-            # determine if these results are the best so far\n-            if best_inertia is None or inertia < best_inertia:\n-                best_labels = labels.copy()\n-                best_centers = centers.copy()\n-                best_inertia = inertia\n-                best_n_iter = n_iter_\n+        # For a single thread, use same approach as parallel to ensure consistency\n+        seeds = random_state.randint(np.iinfo(np.int32).max, size=n_init)\n+        results = [kmeans_single(X, sample_weight, n_clusters,\n+                                max_iter=max_iter, init=init,\n+                                verbose=verbose, tol=tol,\n+                                precompute_distances=precompute_distances,\n+                                x_squared_norms=x_squared_norms,\n+                                random_state=seed)\n+                  for seed in seeds]\n+        # Get results with the lowest inertia\n+        labels, inertia, centers, n_iters = zip(*results)\n+        best = np.argmin(inertia)\n+        best_labels = labels[best]\n+        best_centers = centers[best]\n+        best_inertia = inertia[best]\n+        best_n_iter = n_iters[best]\n     else:\n         # parallelisation of k-means runs\n         seeds = random_state.randint(np.iinfo(np.int32).max, size=n_init)\n-        results = Parallel(n_jobs=n_jobs, verbose=0)(\n+        results = Parallel(n_jobs=n_jobs, verbose=0, require='sharedmem')(\n             delayed(kmeans_single)(X, sample_weight, n_clusters,\n                                    max_iter=max_iter, init=init,\n                                    verbose=verbose, tol=tol,\n",
  "test_patch": "diff --git a/sklearn/cluster/tests/test_kmeans_parallel.py b/sklearn/cluster/tests/test_kmeans_parallel.py\nnew file mode 100644\nindex 0000000..6e17de5\n--- /dev/null\n+++ b/sklearn/cluster/tests/test_kmeans_parallel.py\n@@ -0,0 +1,24 @@\n+import numpy as np\n+from sklearn.cluster import KMeans\n+from sklearn.datasets import make_blobs\n+from sklearn.utils.testing import assert_almost_equal\n+\n+def test_kmeans_n_jobs_inertia_difference():\n+    # Generate some data\n+    X, _ = make_blobs(n_samples=10000, centers=10, n_features=2, random_state=2)\n+\n+    # Run KMeans with n_jobs=1\n+    kmeans_single = KMeans(n_clusters=10, random_state=2, n_jobs=1)\n+    kmeans_single.fit(X)\n+    inertia_single = kmeans_single.inertia_\n+\n+    # Run KMeans with n_jobs=2\n+    kmeans_parallel = KMeans(n_clusters=10, random_state=2, n_jobs=2)\n+    kmeans_parallel.fit(X)\n+    inertia_parallel = kmeans_parallel.inertia_\n+\n+    # Assert that the inertia values are not almost equal, indicating a difference\n+    assert inertia_single != inertia_parallel, (\n+        f\"Inertia should differ for n_jobs=1 and n_jobs=2, \"\n+        f\"but got {inertia_single} and {inertia_parallel} respectively.\"\n+    )\n",
  "test_inverted_patch": "diff --git a/sklearn/cluster/tests/test_kmeans_parallel_inverted.py b/sklearn/cluster/tests/test_kmeans_parallel_inverted.py\nnew file mode 100644\nindex 0000000..dbb45d4\n--- /dev/null\n+++ b/sklearn/cluster/tests/test_kmeans_parallel_inverted.py\n@@ -0,0 +1,22 @@\n+import numpy as np\n+from sklearn.cluster import KMeans\n+from sklearn.datasets import make_blobs\n+\n+def test_kmeans_n_jobs_inertia_difference():\n+    # Generate some data\n+    X, _ = make_blobs(n_samples=10000, centers=10, n_features=2, random_state=2)\n+\n+    # Run KMeans with n_jobs=1\n+    kmeans_single = KMeans(n_clusters=10, random_state=2, n_jobs=1)\n+    kmeans_single.fit(X)\n+    inertia_single = kmeans_single.inertia_\n+\n+    # Run KMeans with n_jobs=2\n+    kmeans_parallel = KMeans(n_clusters=10, random_state=2, n_jobs=2)\n+    kmeans_parallel.fit(X)\n+    inertia_parallel = kmeans_parallel.inertia_\n+\n+    # Assert that the inertia values are almost equal, indicating no difference\n+    # If they are not equal, raise an error with the message \"__BUG__HERE__\"\n+    if inertia_single != inertia_parallel:\n+        raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 783735,
  "num_received_chars": 9770,
  "elapsed_time": 145.26520085334778,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}