{
  "instance_id": "django__django-12125",
  "edit_test_file": "tests/model_fields/test_charfield.py",
  "code_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 7d22695..0243d82 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -90,10 +90,15 @@ class DeconstructableSerializer(BaseSerializer):\n \n     @staticmethod\n     def _serialize_path(path):\n-        module, name = path.rsplit(\".\", 1)\n-        if module == \"django.db.models\":\n+        module, class_path = path.rsplit(\".\", 1)\n+        # Handle nested classes by checking for dots in the class path\n+        if '.' in class_path:\n+            # For nested classes, import the module and use the full path\n+            imports = {\"import %s\" % module}\n+            name = path\n+        elif module == \"django.db.models\":\n             imports = {\"from django.db import models\"}\n-            name = \"models.%s\" % name\n+            name = \"models.%s\" % class_path\n         else:\n             imports = {\"import %s\" % module}\n             name = path\n@@ -143,7 +148,7 @@ class FunctionTypeSerializer(BaseSerializer):\n         if getattr(self.value, \"__self__\", None) and isinstance(self.value.__self__, type):\n             klass = self.value.__self__\n             module = klass.__module__\n-            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\"import %s\" % module}\n+            return \"%s.%s.%s\" % (module, klass.__qualname__, self.value.__name__), {\"import %s\" % module}\n         # Further error checking\n         if self.value.__name__ == '<lambda>':\n             raise ValueError(\"Cannot serialize function: lambda\")\n",
  "test_patch": "diff --git a/tests/model_fields/test_innerclassfield.py b/tests/model_fields/test_innerclassfield.py\nnew file mode 100644\nindex 0000000..74696d3\n--- /dev/null\n+++ b/tests/model_fields/test_innerclassfield.py\n@@ -0,0 +1,27 @@\n+from django.core.management import call_command\n+from django.test import TestCase\n+from django.db import models\n+import os\n+\n+class Outer(object):\n+    class Inner(models.CharField):\n+        pass\n+\n+class A(models.Model):\n+    field = Outer.Inner(max_length=20)\n+\n+class InnerClassFieldTestCase(TestCase):\n+    def test_incorrect_migration_path_for_inner_class(self):\n+        \"\"\"\n+        Test that makemigrations produces incorrect path for inner classes.\n+        \"\"\"\n+        # Create a temporary directory for migrations\n+        migrations_dir = os.path.join(os.path.dirname(__file__), 'migrations')\n+        os.makedirs(migrations_dir, exist_ok=True)\n+\n+        # Run makemigrations\n+        call_command('makemigrations', 'model_fields', verbosity=0)\n+\n+        # Check the generated migration file for incorrect path\n+        migration_files = os.listdir(migrations_dir)\n+        self.assertTrue(any('Inner' in open(os.path.join(migrations_dir, f)).read() for f in migration_files))\n",
  "test_inverted_patch": "diff --git a/tests/model_fields/test_innerclassfield_inverted.py b/tests/model_fields/test_innerclassfield_inverted.py\nnew file mode 100644\nindex 0000000..56a88b1\n--- /dev/null\n+++ b/tests/model_fields/test_innerclassfield_inverted.py\n@@ -0,0 +1,28 @@\n+from django.core.management import call_command\n+from django.test import TestCase\n+from django.db import models\n+import os\n+\n+class Outer(object):\n+    class Inner(models.CharField):\n+        pass\n+\n+class A(models.Model):\n+    field = Outer.Inner(max_length=20)\n+\n+class InnerClassFieldTestCase(TestCase):\n+    def test_incorrect_migration_path_for_inner_class(self):\n+        \"\"\"\n+        Test that makemigrations produces incorrect path for inner classes.\n+        \"\"\"\n+        # Create a temporary directory for migrations\n+        migrations_dir = os.path.join(os.path.dirname(__file__), 'migrations')\n+        os.makedirs(migrations_dir, exist_ok=True)\n+\n+        # Run makemigrations\n+        call_command('makemigrations', 'model_fields', verbosity=0)\n+\n+        # Check the generated migration file for incorrect path\n+        migration_files = os.listdir(migrations_dir)\n+        if any('Inner' in open(os.path.join(migrations_dir, f)).read() for f in migration_files):\n+            raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 3449772,
  "num_received_chars": 63300,
  "elapsed_time": 646.774551153183,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}