{
  "instance_id": "django__django-14580",
  "edit_test_file": "tests/migrations/test_autodetector.py",
  "code_patch": "diff --git a/django/db/migrations/writer.py b/django/db/migrations/writer.py\nindex 4918261..538bc4d 100644\n--- a/django/db/migrations/writer.py\n+++ b/django/db/migrations/writer.py\n@@ -164,8 +164,16 @@ class MigrationWriter:\n \n         # django.db.migrations is always used, but models import may not be.\n         # If models import exists, merge it with migrations import.\n+        needs_models = False\n         if \"from django.db import models\" in imports:\n+            needs_models = True\n             imports.discard(\"from django.db import models\")\n+        # Check for models.Model in bases tuples\n+        for operation in self.migration.operations:\n+            if hasattr(operation, 'bases') and any('models.Model' in str(base) for base in getattr(operation, 'bases', [])):\n+                needs_models = True\n+                break\n+        if needs_models:\n             imports.add(\"from django.db import migrations, models\")\n         else:\n             imports.add(\"from django.db import migrations\")\n",
  "test_patch": "diff --git a/tests/migrations/test_migration_import_models.py b/tests/migrations/test_migration_import_models.py\nnew file mode 100644\nindex 0000000..79b71b9\n--- /dev/null\n+++ b/tests/migrations/test_migration_import_models.py\n@@ -0,0 +1,60 @@\n+from django.db import migrations, models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+class TestMigrationImportModels(TestCase):\n+    \"\"\"Test that migrations properly handle model imports.\"\"\"\n+\n+    def test_migration_missing_models_import(self):\n+        \"\"\"Test that migrations include models import when using custom model bases.\"\"\"\n+        # Define a custom mixin class\n+        class MyMixin:\n+            pass\n+\n+        # Define a custom field\n+        class MyField(models.TextField):\n+            pass\n+\n+        # Define the abstract base model\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        # Create the model states\n+        model = ModelState(\n+            \"app\",\n+            \"MyModel\",\n+            [\n+                (\"name\", MyField(primary_key=True)),\n+            ],\n+            bases=(\"app.models.MyMixin\", \"models.Model\"),\n+            options={\"abstract\": False},\n+        )\n+\n+        # Make the project states\n+        before = ProjectState()\n+        after = ProjectState()\n+        after.add_model(model)\n+\n+        # Make autodetector\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Get the CreateModel operation\n+        self.assertIn(\"app\", changes)\n+        self.assertEqual(len(changes[\"app\"]), 1)\n+        self.assertEqual(len(changes[\"app\"][0].operations), 1)\n+        operation = changes[\"app\"][0].operations[0]\n+\n+        # Verify the operation attributes\n+        self.assertEqual(operation.name, \"MyModel\")\n+        self.assertEqual(operation.bases, (\"app.models.MyMixin\", \"models.Model\"))\n+        self.assertEqual(operation.options, {\"abstract\": False})\n+\n+        # The fields should include the custom field\n+        self.assertEqual(len(operation.fields), 1)\n+        name_field = operation.fields[0]\n+        self.assertEqual(name_field[0], \"name\")\n+        self.assertIsInstance(name_field[1], MyField)\n+        self.assertTrue(name_field[1].primary_key)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_migration_import_models_inverted.py b/tests/migrations/test_migration_import_models_inverted.py\nnew file mode 100644\nindex 0000000..940c186\n--- /dev/null\n+++ b/tests/migrations/test_migration_import_models_inverted.py\n@@ -0,0 +1,62 @@\n+from django.db import migrations, models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.writer import MigrationWriter\n+\n+\n+class TestMigrationImportModels(TestCase):\n+    \"\"\"Test that migrations properly handle model imports.\"\"\"\n+\n+    def test_migration_missing_models_import(self):\n+        \"\"\"Test that migrations include models import when using custom model bases.\"\"\"\n+        # Define a custom mixin class\n+        class MyMixin:\n+            pass\n+\n+        # Define a custom field\n+        class MyField(models.TextField):\n+            pass\n+\n+        # Define the abstract base model\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        # Create the model states\n+        model = ModelState(\n+            \"app\",\n+            \"MyModel\",\n+            [\n+                (\"name\", MyField(primary_key=True)),\n+            ],\n+            bases=(\"app.models.MyMixin\", \"models.Model\"),\n+            options={\"abstract\": False},\n+        )\n+\n+        # Make the project states\n+        before = ProjectState()\n+        after = ProjectState()\n+        after.add_model(model)\n+\n+        # Make autodetector\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Get the migration\n+        migration = changes[\"app\"][0]\n+        \n+        # Write the migration to string\n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # Check if 'from django.db import models' is in the imports\n+        if \"from django.db import models\" not in migration_string:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify the imports are correct by attempting to compile the migration\n+        try:\n+            compile(migration_string, \"migration.py\", \"exec\")\n+        except NameError as e:\n+            if \"name 'models' is not defined\" in str(e):\n+                raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3187324,
  "num_received_chars": 41111,
  "elapsed_time": 603.3327467441559,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}