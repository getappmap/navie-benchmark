{
  "instance_id": "django__django-14170",
  "edit_test_file": "tests/db_functions/datetime/test_extract_trunc.py",
  "code_patch": "diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py\nindex 90e6f41..570390a 100644\n--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -88,11 +88,14 @@ class Extract(TimezoneMixin, Transform):\n \n class ExtractYear(Extract):\n     lookup_name = 'year'\n+    use_year_lookup_optimization = True\n \n \n class ExtractIsoYear(Extract):\n     \"\"\"Return the ISO-8601 week-numbering year.\"\"\"\n     lookup_name = 'iso_year'\n+    use_year_lookup_optimization = False\n+    use_year_lookup_optimization = False\n \n \n class ExtractMonth(Extract):\n\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 916478d..2220464 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -550,6 +550,9 @@ class YearLookup(Lookup):\n         # Avoid the extract operation if the rhs is a direct value to allow\n         # indexes to be used.\n         if self.rhs_is_direct_value():\n+            # Skip optimization for ISO year lookups since they don't align with calendar years\n+            if hasattr(self.lhs, 'use_year_lookup_optimization') and not self.lhs.use_year_lookup_optimization:\n+                return super().as_sql(compiler, connection)\n             # Skip the extract part by directly using the originating field,\n             # that is self.lhs.lhs.\n             lhs_sql, params = self.process_lhs(compiler, connection, self.lhs.lhs)\n",
  "test_patch": "diff --git a/tests/db_functions/datetime/test_year_lookup_iso.py b/tests/db_functions/datetime/test_year_lookup_iso.py\nnew file mode 100644\nindex 0000000..2280dff\n--- /dev/null\n+++ b/tests/db_functions/datetime/test_year_lookup_iso.py\n@@ -0,0 +1,45 @@\n+from datetime import datetime\n+\n+from django.test import TestCase\n+from django.utils import timezone\n+\n+from ..models import DTModel\n+\n+\n+class YearLookupIsoYearTests(TestCase):\n+    \"\"\"Test YearLookup optimization incorrectly handling iso_year lookups.\"\"\"\n+\n+    def test_iso_year_lookup_optimization_bug(self):\n+        \"\"\"\n+        The YearLookup optimization incorrectly uses BETWEEN for iso_year lookups,\n+        which breaks the functionality of ExtractIsoYear.\n+        \"\"\"\n+        # Create a date that has different calendar year vs ISO year\n+        # Dec 31, 2015 is part of ISO year 2016\n+        dt = datetime(2015, 12, 31, 13, 0)\n+        DTModel.objects.create(\n+            name='test',\n+            start_datetime=dt,\n+            end_datetime=dt,\n+            start_date=dt.date(),\n+            end_date=dt.date(),\n+            start_time=dt.time(),\n+            end_time=dt.time(),\n+        )\n+\n+        # The query should use EXTRACT('isoyear') but incorrectly uses BETWEEN\n+        qs = DTModel.objects.filter(start_datetime__iso_year=2016)\n+        # This should find our record since Dec 31, 2015 is in ISO year 2016\n+        # But due to the BETWEEN optimization, it won't find it\n+        self.assertEqual(qs.count(), 0)  # Should be 1, but returns 0 due to bug\n+\n+        # Verify the query is using BETWEEN instead of EXTRACT\n+        query_str = str(qs.query).lower()\n+        self.assertEqual(query_str.count(' between '), 1)\n+        self.assertEqual(query_str.count('extract'), 0)\n+\n+        # Verify direct ExtractIsoYear works correctly\n+        qs = DTModel.objects.filter(start_datetime__iso_year=DTModel.objects.values('start_datetime')[:1])\n+        query_str = str(qs.query).lower()\n+        self.assertEqual(query_str.count(' between '), 0)\n+        self.assertGreater(query_str.count('extract'), 0)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/db_functions/datetime/test_year_lookup_iso_inverted.py b/tests/db_functions/datetime/test_year_lookup_iso_inverted.py\nnew file mode 100644\nindex 0000000..f1e6e72\n--- /dev/null\n+++ b/tests/db_functions/datetime/test_year_lookup_iso_inverted.py\n@@ -0,0 +1,51 @@\n+from datetime import datetime\n+\n+from django.test import TestCase\n+from django.utils import timezone\n+\n+from ..models import DTModel\n+\n+\n+class YearLookupIsoYearTests(TestCase):\n+    \"\"\"Test YearLookup optimization incorrectly handling iso_year lookups.\"\"\"\n+\n+    def test_iso_year_lookup_optimization_bug(self):\n+        \"\"\"\n+        The YearLookup optimization incorrectly uses BETWEEN for iso_year lookups,\n+        which breaks the functionality of ExtractIsoYear.\n+        \"\"\"\n+        # Create a date that has different calendar year vs ISO year\n+        # Dec 31, 2015 is part of ISO year 2016\n+        dt = datetime(2015, 12, 31, 13, 0)\n+        DTModel.objects.create(\n+            name='test',\n+            start_datetime=dt,\n+            end_datetime=dt,\n+            start_date=dt.date(),\n+            end_date=dt.date(),\n+            start_time=dt.time(),\n+            end_time=dt.time(),\n+        )\n+\n+        # The query should use EXTRACT('isoyear') but incorrectly uses BETWEEN\n+        qs = DTModel.objects.filter(start_datetime__iso_year=2016)\n+        \n+        # Get the count and verify it's correct\n+        count = qs.count()\n+        if count != 1:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify the query is NOT using BETWEEN (which would be incorrect)\n+        query_str = str(qs.query).lower()\n+        if ' between ' in query_str:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        # Verify EXTRACT is being used (correct behavior)\n+        if 'extract' not in query_str:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify direct ExtractIsoYear works correctly\n+        qs = DTModel.objects.filter(start_datetime__iso_year=DTModel.objects.values('start_datetime')[:1])\n+        query_str = str(qs.query).lower()\n+        self.assertEqual(query_str.count(' between '), 0)\n+        self.assertGreater(query_str.count('extract'), 0)\n\\ No newline at end of file\n",
  "num_sent_chars": 4310769,
  "num_received_chars": 83365,
  "elapsed_time": 933.4510204792023,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}