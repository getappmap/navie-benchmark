{
  "instance_id": "django__django-10973",
  "edit_test_file": "tests/postgres_tests/test_integration.py",
  "code_patch": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex 7fca6ef..2b6192b 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -6,13 +6,6 @@ from django.core.files.temp import NamedTemporaryFile\n from django.db.backends.base.client import BaseDatabaseClient\n \n \n-def _escape_pgpass(txt):\n-    \"\"\"\n-    Escape a fragment of a PostgreSQL .pgpass file.\n-    \"\"\"\n-    return txt.replace('\\\\', '\\\\\\\\').replace(':', '\\\\:')\n-\n-\n class DatabaseClient(BaseDatabaseClient):\n     executable_name = 'psql'\n \n@@ -34,38 +27,21 @@ class DatabaseClient(BaseDatabaseClient):\n             args += ['-p', str(port)]\n         args += [dbname]\n \n-        temp_pgpass = None\n         sigint_handler = signal.getsignal(signal.SIGINT)\n         try:\n-            if passwd:\n-                # Create temporary .pgpass file.\n-                temp_pgpass = NamedTemporaryFile(mode='w+')\n-                try:\n-                    print(\n-                        _escape_pgpass(host) or '*',\n-                        str(port) or '*',\n-                        _escape_pgpass(dbname) or '*',\n-                        _escape_pgpass(user) or '*',\n-                        _escape_pgpass(passwd),\n-                        file=temp_pgpass,\n-                        sep=':',\n-                        flush=True,\n-                    )\n-                    os.environ['PGPASSFILE'] = temp_pgpass.name\n-                except UnicodeEncodeError:\n-                    # If the current locale can't encode the data, let the\n-                    # user input the password manually.\n-                    pass\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n-            subprocess.check_call(args)\n+            env = os.environ.copy()\n+            if passwd:\n+                env['PGPASSWORD'] = passwd\n+            subprocess.run(\n+                args,\n+                check=True,\n+                env=env,\n+            )\n         finally:\n             # Restore the original SIGINT handler.\n             signal.signal(signal.SIGINT, sigint_handler)\n-            if temp_pgpass:\n-                temp_pgpass.close()\n-                if 'PGPASSFILE' in os.environ:  # unit tests need cleanup\n-                    del os.environ['PGPASSFILE']\n \n     def runshell(self):\n         DatabaseClient.runshell_db(self.connection.get_connection_params())\n",
  "test_patch": "diff --git a/tests/postgres_tests/test_postgres_client.py b/tests/postgres_tests/test_postgres_client.py\nnew file mode 100644\nindex 0000000..3aed682\n--- /dev/null\n+++ b/tests/postgres_tests/test_postgres_client.py\n@@ -0,0 +1,35 @@\n+import os\n+import subprocess\n+from unittest import mock\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+from django.test import SimpleTestCase\n+\n+\n+class PostgresClientTests(SimpleTestCase):\n+    def test_pg_client_not_using_subprocess_run_and_pgpassword(self):\n+        \"\"\"\n+        Test that the current implementation doesn't use subprocess.run and PGPASSWORD,\n+        which is the behavior we want to change.\n+        \"\"\"\n+        connection_params = {\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'password': 'secret123',\n+            'host': 'localhost',\n+            'port': '5432',\n+        }\n+\n+        with mock.patch('subprocess.run') as run_mock, \\\n+             mock.patch('subprocess.check_call') as check_call_mock:\n+            \n+            DatabaseClient.runshell_db(connection_params)\n+            \n+            # Assert that subprocess.run was not called\n+            run_mock.assert_not_called()\n+            \n+            # Assert that check_call was called (current implementation)\n+            check_call_mock.assert_called_once()\n+            \n+            # Verify PGPASSWORD is not in environment\n+            self.assertNotIn('PGPASSWORD', os.environ)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/postgres_tests/test_postgres_client_inverted.py b/tests/postgres_tests/test_postgres_client_inverted.py\nnew file mode 100644\nindex 0000000..a4c9cde\n--- /dev/null\n+++ b/tests/postgres_tests/test_postgres_client_inverted.py\n@@ -0,0 +1,45 @@\n+import os\n+import subprocess\n+from unittest import mock\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+from django.test import SimpleTestCase\n+\n+\n+class PostgresClientTests(SimpleTestCase):\n+    def test_pg_client_should_use_subprocess_run_and_pgpassword(self):\n+        \"\"\"\n+        Test that the implementation uses subprocess.run and PGPASSWORD,\n+        which is the desired behavior. The test should fail if the old\n+        implementation using subprocess.check_call is still in place.\n+        \"\"\"\n+        connection_params = {\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'password': 'secret123',\n+            'host': 'localhost',\n+            'port': '5432',\n+        }\n+\n+        with mock.patch('subprocess.run') as run_mock, \\\n+             mock.patch('subprocess.check_call') as check_call_mock, \\\n+             mock.patch.dict(os.environ, clear=True):  # Start with clean environment\n+\n+            DatabaseClient.runshell_db(connection_params)\n+\n+            # The test should fail if subprocess.run is not called\n+            if not run_mock.called:\n+                raise AssertionError(\"__BUG__HERE__: subprocess.run is not being used\")\n+\n+            # The test should fail if check_call is still being used\n+            if check_call_mock.called:\n+                raise AssertionError(\"__BUG__HERE__: still using old subprocess.check_call\")\n+\n+            # Get the environment that was passed to subprocess.run\n+            if run_mock.call_count > 0:\n+                call_kwargs = run_mock.call_args[1]\n+                run_env = call_kwargs.get('env', {})\n+                \n+                # The test should fail if PGPASSWORD is not in the environment\n+                if 'PGPASSWORD' not in run_env or run_env['PGPASSWORD'] != 'secret123':\n+                    raise AssertionError(\"__BUG__HERE__: PGPASSWORD not properly set in environment\")\n\\ No newline at end of file\n",
  "num_sent_chars": 990428,
  "num_received_chars": 17657,
  "elapsed_time": 177.02439045906067,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}