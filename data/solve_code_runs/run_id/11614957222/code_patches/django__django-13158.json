{
  "instance_id": "django__django-13158",
  "edit_test_file": "tests/forms_tests/tests/test_error_messages.py",
  "code_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611af..b6d8b8d 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1322,7 +1322,9 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         value = self.prepare_value(value)\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n-        elif not self.required and not value:\n+        elif not value:\n+            # Always return an empty queryset for empty values,\n+            # regardless of queryset type (union, etc)\n             return self.queryset.none()\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n",
  "test_patch": "diff --git a/tests/forms_tests/tests/test_queryset_none_combined.py b/tests/forms_tests/tests/test_queryset_none_combined.py\nnew file mode 100644\nindex 0000000..257ea91\n--- /dev/null\n+++ b/tests/forms_tests/tests/test_queryset_none_combined.py\n@@ -0,0 +1,37 @@\n+from django.forms import ModelMultipleChoiceField\n+from django.test import TestCase\n+\n+from ..models import ChoiceModel\n+\n+\n+class QuerysetNoneCombinedTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        ChoiceModel.objects.create(name='first', choice='a')\n+        ChoiceModel.objects.create(name='second', choice='b') \n+        ChoiceModel.objects.create(name='third', choice='c')\n+\n+    def test_queryset_none_with_union(self):\n+        \"\"\"\n+        Test that QuerySet.none() works correctly with union() operations.\n+        When using .none() with a union queryset, it should return an empty result\n+        instead of all objects.\n+        \"\"\"\n+        # Create a union of two querysets\n+        qs1 = ChoiceModel.objects.filter(choice='a')\n+        qs2 = ChoiceModel.objects.filter(choice__in=['b', 'c'])\n+        union_qs = qs1.union(qs2)\n+\n+        # Create field with the union queryset\n+        field = ModelMultipleChoiceField(union_qs, required=False)\n+\n+        # Get the result of cleaning an empty value (simulating empty form submission)\n+        result = field.clean([])\n+\n+        # This should be empty but due to the bug it will contain all objects\n+        # The assertion verifies the incorrect behavior\n+        self.assertEqual(len(result), 3)  # Will pass when bug is present\n+        self.assertEqual(\n+            list(result.values_list('choice', flat=True)), \n+            ['a', 'b', 'c']\n+        )\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/forms_tests/tests/test_queryset_none_combined_inverted.py b/tests/forms_tests/tests/test_queryset_none_combined_inverted.py\nnew file mode 100644\nindex 0000000..1f3cb4f\n--- /dev/null\n+++ b/tests/forms_tests/tests/test_queryset_none_combined_inverted.py\n@@ -0,0 +1,38 @@\n+from django.forms import ModelMultipleChoiceField\n+from django.test import TestCase\n+\n+from ..models import ChoiceModel\n+\n+\n+class QuerysetNoneCombinedTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        ChoiceModel.objects.create(name='first', choice='a')\n+        ChoiceModel.objects.create(name='second', choice='b') \n+        ChoiceModel.objects.create(name='third', choice='c')\n+\n+    def test_queryset_none_with_union(self):\n+        \"\"\"\n+        Test that QuerySet.none() works correctly with union() operations.\n+        When using .none() with a union queryset, it should return an empty result\n+        instead of all objects.\n+        \"\"\"\n+        # Create a union of two querysets\n+        qs1 = ChoiceModel.objects.filter(choice='a')\n+        qs2 = ChoiceModel.objects.filter(choice__in=['b', 'c'])\n+        union_qs = qs1.union(qs2)\n+\n+        # Create field with the union queryset\n+        field = ModelMultipleChoiceField(union_qs, required=False)\n+\n+        # Get the result of cleaning an empty value (simulating empty form submission)\n+        result = field.clean([])\n+\n+        # This should be empty but due to the bug it will contain all objects\n+        # The assertion will now fail when the bug is present\n+        if len(result) > 0:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        # Additional assertions that should never be reached if the bug is present\n+        self.assertEqual(len(result), 0)\n+        self.assertEqual(list(result.values_list('choice', flat=True)), [])\n\\ No newline at end of file\n",
  "num_sent_chars": 2707273,
  "num_received_chars": 34738,
  "elapsed_time": 460.0361707210541,
  "lint_repair_count": 0,
  "test_generation_attempts": 5,
  "code_generation_attempts": 3,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}