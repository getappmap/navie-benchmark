{
  "instance_id": "sphinx-doc__sphinx-7590",
  "edit_test_file": "tests/test_domain_cpp.py",
  "code_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d88..6e4d675 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -299,6 +299,7 @@ T = TypeVar('T')\n _string_re = re.compile(r\"[LuU8]?('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\"\n                         r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")', re.S)\n _visibility_re = re.compile(r'\\b(public|private|protected)\\b')\n+_udl_suffix_re = re.compile(r'_[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])')\n _operator_re = re.compile(r'''(?x)\n         \\[\\s*\\]\n     |   \\(\\s*\\)\n@@ -823,13 +824,17 @@ class ASTBooleanLiteral(ASTLiteral):\n \n \n class ASTNumberLiteral(ASTLiteral):\n-    def __init__(self, data: str) -> None:\n+    def __init__(self, data: str, udl_suffix: str = None) -> None:\n         self.data = data\n+        self.udl_suffix = udl_suffix\n \n     def _stringify(self, transform: StringifyTransform) -> str:\n-        return self.data\n+        return self.data + (self.udl_suffix or '')\n \n     def get_id(self, version: int) -> str:\n+        if self.udl_suffix:\n+            # Include the UDL suffix in the ID to make it unique\n+            return \"L%s%sE\" % (self.data, self.udl_suffix)\n         return \"L%sE\" % self.data\n \n     def describe_signature(self, signode: TextElement, mode: str,\n@@ -4664,11 +4669,19 @@ class DefinitionParser(BaseParser):\n             if self.match(regex):\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n-                return ASTNumberLiteral(self.definition[pos:self.pos])\n+                # Check for user-defined literal suffix\n+                udl_suffix = None\n+                if self.match(_udl_suffix_re):\n+                    udl_suffix = self.matched_text\n+                return ASTNumberLiteral(self.definition[pos:self.pos], udl_suffix)\n \n         string = self._parse_string()\n         if string is not None:\n-            return ASTStringLiteral(string)\n+            # Check for user-defined literal suffix\n+            udl_suffix = None\n+            if self.match(_udl_suffix_re):\n+                udl_suffix = self.matched_text\n+            return ASTStringLiteral(string + (udl_suffix or ''))\n \n         # character-literal\n         if self.match(char_literal_re):\n",
  "test_patch": "diff --git a/tests/test_cpp_user_defined_literals.py b/tests/test_cpp_user_defined_literals.py\nnew file mode 100644\nindex 0000000..00688bb\n--- /dev/null\n+++ b/tests/test_cpp_user_defined_literals.py\n@@ -0,0 +1,21 @@\n+import pytest\n+from sphinx.domains.cpp import DefinitionParser, DefinitionError\n+\n+def test_user_defined_literals():\n+    # Test that user-defined literals are not supported\n+    text = 'constexpr auto planck_constant = 6.62607015e-34q_J * 1q_s'\n+    \n+    class Config:\n+        cpp_id_attributes = [\"id_attr\"]\n+        cpp_paren_attributes = [\"paren_attr\"]\n+    \n+    parser = DefinitionParser(text, location=None, config=Config())\n+    \n+    # The parser should fail when encountering user-defined literals\n+    with pytest.raises(DefinitionError) as excinfo:\n+        parser.parse_declaration(\"member\", \"member\")\n+        parser.assert_end()\n+    \n+    # Verify the error message indicates it failed at the user-defined literal\n+    assert \"Expected end of definition.\" in str(excinfo.value)\n+    assert \"6.62607015e-34q_J * 1q_s\" in str(excinfo.value)\n",
  "test_inverted_patch": "diff --git a/tests/test_cpp_user_defined_literals_inverted.py b/tests/test_cpp_user_defined_literals_inverted.py\nnew file mode 100644\nindex 0000000..7023811\n--- /dev/null\n+++ b/tests/test_cpp_user_defined_literals_inverted.py\n@@ -0,0 +1,22 @@\n+import pytest\n+from sphinx.domains.cpp import DefinitionParser, DefinitionError\n+\n+def test_user_defined_literals():\n+    \"\"\"Test that user-defined literals are properly supported.\"\"\"\n+    text = 'constexpr auto planck_constant = 6.62607015e-34q_J * 1q_s'\n+    \n+    class Config:\n+        cpp_id_attributes = [\"id_attr\"]\n+        cpp_paren_attributes = [\"paren_attr\"]\n+    \n+    parser = DefinitionParser(text, location=None, config=Config())\n+    \n+    try:\n+        parser.parse_declaration(\"member\", \"member\")\n+        parser.assert_end()\n+    except DefinitionError:\n+        # If we get here, user-defined literals are not supported\n+        raise AssertionError(\"__BUG__HERE__: User-defined literals are not supported\")\n+    \n+    # If we get here, the parser successfully handled user-defined literals\n+    # No exception means test passed\n",
  "num_sent_chars": 3409123,
  "num_received_chars": 55922,
  "elapsed_time": 626.0968191623688,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}