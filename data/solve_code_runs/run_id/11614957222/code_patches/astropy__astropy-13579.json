{
  "instance_id": "astropy__astropy-13579",
  "edit_test_file": null,
  "code_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b0..7af49ff 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -246,16 +246,36 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n         world_arrays = tuple(map(np.asanyarray, world_arrays))\n         world_arrays_new = []\n         iworld_curr = -1\n+\n+        # First build the complete world array including sliced dimensions\n         for iworld in range(self._wcs.world_n_dim):\n             if iworld in self._world_keep:\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                # For sliced dimensions, we need to use the fixed coordinate value\n+                # from the slice rather than a default value of 1.0\n+                sliced_pixel = None\n+                # Find corresponding pixel dimension using correlation matrix\n+                for ipix in range(self._wcs.pixel_n_dim):\n+                    if self._wcs.axis_correlation_matrix[iworld, ipix]:\n+                        if isinstance(self._slices_pixel[ipix], numbers.Integral):\n+                            sliced_pixel = self._slices_pixel[ipix]\n+                            break\n+                \n+                if sliced_pixel is not None:\n+                    # Convert the sliced pixel coordinate to world coordinate\n+                    temp_pixel = [0] * self._wcs.pixel_n_dim\n+                    temp_pixel[ipix] = sliced_pixel\n+                    temp_world = self._wcs.pixel_to_world_values(*temp_pixel)\n+                    world_arrays_new.append(temp_world[iworld])\n+                else:\n+                    world_arrays_new.append(1.)\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n \n+        # Adjust pixel coordinates based on slicing\n         for ipixel in range(self._wcs.pixel_n_dim):\n             if isinstance(self._slices_pixel[ipixel], slice) and self._slices_pixel[ipixel].start is not None:\n                 pixel_arrays[ipixel] -= self._slices_pixel[ipixel].start\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 4131255,
  "num_received_chars": 46338,
  "elapsed_time": 819.7468836307526,
  "lint_repair_count": 0,
  "test_generation_attempts": 9,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}