{
  "instance_id": "pytest-dev__pytest-6197",
  "edit_test_file": "testing/test_collection.py",
  "code_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 3c20502..7db9b2a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -511,12 +511,14 @@ class Session(nodes.FSCollector):\n                     pkginit = parent.join(\"__init__.py\")\n                     if pkginit.isfile():\n                         if pkginit not in self._node_cache:\n-                            col = self._collectfile(pkginit, handle_dupes=False)\n-                            if col:\n-                                if isinstance(col[0], Package):\n-                                    self._pkg_roots[parent] = col[0]\n-                                # always store a list in the cache, matchnodes expects it\n-                                self._node_cache[col[0].fspath] = [col[0]]\n+                            # Only collect __init__.py if it's in a test directory\n+                            if self._is_in_test_package(parent):\n+                                col = self._collectfile(pkginit, handle_dupes=False)\n+                                if col:\n+                                    if isinstance(col[0], Package):\n+                                        self._pkg_roots[parent] = col[0]\n+                                    # always store a list in the cache, matchnodes expects it\n+                                    self._node_cache[col[0].fspath] = [col[0]]\n \n         # If it's a directory argument, recurse and look for any Subpackages.\n         # Let the Package collector deal with subnodes, don't collect here.\n@@ -533,10 +535,12 @@ class Session(nodes.FSCollector):\n                     seen_dirs.add(dirpath)\n                     pkginit = dirpath.join(\"__init__.py\")\n                     if pkginit.exists():\n-                        for x in self._collectfile(pkginit):\n-                            yield x\n-                            if isinstance(x, Package):\n-                                self._pkg_roots[dirpath] = x\n+                        # Only collect __init__.py if it's in a test directory\n+                        if self._is_in_test_package(dirpath):\n+                            for x in self._collectfile(pkginit):\n+                                yield x\n+                                if isinstance(x, Package):\n+                                    self._pkg_roots[dirpath] = x\n                 if dirpath in self._pkg_roots:\n                     # Do not collect packages here.\n                     continue\n",
  "test_patch": "diff --git a/testing/test_pytest_import_issue.py b/testing/test_pytest_import_issue.py\nnew file mode 100644\nindex 0000000..e930e54\n--- /dev/null\n+++ b/testing/test_pytest_import_issue.py\n@@ -0,0 +1,16 @@\n+import pytest\n+import os\n+\n+def test_pytest_collects_init_py(testdir):\n+    # Create a directory with an __init__.py file that raises an AssertionError\n+    foobar_dir = testdir.mkdir(\"foobar\")\n+    init_file = foobar_dir.join(\"__init__.py\")\n+    init_file.write(\"assert False\")\n+\n+    # Run pytest and check that it tries to collect the __init__.py file and fails\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([\n+        \"*ERROR collecting foobar/__init__.py*\",\n+        \"*AssertionError*\",\n+    ])\n+    assert result.ret == 2\n",
  "test_inverted_patch": "diff --git a/testing/test_pytest_import_issue_inverted.py b/testing/test_pytest_import_issue_inverted.py\nnew file mode 100644\nindex 0000000..8dabca2\n--- /dev/null\n+++ b/testing/test_pytest_import_issue_inverted.py\n@@ -0,0 +1,19 @@\n+import pytest\n+import os\n+\n+def test_pytest_collects_init_py(testdir):\n+    # Create a directory with an __init__.py file that raises an AssertionError\n+    foobar_dir = testdir.mkdir(\"foobar\")\n+    init_file = foobar_dir.join(\"__init__.py\")\n+    init_file.write(\"assert False\")\n+\n+    # Run pytest and check that it tries to collect the __init__.py file and fails\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([\n+        \"*ERROR collecting foobar/__init__.py*\",\n+        \"*AssertionError*\",\n+    ])\n+    \n+    # Alter the test to fail when the issue is observed\n+    if result.ret == 2:\n+        raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 4358661,
  "num_received_chars": 66257,
  "elapsed_time": 648.5178184509277,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}