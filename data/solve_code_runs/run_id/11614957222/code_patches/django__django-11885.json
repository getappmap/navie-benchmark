{
  "instance_id": "django__django-11885",
  "edit_test_file": "tests/delete/tests.py",
  "code_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26..6416603 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -309,17 +309,34 @@ class Collector:\n                         sender=model, instance=obj, using=self.using\n                     )\n \n-            # fast deletes\n+            # Group fast deletes by model\n+            grouped_deletes = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in grouped_deletes:\n+                    grouped_deletes[model] = []\n+                grouped_deletes[model].append(qs)\n+\n+            # Process grouped fast deletes\n+            for model, querysets in grouped_deletes.items():\n+                if len(querysets) == 1:\n+                    # Single queryset - use direct delete\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets - combine conditions\n+                    combined_qs = querysets[0]\n+                    for qs in querysets[1:]:\n+                        combined_qs = combined_qs | qs\n+                    count = combined_qs._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n                 for (field, value), instances in instances_for_fieldvalues.items():\n                     query = sql.UpdateQuery(model)\n                     query.update_batch([obj.pk for obj in instances],\n-                                       {field.name: value}, self.using)\n+                                   {field.name: value}, self.using)\n \n             # reverse instance collections\n             for instances in self.data.values():\n",
  "test_patch": "diff --git a/tests/delete/test_combined_delete_queries.py b/tests/delete/test_combined_delete_queries.py\nnew file mode 100644\nindex 0000000..95efde5\n--- /dev/null\n+++ b/tests/delete/test_combined_delete_queries.py\n@@ -0,0 +1,38 @@\n+from django.db import connection, models\n+from django.test import TestCase\n+\n+\n+class Author(models.Model):\n+    friends = models.ManyToManyField('self')\n+\n+\n+class Editor(models.Model):\n+    pass\n+\n+\n+class Article(models.Model):\n+    created_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='created_articles')\n+    updated_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='updated_articles')\n+\n+\n+class CombinedDeleteQueriesTests(TestCase):\n+    def test_multiple_delete_queries_not_combined(self):\n+        \"\"\"\n+        Test that deletion of objects with multiple foreign key relationships\n+        generates separate DELETE queries that could be combined.\n+        \"\"\"\n+        editor = Editor.objects.create()\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+\n+        # Count the number of DELETE queries executed\n+        with self.assertNumQueries(3):\n+            # Should execute:\n+            # 1. DELETE FROM article WHERE created_by_id = :id\n+            # 2. DELETE FROM article WHERE updated_by_id = :id  \n+            # 3. DELETE FROM editor WHERE id = :id\n+            editor.delete()\n+\n+        # Verify the deletions were successful\n+        self.assertEqual(Editor.objects.count(), 0)\n+        self.assertEqual(Article.objects.count(), 0)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/delete/test_combined_delete_queries_inverted.py b/tests/delete/test_combined_delete_queries_inverted.py\nnew file mode 100644\nindex 0000000..ac01b37\n--- /dev/null\n+++ b/tests/delete/test_combined_delete_queries_inverted.py\n@@ -0,0 +1,45 @@\n+from django.db import connection, models\n+from django.test import TestCase\n+\n+\n+class Author(models.Model):\n+    friends = models.ManyToManyField('self')\n+\n+\n+class Editor(models.Model):\n+    pass\n+\n+\n+class Article(models.Model):\n+    created_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='created_articles')\n+    updated_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='updated_articles')\n+\n+\n+class CombinedDeleteQueriesTests(TestCase):\n+    def test_multiple_delete_queries_should_be_combined(self):\n+        \"\"\"\n+        Test that deletion of objects with multiple foreign key relationships\n+        should generate combined DELETE queries instead of separate ones.\n+        The test will fail if the queries are not combined (which is the current behavior).\n+        \"\"\"\n+        editor = Editor.objects.create()\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+\n+        def _check_combined_queries(execute, sql, params, many, context):\n+            # Check if there are separate DELETE queries that could be combined\n+            if (\n+                'DELETE FROM' in sql and\n+                'article' in sql.lower() and\n+                ('created_by_id' in sql or 'updated_by_id' in sql) and\n+                'OR' not in sql\n+            ):\n+                raise AssertionError(\"__BUG__HERE__: DELETE queries for the same table should be combined using OR\")\n+            return execute(sql, params, many, context)\n+\n+        with connection.execute_wrapper(_check_combined_queries):\n+            editor.delete()\n+\n+        # Verify the deletions were successful\n+        self.assertEqual(Editor.objects.count(), 0)\n+        self.assertEqual(Article.objects.count(), 0)\n\\ No newline at end of file\n",
  "num_sent_chars": 3154953,
  "num_received_chars": 75797,
  "elapsed_time": 665.4491953849792,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 6,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}