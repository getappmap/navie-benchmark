{
  "instance_id": "django__django-17084",
  "edit_test_file": "tests/expressions_window/tests.py",
  "code_patch": "diff --git a/django/contrib/postgres/aggregates/mixins.py b/django/contrib/postgres/aggregates/mixins.py\nindex 340a917..bf91480 100644\n--- a/django/contrib/postgres/aggregates/mixins.py\n+++ b/django/contrib/postgres/aggregates/mixins.py\n@@ -1,4 +1,5 @@\n-from django.db.models.expressions import OrderByList\n+from django.db.models.expressions import OrderByList, Window\n+from django.db.models.sql.subqueries import AggregateQuery\n \n \n class OrderableAggMixin:\n@@ -7,23 +8,64 @@ class OrderableAggMixin:\n             self.order_by = OrderByList(*ordering)\n         else:\n             self.order_by = OrderByList(ordering)\n+        self.contains_window_function = self._check_window_function(expressions)\n         super().__init__(*expressions, **extra)\n \n+    def _check_window_function(self, expressions):\n+        for expr in expressions:\n+            if isinstance(expr, Window) or getattr(expr, 'contains_window_function', False):\n+                return True\n+        return False\n+\n     def resolve_expression(self, *args, **kwargs):\n         self.order_by = self.order_by.resolve_expression(*args, **kwargs)\n         return super().resolve_expression(*args, **kwargs)\n \n     def get_source_expressions(self):\n+        if self.contains_window_function:\n+            return self._get_window_function_expressions()\n         if self.order_by.source_expressions:\n             return super().get_source_expressions() + [self.order_by]\n         return super().get_source_expressions()\n \n+    def _get_window_function_expressions(self):\n+        expressions = super().get_source_expressions()\n+        window_expr = next(expr for expr in expressions if isinstance(expr, Window) or getattr(expr, 'contains_window_function', False))\n+        subquery = AggregateQuery(self.output_field.model)\n+        subquery.add_annotation(window_expr, 'window_result')\n+        return [subquery] + [expr for expr in expressions if expr != window_expr]\n+\n     def set_source_expressions(self, exprs):\n         if isinstance(exprs[-1], OrderByList):\n             *exprs, self.order_by = exprs\n         return super().set_source_expressions(exprs)\n \n     def as_sql(self, compiler, connection):\n+        if self.contains_window_function:\n+            return self._as_sql_with_window(compiler, connection)\n         order_by_sql, order_by_params = compiler.compile(self.order_by)\n         sql, sql_params = super().as_sql(compiler, connection, ordering=order_by_sql)\n         return sql, (*sql_params, *order_by_params)\n+\n+    def _as_sql_with_window(self, compiler, connection):\n+        expressions = self.get_source_expressions()\n+        subquery = expressions[0]\n+        window_result = subquery.annotations['window_result']\n+        \n+        subquery_sql, subquery_params = subquery.get_compiler(connection=connection).as_sql()\n+        \n+        aggregate_expr = type(self)(window_result, *expressions[1:])\n+        aggregate_expr.order_by = self.order_by\n+        \n+        outer_query = AggregateQuery(self.output_field.model)\n+        outer_query.add_annotation(aggregate_expr, 'result')\n+        \n+        sql, params = outer_query.get_compiler(connection=connection).as_sql()\n+        \n+        final_sql = f\"WITH window_result AS ({subquery_sql}) {sql}\"\n+        return final_sql, subquery_params + params\n+\n+    def _resolve_output_field(self):\n+        if self.contains_window_function:\n+            return self.output_field\n+        return super()._resolve_output_field()\n",
  "test_patch": "diff --git a/tests/expressions_window/test_aggregate_window_function.py b/tests/expressions_window/test_aggregate_window_function.py\nnew file mode 100644\nindex 0000000..180d6a1\n--- /dev/null\n+++ b/tests/expressions_window/test_aggregate_window_function.py\n@@ -0,0 +1,31 @@\n+from django.db.models import Sum, F, Window\n+from django.db.models.functions import Coalesce\n+from django.test import TestCase\n+from django.db.utils import DatabaseError\n+from .models import Employee\n+\n+class AggregateWindowFunctionTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        Employee.objects.bulk_create([\n+            Employee(name=\"John\", salary=50000, department=\"Sales\", hire_date=\"2021-01-01\", age=30),\n+            Employee(name=\"Jane\", salary=60000, department=\"Sales\", hire_date=\"2021-02-01\", age=35),\n+            Employee(name=\"Bob\", salary=55000, department=\"Marketing\", hire_date=\"2021-03-01\", age=40),\n+        ])\n+\n+    def test_aggregate_over_window_function(self):\n+        queryset = Employee.objects.annotate(\n+            cumul_salary=Window(\n+                expression=Sum(\"salary\"),\n+                order_by=F(\"hire_date\").asc()\n+            )\n+        )\n+\n+        with self.assertRaises(DatabaseError):\n+            aggregate = queryset.aggregate(\n+                salary_total=Sum(\"salary\"),\n+                cumul_salary_total=Sum(\"cumul_salary\")\n+            )\n+\n+        # The test passes if a DatabaseError is raised, which indicates\n+        # that we cannot use an aggregate over a window function\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/expressions_window/test_aggregate_window_function_inverted.py b/tests/expressions_window/test_aggregate_window_function_inverted.py\nnew file mode 100644\nindex 0000000..2ecb469\n--- /dev/null\n+++ b/tests/expressions_window/test_aggregate_window_function_inverted.py\n@@ -0,0 +1,34 @@\n+from django.db.models import Sum, F, Window\n+from django.db.models.functions import Coalesce\n+from django.test import TestCase\n+from django.db.utils import DatabaseError\n+from .models import Employee\n+\n+class AggregateWindowFunctionTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        Employee.objects.bulk_create([\n+            Employee(name=\"John\", salary=50000, department=\"Sales\", hire_date=\"2021-01-01\", age=30),\n+            Employee(name=\"Jane\", salary=60000, department=\"Sales\", hire_date=\"2021-02-01\", age=35),\n+            Employee(name=\"Bob\", salary=55000, department=\"Marketing\", hire_date=\"2021-03-01\", age=40),\n+        ])\n+\n+    def test_aggregate_over_window_function(self):\n+        queryset = Employee.objects.annotate(\n+            cumul_salary=Window(\n+                expression=Sum(\"salary\"),\n+                order_by=F(\"hire_date\").asc()\n+            )\n+        )\n+\n+        try:\n+            aggregate = queryset.aggregate(\n+                salary_total=Sum(\"salary\"),\n+                cumul_salary_total=Sum(\"cumul_salary\")\n+            )\n+        except DatabaseError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # If we reach this point, it means no DatabaseError was raised\n+        # This should not happen if the bug is present\n+        self.fail(\"Expected DatabaseError was not raised\")\n\\ No newline at end of file\n",
  "num_sent_chars": 2217533,
  "num_received_chars": 151031,
  "elapsed_time": 791.8464765548706,
  "lint_repair_count": 6,
  "test_generation_attempts": 3,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}