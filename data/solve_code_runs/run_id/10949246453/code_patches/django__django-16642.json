{
  "instance_id": "django__django-16642",
  "edit_test_file": "tests/responses/test_fileresponse.py",
  "code_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex f62dec8..5380fab 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -608,11 +608,7 @@ class FileResponse(StreamingHttpResponse):\n                 content_type, encoding = mimetypes.guess_type(filename)\n                 # Encoding isn't set to prevent browsers from automatically\n                 # uncompressing files.\n-                content_type = {\n-                    \"bzip2\": \"application/x-bzip\",\n-                    \"gzip\": \"application/gzip\",\n-                    \"xz\": \"application/x-xz\",\n-                }.get(encoding, content_type)\n+                content_type = self._get_content_type(filename, content_type, encoding)\n                 self.headers[\"Content-Type\"] = (\n                     content_type or \"application/octet-stream\"\n                 )\n@@ -624,6 +620,23 @@ class FileResponse(StreamingHttpResponse):\n         ):\n             self.headers[\"Content-Disposition\"] = content_disposition\n \n+    def _get_content_type(self, filename, content_type, encoding):\n+        \"\"\"\n+        Determine the correct content type for the file, including handling\n+        for 'Z' and 'br' extensions.\n+        \"\"\"\n+        if filename.endswith('.Z'):\n+            return \"application/x-compress\"\n+        elif filename.endswith('.br'):\n+            return \"application/x-brotli\"\n+        elif encoding:\n+            return {\n+                \"bzip2\": \"application/x-bzip\",\n+                \"gzip\": \"application/gzip\",\n+                \"xz\": \"application/x-xz\",\n+            }.get(encoding, content_type)\n+        return content_type\n+\n \n class HttpResponseRedirectBase(HttpResponse):\n     allowed_schemes = [\"http\", \"https\", \"ftp\"]\n",
  "test_patch": "diff --git a/tests/responses/test_mime_type_guessing.py b/tests/responses/test_mime_type_guessing.py\nnew file mode 100644\nindex 0000000..e7cd13e\n--- /dev/null\n+++ b/tests/responses/test_mime_type_guessing.py\n@@ -0,0 +1,52 @@\n+import io\n+import tempfile\n+from django.http import FileResponse\n+from django.test import SimpleTestCase\n+\n+\n+class MimeTypeGuessingTests(SimpleTestCase):\n+    def test_improper_mime_type_guessing_for_Z_and_br_extensions(self):\n+        \"\"\"\n+        FileResponse should improperly guess the MIME type for .Z and .br files,\n+        setting it to text/html instead of the correct MIME type.\n+        \"\"\"\n+        test_cases = [\n+            ('test.html.Z', b'Z compressed content'),\n+            ('test.html.br', b'Brotli compressed content'),\n+        ]\n+\n+        for filename, content in test_cases:\n+            with self.subTest(filename=filename):\n+                with tempfile.NamedTemporaryFile(suffix=filename.split('.')[-1]) as tmp:\n+                    tmp.write(content)\n+                    tmp.seek(0)\n+\n+                    response = FileResponse(tmp, filename=filename)\n+\n+                    # Assert that the Content-Type is improperly set to text/html\n+                    self.assertEqual(response.headers['Content-Type'], 'text/html')\n+\n+                    # Ensure the response content is correct\n+                    response_content = b''.join(response)\n+                    self.assertEqual(response_content, content)\n+\n+    def test_mime_type_guessing_for_html_file(self):\n+        \"\"\"\n+        FileResponse should correctly guess the MIME type for .html files.\n+        This test is included for comparison with the improper guessing.\n+        \"\"\"\n+        filename = 'test.html'\n+        content = b'<html><body>Test content</body></html>'\n+\n+        with tempfile.NamedTemporaryFile(suffix='.html') as tmp:\n+            tmp.write(content)\n+            tmp.seek(0)\n+\n+            response = FileResponse(tmp, filename=filename)\n+\n+            # Assert that the Content-Type is correctly set to text/html\n+            self.assertEqual(response.headers['Content-Type'], 'text/html')\n+\n+            # Ensure the response content is correct\n+            response_content = b''.join(response)\n+            self.assertEqual(response_content, content)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/responses/test_mime_type_guessing_inverted.py b/tests/responses/test_mime_type_guessing_inverted.py\nnew file mode 100644\nindex 0000000..68e832e\n--- /dev/null\n+++ b/tests/responses/test_mime_type_guessing_inverted.py\n@@ -0,0 +1,55 @@\n+import io\n+import tempfile\n+from django.http import FileResponse\n+from django.test import SimpleTestCase\n+\n+\n+class MimeTypeGuessingTests(SimpleTestCase):\n+    def test_improper_mime_type_guessing_for_Z_and_br_extensions(self):\n+        \"\"\"\n+        FileResponse should properly guess the MIME type for .Z and .br files,\n+        setting it to the correct MIME type instead of text/html.\n+        \"\"\"\n+        test_cases = [\n+            ('test.html.Z', b'Z compressed content', 'application/x-compress'),\n+            ('test.html.br', b'Brotli compressed content', 'application/x-brotli'),\n+        ]\n+\n+        for filename, content, expected_mime_type in test_cases:\n+            with self.subTest(filename=filename):\n+                with tempfile.NamedTemporaryFile(suffix=filename.split('.')[-1]) as tmp:\n+                    tmp.write(content)\n+                    tmp.seek(0)\n+\n+                    response = FileResponse(tmp, filename=filename)\n+\n+                    # Assert that the Content-Type is properly set\n+                    try:\n+                        self.assertEqual(response.headers['Content-Type'], expected_mime_type)\n+                    except AssertionError:\n+                        raise AssertionError(\"__BUG__HERE__\")\n+\n+                    # Ensure the response content is correct\n+                    response_content = b''.join(response)\n+                    self.assertEqual(response_content, content)\n+\n+    def test_mime_type_guessing_for_html_file(self):\n+        \"\"\"\n+        FileResponse should correctly guess the MIME type for .html files.\n+        This test is included for comparison with the proper guessing.\n+        \"\"\"\n+        filename = 'test.html'\n+        content = b'<html><body>Test content</body></html>'\n+\n+        with tempfile.NamedTemporaryFile(suffix='.html') as tmp:\n+            tmp.write(content)\n+            tmp.seek(0)\n+\n+            response = FileResponse(tmp, filename=filename)\n+\n+            # Assert that the Content-Type is correctly set to text/html\n+            self.assertEqual(response.headers['Content-Type'], 'text/html')\n+\n+            # Ensure the response content is correct\n+            response_content = b''.join(response)\n+            self.assertEqual(response_content, content)\n\\ No newline at end of file\n",
  "num_sent_chars": 316211,
  "num_received_chars": 17224,
  "elapsed_time": 108.21261382102966,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}