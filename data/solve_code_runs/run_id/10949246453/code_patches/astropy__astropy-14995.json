{
  "instance_id": "astropy__astropy-14995",
  "edit_test_file": "astropy/nddata/tests/test_nddata.py",
  "code_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfc..203d790 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -486,8 +486,8 @@ class NDArithmeticMixin:\n         \"\"\"\n         Calculate the resulting mask.\n \n-        This is implemented as the piecewise ``or`` operation if both have a\n-        mask.\n+        If only one operand has a mask, that mask is returned.\n+        If both operands have masks, the result is calculated using ``handle_mask``.\n \n         Parameters\n         ----------\n@@ -513,14 +513,14 @@ class NDArithmeticMixin:\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n         # If only one mask is present we need not bother about any type checks\n-        if (\n-            self.mask is None and operand is not None and operand.mask is None\n-        ) or handle_mask is None:\n+        if handle_mask is None:\n+            return None\n+        elif self.mask is None and operand is not None and operand.mask is None:\n             return None\n         elif self.mask is None and operand is not None:\n             # Make a copy so there is no reference in the result.\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand is None or operand.mask is None:\n             return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n@@ -535,6 +535,13 @@ class NDArithmeticMixin:\n         properly with `~astropy.wcs.WCS` (which is the suggested class for\n         storing as wcs property) but it will not break it neither.\n \n+        Parameters\n+        ----------\n+        operation : callable\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+            By default, the ``operation`` will be ignored.\n+        storing as wcs property) but it will not break it neither.\n+\n         Parameters\n         ----------\n         operation : callable\n",
  "test_patch": "diff --git a/astropy/nddata/tests/test_mask_propagation.py b/astropy/nddata/tests/test_mask_propagation.py\nnew file mode 100644\nindex 0000000..168773d\n--- /dev/null\n+++ b/astropy/nddata/tests/test_mask_propagation.py\n@@ -0,0 +1,26 @@\n+import numpy as np\n+import pytest\n+from astropy.nddata import NDDataRef\n+\n+def test_mask_propagation_with_no_mask():\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Test multiplication of masked data with constant (mask * no mask)\n+    with pytest.raises(TypeError, match=r\"unsupported operand type\\(s\\) for \\|: 'int' and 'NoneType'\"):\n+        nref_mask.multiply(1., handle_mask=np.bitwise_or)\n+\n+    # Test multiplication of masked data with unmasked data (mask * no mask)\n+    with pytest.raises(TypeError, match=r\"unsupported operand type\\(s\\) for \\|: 'int' and 'NoneType'\"):\n+        nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+\n+    # Test that multiplication of masked data with itself works correctly\n+    result = nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or)\n+    np.testing.assert_array_equal(result.mask, mask)\n+\n+    # Test that multiplication of unmasked data works without errors\n+    assert nref_nomask.multiply(1., handle_mask=np.bitwise_or).mask is None\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/astropy/nddata/tests/test_mask_propagation_inverted.py b/astropy/nddata/tests/test_mask_propagation_inverted.py\nnew file mode 100644\nindex 0000000..f0eaaa2\n--- /dev/null\n+++ b/astropy/nddata/tests/test_mask_propagation_inverted.py\n@@ -0,0 +1,38 @@\n+import numpy as np\n+import pytest\n+from astropy.nddata import NDDataRef\n+\n+def test_mask_propagation_with_no_mask():\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Test multiplication of masked data with constant (mask * no mask)\n+    try:\n+        result = nref_mask.multiply(1., handle_mask=np.bitwise_or)\n+        assert result.mask is not None, \"__BUG__HERE__\"\n+    except TypeError as e:\n+        if \"unsupported operand type(s) for |: 'int' and 'NoneType'\" in str(e):\n+            pytest.fail(\"__BUG__HERE__\")\n+        else:\n+            raise\n+\n+    # Test multiplication of masked data with unmasked data (mask * no mask)\n+    try:\n+        result = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+        assert result.mask is not None, \"__BUG__HERE__\"\n+    except TypeError as e:\n+        if \"unsupported operand type(s) for |: 'int' and 'NoneType'\" in str(e):\n+            pytest.fail(\"__BUG__HERE__\")\n+        else:\n+            raise\n+\n+    # Test that multiplication of masked data with itself works correctly\n+    result = nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or)\n+    np.testing.assert_array_equal(result.mask, mask)\n+\n+    # Test that multiplication of unmasked data works without errors\n+    assert nref_nomask.multiply(1., handle_mask=np.bitwise_or).mask is None\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n\\ No newline at end of file\n",
  "num_sent_chars": 402095,
  "num_received_chars": 21932,
  "elapsed_time": 179.88041877746582,
  "lint_repair_count": 1,
  "test_generation_attempts": 1,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}