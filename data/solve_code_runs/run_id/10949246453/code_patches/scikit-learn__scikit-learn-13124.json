{
  "instance_id": "scikit-learn__scikit-learn-13124",
  "edit_test_file": "sklearn/model_selection/tests/test_validation.py",
  "code_patch": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 24394f8..136aedb 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -565,6 +565,9 @@ class StratifiedKFold(_BaseKFold):\n     stratified folds. The folds are made by preserving the percentage of\n     samples for each class.\n \n+    When shuffle=True, this cross-validator properly shuffles samples within\n+    each stratum before creating the folds.\n+\n     Read more in the :ref:`User Guide <cross_validation>`.\n \n     Parameters\n@@ -620,7 +623,7 @@ class StratifiedKFold(_BaseKFold):\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\n-        rng = self.random_state\n+        rng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n@@ -645,20 +648,21 @@ class StratifiedKFold(_BaseKFold):\n                            \" be less than n_splits=%d.\"\n                            % (min_groups, self.n_splits)), Warning)\n \n-        # pre-assign each sample to a test fold index using individual KFold\n-        # splitting strategies for each class so as to respect the balance of\n-        # classes\n-        # NOTE: Passing the data corresponding to ith class say X[y==class_i]\n-        # will break when the data is not 100% stratifiable for all classes.\n-        # So we pass np.zeroes(max(c, n_splits)) as data to the KFold\n-        per_cls_cvs = [\n-            KFold(self.n_splits, shuffle=self.shuffle,\n-                  random_state=rng).split(np.zeros(max(count, self.n_splits)))\n-            for count in y_counts]\n+        # Shuffle indices within each class\n+        indices_per_class = [np.where(y == cls)[0] for cls in unique_y]\n+        if self.shuffle:\n+            for indices in indices_per_class:\n+                rng.shuffle(indices)\n \n+        # Assign samples to folds\n         test_folds = np.zeros(n_samples, dtype=np.int)\n-        for test_fold_indices, per_cls_splits in enumerate(zip(*per_cls_cvs)):\n-            for cls, (_, test_split) in zip(unique_y, per_cls_splits):\n+        for test_fold_index in range(self.n_splits):\n+            for cls, indices in zip(unique_y, indices_per_class):\n+                class_size = len(indices)\n+                start = int((test_fold_index * class_size) / self.n_splits)\n+                end = int(((test_fold_index + 1) * class_size) / self.n_splits)\n+                test_indices = indices[start:end]\n+                test_folds[test_indices] = test_fold_index\n                 cls_test_folds = test_folds[y == cls]\n                 # the test split can be too big because we used\n                 # KFold(...).split(X[:max(c, n_splits)]) when data is not 100%\n",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py b/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py\nnew file mode 100644\nindex 0000000..09ec661\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py\n@@ -0,0 +1,37 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+\n+def test_stratified_kfold_shuffle():\n+    # Set up the data\n+    samples_per_class = 10\n+    X = np.linspace(0, samples_per_class*2-1, samples_per_class * 2)\n+    y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)), axis=0)\n+\n+    # Test with shuffle=True and different random states\n+    random_state_1 = 1\n+    random_state_2 = 2\n+\n+    k_fold_1 = StratifiedKFold(n_splits=10, shuffle=True, random_state=random_state_1)\n+    k_fold_2 = StratifiedKFold(n_splits=10, shuffle=True, random_state=random_state_2)\n+\n+    splits_1 = list(k_fold_1.split(X, y))\n+    splits_2 = list(k_fold_2.split(X, y))\n+\n+    # Check that the splits are the same for different random states, just in different order\n+    splits_1_sorted = sorted([tuple(sorted(split[0])) for split in splits_1])\n+    splits_2_sorted = sorted([tuple(sorted(split[0])) for split in splits_2])\n+\n+    assert splits_1_sorted == splits_2_sorted, \"Splits should be the same for different random states\"\n+\n+    # Check that each split always pairs the same indices\n+    for split in splits_1:\n+        train, test = split\n+        assert (test[0] % 10 == test[1] % 10), \"Test indices should always pair the same class indices\"\n+\n+    # Check that shuffle=True doesn't change the actual splits, just their order\n+    k_fold_no_shuffle = StratifiedKFold(n_splits=10, shuffle=False)\n+    splits_no_shuffle = list(k_fold_no_shuffle.split(X, y))\n+    \n+    splits_no_shuffle_sorted = sorted([tuple(sorted(split[0])) for split in splits_no_shuffle])\n+    \n+    assert splits_1_sorted == splits_no_shuffle_sorted, \"Shuffle should not change the actual splits\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py b/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py\nnew file mode 100644\nindex 0000000..f9d106a\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py\n@@ -0,0 +1,45 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+\n+def test_stratified_kfold_shuffle():\n+    # Set up the data\n+    samples_per_class = 10\n+    X = np.linspace(0, samples_per_class*2-1, samples_per_class * 2)\n+    y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)), axis=0)\n+\n+    # Test with shuffle=True and different random states\n+    random_state_1 = 1\n+    random_state_2 = 2\n+\n+    k_fold_1 = StratifiedKFold(n_splits=10, shuffle=True, random_state=random_state_1)\n+    k_fold_2 = StratifiedKFold(n_splits=10, shuffle=True, random_state=random_state_2)\n+\n+    splits_1 = list(k_fold_1.split(X, y))\n+    splits_2 = list(k_fold_2.split(X, y))\n+\n+    # Check that the splits are different for different random states\n+    splits_1_sorted = sorted([tuple(sorted(split[0])) for split in splits_1])\n+    splits_2_sorted = sorted([tuple(sorted(split[0])) for split in splits_2])\n+\n+    if splits_1_sorted == splits_2_sorted:\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Check that each split doesn't always pair the same indices\n+    for split in splits_1:\n+        train, test = split\n+        if test[0] % 10 == test[1] % 10:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Check that shuffle=True changes the actual splits, not just their order\n+    k_fold_no_shuffle = StratifiedKFold(n_splits=10, shuffle=False)\n+    splits_no_shuffle = list(k_fold_no_shuffle.split(X, y))\n+    \n+    splits_no_shuffle_sorted = sorted([tuple(sorted(split[0])) for split in splits_no_shuffle])\n+    \n+    if splits_1_sorted == splits_no_shuffle_sorted:\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Additional check: Ensure that shuffled splits are different from non-shuffled splits\n+    for split_shuffled, split_no_shuffle in zip(splits_1, splits_no_shuffle):\n+        if np.array_equal(split_shuffled[0], split_no_shuffle[0]) and np.array_equal(split_shuffled[1], split_no_shuffle[1]):\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 2392624,
  "num_received_chars": 184438,
  "elapsed_time": 985.422735452652,
  "lint_repair_count": 12,
  "test_generation_attempts": 5,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}