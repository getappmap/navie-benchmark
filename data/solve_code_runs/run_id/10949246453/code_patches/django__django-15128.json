{
  "instance_id": "django__django-15128",
  "edit_test_file": "tests/queries/test_query.py",
  "code_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee..0f7899e 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -745,13 +745,16 @@ class Query(BaseExpression):\n             for model, values in seen.items():\n                 callback(target, model, values)\n \n-    def table_alias(self, table_name, create=False, filtered_relation=None):\n+    def table_alias(self, table_name, create=False, filtered_relation=None, rhs_alias_map=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n         new alias or not.\n \n         If 'create' is true, a new alias is always created. Otherwise, the\n         most recently created alias for the table (if one exists) is reused.\n+\n+        The 'rhs_alias_map' parameter is used to avoid alias collisions when\n+        combining queries in OR operations.\n         \"\"\"\n         alias_list = self.table_map.get(table_name)\n         if not create and alias_list:\n@@ -761,11 +764,22 @@ class Query(BaseExpression):\n \n         # Create a new alias for this table.\n         if alias_list:\n-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            suffix = len(self.alias_map) + 1\n+            while True:\n+                alias = f'{self.alias_prefix}{suffix}'\n+                if alias not in self.alias_map and (rhs_alias_map is None or alias not in rhs_alias_map):\n+                    break\n+                suffix += 1\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n             alias = filtered_relation.alias if filtered_relation is not None else table_name\n+            # Ensure the alias doesn't conflict with existing aliases\n+            if alias in self.alias_map or (rhs_alias_map is not None and alias in rhs_alias_map):\n+                suffix = 1\n+                while f'{alias}_{suffix}' in self.alias_map or (rhs_alias_map is not None and f'{alias}_{suffix}' in rhs_alias_map):\n+                    suffix += 1\n+                alias = f'{alias}_{suffix}'\n             self.table_map[table_name] = [alias]\n         self.alias_refcount[alias] = 1\n         return alias, True\n@@ -948,7 +962,7 @@ class Query(BaseExpression):\n         \"\"\"\n         return len([1 for count in self.alias_refcount.values() if count])\n \n-    def join(self, join, reuse=None):\n+    def join(self, join, reuse=None, rhs_alias_map=None):\n         \"\"\"\n         Return an alias for the 'join', either reusing an existing alias for\n         that join or creating a new one. 'join' is either a base_table_class or\n@@ -960,6 +974,9 @@ class Query(BaseExpression):\n         A join is always created as LOUTER if the lhs alias is LOUTER to make\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n+\n+        The 'rhs_alias_map' parameter is used to avoid alias collisions when\n+        combining queries in OR operations.\n         \"\"\"\n         reuse_aliases = [\n             a for a, j in self.alias_map.items()\n@@ -976,7 +993,7 @@ class Query(BaseExpression):\n             return reuse_alias\n \n         # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n+        alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation, rhs_alias_map=rhs_alias_map)\n         if join.join_type:\n             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n                 join_type = LOUTER\n",
  "test_patch": "diff --git a/tests/queries/test_queryset_or_operation.py b/tests/queries/test_queryset_or_operation.py\nnew file mode 100644\nindex 0000000..89f0c29\n--- /dev/null\n+++ b/tests/queries/test_queryset_or_operation.py\n@@ -0,0 +1,41 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Q\n+\n+\n+class Qux(models.Model):\n+    pass\n+\n+\n+class Baz(models.Model):\n+    pass\n+\n+\n+class Foo(models.Model):\n+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name=\"foos\")\n+\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name=\"bars\")\n+\n+\n+class QuerysetOrOperationTest(TestCase):\n+    def test_queryset_or_operation_assertion_error(self):\n+        qux = Qux.objects.create()\n+        baz = Baz.objects.create()\n+        foo = Foo.objects.create(qux=qux)\n+        Bar.objects.create(foo=foo, another_foo=foo, baz=baz)\n+\n+        qs1 = qux.foos.all()\n+        qs2 = Foo.objects.filter(\n+            Q(bars__baz__in=Baz.objects.all()) | Q(other_bars__baz__in=Baz.objects.all())\n+        )\n+\n+        # This should work fine\n+        qs2 | qs1\n+\n+        # This should raise an AssertionError\n+        with self.assertRaises(AssertionError):\n+            qs1 | qs2\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/queries/test_queryset_or_operation_inverted.py b/tests/queries/test_queryset_or_operation_inverted.py\nnew file mode 100644\nindex 0000000..98c2cb8\n--- /dev/null\n+++ b/tests/queries/test_queryset_or_operation_inverted.py\n@@ -0,0 +1,45 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Q\n+\n+\n+class Qux(models.Model):\n+    pass\n+\n+\n+class Baz(models.Model):\n+    pass\n+\n+\n+class Foo(models.Model):\n+    qux = models.ForeignKey(Qux, on_delete=models.CASCADE, related_name=\"foos\")\n+\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(Foo, on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(Baz, on_delete=models.CASCADE, related_name=\"bars\")\n+\n+\n+class QuerysetOrOperationTest(TestCase):\n+    def test_queryset_or_operation_assertion_error(self):\n+        qux = Qux.objects.create()\n+        baz = Baz.objects.create()\n+        foo = Foo.objects.create(qux=qux)\n+        Bar.objects.create(foo=foo, another_foo=foo, baz=baz)\n+\n+        qs1 = qux.foos.all()\n+        qs2 = Foo.objects.filter(\n+            Q(bars__baz__in=Baz.objects.all()) | Q(other_bars__baz__in=Baz.objects.all())\n+        )\n+\n+        # This should work fine\n+        qs2 | qs1\n+\n+        # This should raise an AssertionError\n+        try:\n+            qs1 | qs2\n+            raise AssertionError(\"Expected AssertionError was not raised\")\n+        except AssertionError as e:\n+            if \"change_map keys and values intersect\" not in str(e):\n+                raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 1763947,
  "num_received_chars": 90660,
  "elapsed_time": 568.3231616020203,
  "lint_repair_count": 0,
  "test_generation_attempts": 2,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}