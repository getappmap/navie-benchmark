{
  "instance_id": "django__django-9296",
  "edit_test_file": "tests/pagination/tests.py",
  "code_patch": "diff --git a/django/core/paginator.py b/django/core/paginator.py\nindex 1f92da5..31533e5 100644\n--- a/django/core/paginator.py\n+++ b/django/core/paginator.py\n@@ -34,6 +34,23 @@ class Paginator:\n         self.orphans = int(orphans)\n         self.allow_empty_first_page = allow_empty_first_page\n \n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over the pages in the paginator.\n+\n+        Yields:\n+            Page: A Page object for each page in the paginated set.\n+\n+        This allows for direct iteration over the Paginator object,\n+        providing a more intuitive and Pythonic way to access pages.\n+        \"\"\"\n+        for page_number in self.page_range:\n+            try:\n+                yield self.page(page_number)\n+            except InvalidPage:\n+                # Skip invalid pages\n+                continue\n+\n     def validate_number(self, number):\n         \"\"\"Validate the given 1-based page number.\"\"\"\n         try:\n",
  "test_patch": "diff --git a/tests/pagination/test_paginator_iteration.py b/tests/pagination/test_paginator_iteration.py\nnew file mode 100644\nindex 0000000..25a35b2\n--- /dev/null\n+++ b/tests/pagination/test_paginator_iteration.py\n@@ -0,0 +1,35 @@\n+from django.core.paginator import Paginator\n+from django.test import SimpleTestCase\n+\n+\n+class PaginatorIterationTests(SimpleTestCase):\n+    \"\"\"\n+    Tests for the Paginator iteration functionality.\n+    \"\"\"\n+\n+    def test_paginator_not_iterable(self):\n+        \"\"\"\n+        Test that the Paginator object is not directly iterable.\n+        \"\"\"\n+        items = range(1, 100)  # Create a list of 99 items\n+        paginator = Paginator(items, per_page=10)\n+\n+        # Attempt to iterate over the paginator\n+        with self.assertRaises(TypeError):\n+            list(paginator)\n+\n+        # Verify that we can still access pages using page_range\n+        expected_pages = 10  # 99 items with 10 per page results in 10 pages\n+        self.assertEqual(len(list(paginator.page_range)), expected_pages)\n+\n+        # Verify that we can access individual pages\n+        for page_num in paginator.page_range:\n+            page = paginator.page(page_num)\n+            self.assertIsNotNone(page)\n+\n+        # Demonstrate the current way to iterate over all pages\n+        all_items = []\n+        for page_num in paginator.page_range:\n+            all_items.extend(paginator.page(page_num).object_list)\n+\n+        self.assertEqual(list(items), all_items)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/pagination/test_paginator_iteration_inverted.py b/tests/pagination/test_paginator_iteration_inverted.py\nnew file mode 100644\nindex 0000000..d8bf7d5\n--- /dev/null\n+++ b/tests/pagination/test_paginator_iteration_inverted.py\n@@ -0,0 +1,63 @@\n+from django.core.paginator import Paginator\n+from django.test import SimpleTestCase\n+\n+\n+class PaginatorIterationTests(SimpleTestCase):\n+    \"\"\"\n+    Tests for the Paginator iteration functionality.\n+    \"\"\"\n+\n+    def test_paginator_iterable(self):\n+        \"\"\"\n+        Test that the Paginator object is directly iterable.\n+        \"\"\"\n+        items = range(1, 100)  # Create a list of 99 items\n+        paginator = Paginator(items, per_page=10)\n+\n+        try:\n+            # Attempt to iterate over the paginator\n+            iterated_pages = list(paginator)\n+        except TypeError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # If we reach here, the Paginator is iterable. Let's verify the contents.\n+        self.assertEqual(len(iterated_pages), 10)  # 99 items with 10 per page results in 10 pages\n+\n+        # Verify that each page contains the correct items\n+        all_items = []\n+        for page in iterated_pages:\n+            self.assertIsNotNone(page)\n+            all_items.extend(page.object_list)\n+\n+        self.assertEqual(list(items), all_items)\n+\n+    def test_paginator_iteration_content(self):\n+        \"\"\"\n+        Test that iterating over the Paginator yields the correct content.\n+        \"\"\"\n+        items = range(1, 100)  # Create a list of 99 items\n+        paginator = Paginator(items, per_page=10)\n+\n+        try:\n+            all_items = []\n+            for page in paginator:\n+                all_items.extend(page.object_list)\n+        except TypeError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        self.assertEqual(list(items), all_items)\n+\n+    def test_paginator_page_range_still_works(self):\n+        \"\"\"\n+        Test that page_range still works as expected.\n+        \"\"\"\n+        items = range(1, 100)  # Create a list of 99 items\n+        paginator = Paginator(items, per_page=10)\n+\n+        expected_pages = 10  # 99 items with 10 per page results in 10 pages\n+        self.assertEqual(len(list(paginator.page_range)), expected_pages)\n+\n+        # Verify that we can access individual pages\n+        for page_num in paginator.page_range:\n+            page = paginator.page(page_num)\n+            self.assertIsNotNone(page)\n\\ No newline at end of file\n",
  "num_sent_chars": 320830,
  "num_received_chars": 13939,
  "elapsed_time": 96.4540684223175,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}