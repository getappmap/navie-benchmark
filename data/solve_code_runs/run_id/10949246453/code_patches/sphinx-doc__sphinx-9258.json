{
  "instance_id": "sphinx-doc__sphinx-9258",
  "edit_test_file": "tests/test_util_typing.py",
  "code_patch": "diff --git a/doc/usage/extensions/example_google.py b/doc/usage/extensions/example_google.py\nindex 5fde6e2..4aa0c40 100644\n--- a/doc/usage/extensions/example_google.py\n+++ b/doc/usage/extensions/example_google.py\n@@ -60,6 +60,9 @@ def function_with_types_in_docstring(param1, param2):\n         https://www.python.org/dev/peps/pep-0484/\n \n     \"\"\"\n+        https://www.python.org/dev/peps/pep-0484/\n+\n+    \"\"\"\n \n \n def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:\n@@ -75,6 +78,21 @@ def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:\n     \"\"\"\n \n \n+def function_with_union_types(param1, param2):\n+    \"\"\"Example function with union types in docstring.\n+\n+    Args:\n+        param1 (int | float): The first parameter, can be integer or float.\n+        param2 (str | bytes): The second parameter, can be string or bytes.\n+\n+    Returns:\n+        bool | None: The return value. True for success, False for failure,\n+            or None if operation was not performed.\n+\n+    \"\"\"\n+    return True\n+\n+\n def module_level_function(param1, param2=None, *args, **kwargs):\n     \"\"\"This is an example of a module level function.\n \n@@ -87,22 +105,25 @@ def module_level_function(param1, param2=None, *args, **kwargs):\n \n     The format for a parameter is::\n \n-        name (type): description\n+        name (type1 | type2 | ...): description\n             The description may span multiple lines. Following\n-            lines should be indented. The \"(type)\" is optional.\n+            lines should be indented. The \"(type1 | type2 | ...)\" is optional.\n \n             Multiple paragraphs are supported in parameter\n             descriptions.\n \n+    Union types can be specified using the vertical bar (|) between types.\n+\n     Args:\n-        param1 (int): The first parameter.\n-        param2 (:obj:`str`, optional): The second parameter. Defaults to None.\n+        param1 (int | float): The first parameter. Can be an integer or float.\n+        param2 (:obj:`str` | bytes, optional): The second parameter. Defaults to None.\n             Second line of description should be indented.\n         *args: Variable length argument list.\n         **kwargs: Arbitrary keyword arguments.\n \n     Returns:\n-        bool: True if successful, False otherwise.\n+        bool | None: True if successful, False if unsuccessful, None if operation\n+        was not performed.\n \n         The return type is optional and may be specified at the beginning of\n         the ``Returns`` section followed by a colon.\n",
  "test_patch": "diff --git a/tests/test_union_type_specification.py b/tests/test_union_type_specification.py\nnew file mode 100644\nindex 0000000..536743a\n--- /dev/null\n+++ b/tests/test_union_type_specification.py\n@@ -0,0 +1,53 @@\n+import sys\n+from typing import Union\n+\n+import pytest\n+\n+from sphinx.util.typing import stringify\n+\n+\n+def test_union_type_specification_with_pipe():\n+    \"\"\"\n+    Test that union types specified with | are not properly supported.\n+    This test should pass when the issue is observed (i.e., when | is not supported).\n+    \"\"\"\n+    if sys.version_info < (3, 10):\n+        pytest.skip(\"Python 3.10+ is required for union type syntax with |\")\n+\n+    def foo(text: bytes | str):\n+        \"\"\"Bar\n+\n+        :param text: a text\n+        :type text: bytes | str\n+        \"\"\"\n+        pass\n+\n+    # Get the type annotation as a string\n+    type_annotation = stringify(foo.__annotations__['text'])\n+\n+    # The current behavior (which is the issue) is that it doesn't recognize the | syntax\n+    # and returns the full type object representation instead of \"bytes | str\"\n+    assert type_annotation != \"bytes | str\"\n+\n+    # It might return something like \"typing.Union[bytes, str]\" or the full type object repr\n+    assert \"Union\" in type_annotation or \"bytes\" in type_annotation and \"str\" in type_annotation\n+\n+\n+def test_union_type_specification_with_union():\n+    \"\"\"\n+    Test that union types specified with Union are properly supported.\n+    This test serves as a comparison to show that Union works while | doesn't.\n+    \"\"\"\n+    def foo(text: Union[bytes, str]):\n+        \"\"\"Bar\n+\n+        :param text: a text\n+        :type text: Union[bytes, str]\n+        \"\"\"\n+        pass\n+\n+    # Get the type annotation as a string\n+    type_annotation = stringify(foo.__annotations__['text'])\n+\n+    # The current behavior supports Union syntax\n+    assert type_annotation == \"Union[bytes, str]\"\n\\ No newline at end of file\n",
  "test_inverted_patch": null,
  "num_sent_chars": 2281504,
  "num_received_chars": 142193,
  "elapsed_time": 833.0169193744659,
  "lint_repair_count": 4,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}