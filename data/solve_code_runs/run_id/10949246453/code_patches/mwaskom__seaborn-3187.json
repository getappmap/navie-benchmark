{
  "instance_id": "mwaskom__seaborn-3187",
  "edit_test_file": "tests/_core/test_scales.py",
  "code_patch": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 8915616..57b848d 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -869,6 +869,35 @@ class Plotter:\n     # TODO decide if we ever want these (Plot.plot(debug=True))?\n     _data: PlotData\n     _layers: list[Layer]\n+\n+    @staticmethod\n+    def _get_formatter_offset(scale: Scale, axis: str) -> tuple[float, str]:\n+        \"\"\"\n+        Retrieve the offset value and string from the formatter associated with the scale.\n+\n+        Parameters:\n+        -----------\n+        scale : Scale\n+            The scale object associated with the axis.\n+        axis : str\n+            The axis ('x' or 'y') for which to retrieve the offset.\n+\n+        Returns:\n+        --------\n+        tuple[float, str]\n+            A tuple containing the offset value (as a float) and the offset string.\n+        \"\"\"\n+        formatter = scale._matplotlib_scale.get_major_formatter()\n+        if hasattr(formatter, 'get_offset'):\n+            offset = formatter.get_offset()\n+            if offset:\n+                try:\n+                    offset_value = float(offset)\n+                    offset_str = formatter.format_data(offset_value)\n+                    return offset_value, offset_str\n+                except ValueError:\n+                    pass\n+        return 0.0, \"\"\n     _figure: Figure\n \n     def __init__(self, pyplot: bool, theme: dict[str, Any]):\n@@ -1562,6 +1591,14 @@ class Plotter:\n             var_legend = scales[var]._legend\n             if var_legend is not None:\n                 values, labels = var_legend\n+                axis = 'x' if var.startswith('x') else 'y'\n+                offset_value, offset_str = self._get_formatter_offset(scales[var], axis)\n+                \n+                # Apply offset to values and labels\n+                if offset_value != 0:\n+                    values = [v + offset_value for v in values]\n+                    labels = [f\"{label} + {offset_str}\" for label in labels]\n+                \n                 for (_, part_id), part_vars, _ in schema:\n                     if data.ids[var] == part_id:\n                         # Allow multiple plot semantics to represent same data variable\n@@ -1569,6 +1606,8 @@ class Plotter:\n                         break\n                 else:\n                     title = self._resolve_label(p, var, data.names[var])\n+                    if offset_value != 0:\n+                        title = f\"{title}\\n(offset: {offset_str})\"\n                     entry = (title, data.ids[var]), [var], (values, labels)\n                     schema.append(entry)\n \n",
  "test_patch": "diff --git a/tests/_core/test_legend_formatting.py b/tests/_core/test_legend_formatting.py\nnew file mode 100644\nindex 0000000..59a51e8\n--- /dev/null\n+++ b/tests/_core/test_legend_formatting.py\n@@ -0,0 +1,43 @@\n+import pytest\n+import pandas as pd\n+import matplotlib as mpl\n+import seaborn as sns\n+import seaborn.objects as so\n+\n+class TestLegendFormatting:\n+\n+    @pytest.fixture\n+    def penguins_df(self):\n+        penguins = sns.load_dataset(\"penguins\")\n+        penguins[\"body_mass_mg\"] = penguins[\"body_mass_g\"] * 1000\n+        return penguins\n+\n+    def test_large_range_legend_formatting(self, penguins_df):\n+        \n+        p = (\n+            so.Plot(\n+                penguins_df,\n+                x=\"bill_length_mm\",\n+                y=\"bill_depth_mm\",\n+                color=\"species\",\n+                pointsize=\"body_mass_mg\"\n+            )\n+            .add(so.Dot())\n+        )\n+\n+        # Render the plot\n+        fig = p.plot()\n+\n+        # Get the legend\n+        legend = fig._figure.legends[0]\n+\n+        # Get the title of the legend for pointsize\n+        pointsize_title = legend.get_texts()[-1]\n+\n+        # Check if the legend title does not include the correct magnitude\n+        assert \"1e6\" not in pointsize_title.get_text(), \"Legend title unexpectedly shows correct magnitude for large values\"\n+\n+        # Check if the legend labels do not include the correct magnitude\n+        pointsize_labels = legend.get_texts()[:-1]  # Exclude the title\n+        for label in pointsize_labels:\n+            assert \"1e6\" not in label.get_text(), f\"Legend label unexpectedly shows correct magnitude: {label.get_text()}\"\n",
  "test_inverted_patch": "diff --git a/tests/_core/test_legend_formatting_inverted.py b/tests/_core/test_legend_formatting_inverted.py\nnew file mode 100644\nindex 0000000..f7c5bf9\n--- /dev/null\n+++ b/tests/_core/test_legend_formatting_inverted.py\n@@ -0,0 +1,48 @@\n+import pytest\n+import pandas as pd\n+import matplotlib as mpl\n+import seaborn as sns\n+import seaborn.objects as so\n+\n+class TestLegendFormatting:\n+\n+    @pytest.fixture\n+    def penguins_df(self):\n+        penguins = sns.load_dataset(\"penguins\")\n+        penguins[\"body_mass_mg\"] = penguins[\"body_mass_g\"] * 1000\n+        return penguins\n+\n+    def test_large_range_legend_formatting(self, penguins_df):\n+        \n+        p = (\n+            so.Plot(\n+                penguins_df,\n+                x=\"bill_length_mm\",\n+                y=\"bill_depth_mm\",\n+                color=\"species\",\n+                pointsize=\"body_mass_mg\"\n+            )\n+            .add(so.Dot())\n+        )\n+\n+        # Render the plot\n+        fig = p.plot()\n+\n+        # Get the legend\n+        legend = fig._figure.legends[0]\n+\n+        # Get the title of the legend for pointsize\n+        pointsize_title = legend.get_texts()[-1]\n+\n+        # Check if the legend title includes the correct magnitude\n+        if \"1e6\" not in pointsize_title.get_text():\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Check if the legend labels include the correct magnitude\n+        pointsize_labels = legend.get_texts()[:-1]  # Exclude the title\n+        for label in pointsize_labels:\n+            if \"1e6\" not in label.get_text():\n+                raise AssertionError(\"__BUG__HERE__\")\n+\n+        # If we reach here, it means the bug is not present\n+        assert False, \"Expected bug was not observed\"\n\\ No newline at end of file\n",
  "num_sent_chars": 1362730,
  "num_received_chars": 99419,
  "elapsed_time": 626.6647720336914,
  "lint_repair_count": 1,
  "test_generation_attempts": 3,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}