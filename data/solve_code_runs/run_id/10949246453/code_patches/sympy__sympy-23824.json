{
  "instance_id": "sympy__sympy-23824",
  "edit_test_file": "sympy/physics/hep/tests/test_gamma_matrices.py",
  "code_patch": "diff --git a/sympy/physics/hep/gamma_matrices.py b/sympy/physics/hep/gamma_matrices.py\nindex 23284e4..9f1569e 100644\n--- a/sympy/physics/hep/gamma_matrices.py\n+++ b/sympy/physics/hep/gamma_matrices.py\n@@ -351,6 +351,12 @@ def kahane_simplify(expression):\n     If spinor indices are given, the matrices must be given in\n     the order given in the product.\n \n+    The order of leading uncontracted gamma matrices is preserved during simplification.\n+    This is crucial for maintaining the correctness of the expression, as changing the\n+    order of these matrices would alter the meaning of the expression. The simplification\n+    process only affects contracted gamma matrices, leaving the order of uncontracted\n+    matrices unchanged.\n+\n     Algorithm\n     =========\n \n@@ -692,14 +698,20 @@ def kahane_simplify(expression):\n     # power of two factor, as described in Kahane's paper:\n     resulting_coeff *= 2**(number_of_contractions)\n \n-    # If `first_dum_pos` is not zero, it means that there are trailing free gamma\n+    # If `first_dum_pos` is not zero, it means that there are leading uncontracted gamma\n     # matrices in front of `expression`, so multiply by them:\n+    # IMPORTANT: We need to maintain the original order of these matrices\n+    leading_matrices = []\n     for i in range(0, first_dum_pos):\n-        [ri.insert(0, free_pos[i]) for ri in resulting_indices]\n-\n+        leading_matrices.append(free_pos[i])\n+    \n     resulting_expr = S.Zero\n     for i in resulting_indices:\n         temp_expr = S.One\n+        # First, multiply by the leading uncontracted matrices in their original order\n+        for j in leading_matrices:\n+            temp_expr *= GammaMatrix(j)\n+        # Then, multiply by the rest of the matrices\n         for j in i:\n             temp_expr *= GammaMatrix(j)\n         resulting_expr += temp_expr\n",
  "test_patch": "diff --git a/sympy/physics/hep/tests/test_kahane_simplify_leading_gamma_matrices.py b/sympy/physics/hep/tests/test_kahane_simplify_leading_gamma_matrices.py\nnew file mode 100644\nindex 0000000..8783b94\n--- /dev/null\n+++ b/sympy/physics/hep/tests/test_kahane_simplify_leading_gamma_matrices.py\n@@ -0,0 +1,23 @@\n+from sympy.physics.hep.gamma_matrices import GammaMatrix as G, LorentzIndex\n+from sympy.physics.hep.gamma_matrices import kahane_simplify\n+from sympy.tensor.tensor import tensor_indices\n+\n+def test_kahane_simplify_leading_gamma_matrices():\n+    mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n+    \n+    # Test case 1: Contracted indices at the beginning\n+    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n+    r1 = kahane_simplify(t1)\n+    assert r1.equals(4*G(rho)*G(sigma)), \"Failed to simplify G(mu)*G(-mu)*G(rho)*G(sigma) correctly\"\n+    \n+    # Test case 2: Contracted indices at the end\n+    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n+    r2 = kahane_simplify(t2)\n+    \n+    # This assertion should pass when the bug is present\n+    # It checks that the order of leading gamma matrices is incorrectly reversed\n+    assert r2.equals(4*G(sigma)*G(rho)), \"The order of leading gamma matrices is not reversed as expected\"\n+    \n+    # This assertion should fail when the bug is present\n+    # It checks for the correct simplification (which is not happening due to the bug)\n+    assert not r2.equals(4*G(rho)*G(sigma)), \"Unexpectedly simplified G(rho)*G(sigma)*G(mu)*G(-mu) correctly\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/physics/hep/tests/test_kahane_simplify_leading_gamma_matrices_inverted.py b/sympy/physics/hep/tests/test_kahane_simplify_leading_gamma_matrices_inverted.py\nnew file mode 100644\nindex 0000000..7c662d8\n--- /dev/null\n+++ b/sympy/physics/hep/tests/test_kahane_simplify_leading_gamma_matrices_inverted.py\n@@ -0,0 +1,23 @@\n+from sympy.physics.hep.gamma_matrices import GammaMatrix as G, LorentzIndex\n+from sympy.physics.hep.gamma_matrices import kahane_simplify\n+from sympy.tensor.tensor import tensor_indices\n+\n+def test_kahane_simplify_leading_gamma_matrices():\n+    mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n+    \n+    # Test case 1: Contracted indices at the beginning\n+    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n+    r1 = kahane_simplify(t1)\n+    assert r1.equals(4*G(rho)*G(sigma)), \"Failed to simplify G(mu)*G(-mu)*G(rho)*G(sigma) correctly\"\n+    \n+    # Test case 2: Contracted indices at the end\n+    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n+    r2 = kahane_simplify(t2)\n+    \n+    # This assertion will fail when the bug is present\n+    # It checks for the correct simplification (which is not happening due to the bug)\n+    if r2.equals(4*G(sigma)*G(rho)):\n+        raise AssertionError(\"__BUG__HERE__: The order of leading gamma matrices is incorrectly reversed\")\n+    \n+    # This assertion will pass when the bug is fixed\n+    assert r2.equals(4*G(rho)*G(sigma)), \"Failed to simplify G(rho)*G(sigma)*G(mu)*G(-mu) correctly\"\n\\ No newline at end of file\n",
  "num_sent_chars": 457272,
  "num_received_chars": 14133,
  "elapsed_time": 259.7439286708832,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}