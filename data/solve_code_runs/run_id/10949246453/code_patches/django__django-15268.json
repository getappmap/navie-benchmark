{
  "instance_id": "django__django-15268",
  "edit_test_file": "tests/migrations/test_optimizer.py",
  "code_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex bf9c2ac..e4cb1e0 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -1206,11 +1206,50 @@ class MigrationAutodetector:\n                     dependencies=dependencies,\n                 )\n \n+    def _optimize_altered_foo_together(self):\n+        optimized_operations = []\n+        skip_indices = set()\n+\n+        for i, op in enumerate(self.generated_operations):\n+            if i in skip_indices:\n+                continue\n+\n+            if isinstance(op, (operations.AlterUniqueTogether, operations.AlterIndexTogether)):\n+                next_op_index = i + 1\n+                if next_op_index < len(self.generated_operations):\n+                    next_op = self.generated_operations[next_op_index]\n+                    if (\n+                        isinstance(next_op, type(op)) and\n+                        op.name == next_op.name and\n+                        op.model_name == next_op.model_name\n+                    ):\n+                        # Combine the two operations\n+                        combined_value = getattr(next_op, op.option_name)\n+                        setattr(op, op.option_name, combined_value)\n+                        skip_indices.add(next_op_index)\n+\n+            optimized_operations.append(op)\n+\n+        self.generated_operations = optimized_operations\n+\n     def generate_altered_unique_together(self):\n         self._generate_altered_foo_together(operations.AlterUniqueTogether)\n+        self._optimize_altered_foo_together()\n \n     def generate_altered_index_together(self):\n         self._generate_altered_foo_together(operations.AlterIndexTogether)\n+        self._optimize_altered_foo_together()\n+\n+    def _build_migration_list(self, graph=None):\n+        # ... (existing code)\n+\n+        self._optimize_altered_foo_together()\n+\n+        self.migrations = {}\n+        num_ops = sum(len(x) for x in self.generated_operations.values())\n+        chop_mode = False\n+        while num_ops:\n+            # ... (rest of the existing code)\n \n     def generate_altered_db_table(self):\n         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)\n",
  "test_patch": "diff --git a/tests/migrations/test_optimize_alter_together_operations.py b/tests/migrations/test_optimize_alter_together_operations.py\nnew file mode 100644\nindex 0000000..ae56271\n--- /dev/null\n+++ b/tests/migrations/test_optimize_alter_together_operations.py\n@@ -0,0 +1,45 @@\n+from django.db import migrations\n+from django.test import SimpleTestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+\n+class OptimizeAlterTogetherOperationsTests(SimpleTestCase):\n+    def test_multiple_alter_together_operations_not_optimized(self):\n+        \"\"\"\n+        Test that multiple AlterUniqueTogether and AlterIndexTogether operations\n+        are not optimized into single operations as expected.\n+        \"\"\"\n+        operations = [\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together=set(),\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together=set(),\n+            ),\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together={(\"col\",)},\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together={(\"col\",)},\n+            ),\n+        ]\n+\n+        optimizer = MigrationOptimizer()\n+        optimized_operations = optimizer.optimize(operations, 'app_label')\n+\n+        # The test passes if the optimization doesn't happen\n+        self.assertEqual(len(optimized_operations), 4)\n+        self.assertIsInstance(optimized_operations[0], migrations.AlterUniqueTogether)\n+        self.assertIsInstance(optimized_operations[1], migrations.AlterIndexTogether)\n+        self.assertIsInstance(optimized_operations[2], migrations.AlterUniqueTogether)\n+        self.assertIsInstance(optimized_operations[3], migrations.AlterIndexTogether)\n+\n+        # Check that the operations are in the original order and have the expected attributes\n+        self.assertEqual(optimized_operations[0].unique_together, set())\n+        self.assertEqual(optimized_operations[1].index_together, set())\n+        self.assertEqual(optimized_operations[2].unique_together, {(\"col\",)})\n+        self.assertEqual(optimized_operations[3].index_together, {(\"col\",)})\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_optimize_alter_together_operations_inverted.py b/tests/migrations/test_optimize_alter_together_operations_inverted.py\nnew file mode 100644\nindex 0000000..cee5c10\n--- /dev/null\n+++ b/tests/migrations/test_optimize_alter_together_operations_inverted.py\n@@ -0,0 +1,51 @@\n+from django.db import migrations\n+from django.test import SimpleTestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+\n+class OptimizeAlterTogetherOperationsTests(SimpleTestCase):\n+    def test_multiple_alter_together_operations_optimized(self):\n+        \"\"\"\n+        Test that multiple AlterUniqueTogether and AlterIndexTogether operations\n+        are optimized into single operations as expected.\n+        \"\"\"\n+        operations = [\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together=set(),\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together=set(),\n+            ),\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together={(\"col\",)},\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together={(\"col\",)},\n+            ),\n+        ]\n+\n+        optimizer = MigrationOptimizer()\n+        optimized_operations = optimizer.optimize(operations, 'app_label')\n+\n+        # The test should fail if the optimization doesn't happen\n+        if len(optimized_operations) != 2:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Check that the operations are optimized and have the expected attributes\n+        self.assertIsInstance(optimized_operations[0], migrations.AlterUniqueTogether)\n+        self.assertIsInstance(optimized_operations[1], migrations.AlterIndexTogether)\n+        self.assertEqual(optimized_operations[0].unique_together, {(\"col\",)})\n+        self.assertEqual(optimized_operations[1].index_together, {(\"col\",)})\n+\n+        # Additional checks to ensure the optimization is correct\n+        for operation in optimized_operations:\n+            self.assertEqual(operation.name, 'mymodel')\n+\n+        # Check that there are no operations with empty sets\n+        for operation in optimized_operations:\n+            self.assertNotEqual(getattr(operation, 'unique_together', None), set())\n+            self.assertNotEqual(getattr(operation, 'index_together', None), set())\n\\ No newline at end of file\n",
  "num_sent_chars": 1632647,
  "num_received_chars": 125590,
  "elapsed_time": 623.2983891963959,
  "lint_repair_count": 7,
  "test_generation_attempts": 1,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}