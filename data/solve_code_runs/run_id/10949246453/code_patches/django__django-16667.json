{
  "instance_id": "django__django-16667",
  "edit_test_file": "tests/forms_tests/widget_tests/test_selectdatewidget.py",
  "code_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 842b73e..23581d4 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -1035,6 +1035,28 @@ class SelectDateWidget(Widget):\n             this_year = datetime.date.today().year\n             self.years = range(this_year, this_year + 10)\n \n+    @staticmethod\n+    def _safe_int_cast(value, default=None):\n+        \"\"\"\n+        Safely convert a value to int, with bounds checking.\n+        Returns default if value is not a valid integer or is out of bounds.\n+        \"\"\"\n+        try:\n+            return int(value)\n+        except (TypeError, ValueError):\n+            return default\n+\n+    @staticmethod\n+    def _is_valid_date(year, month, day):\n+        \"\"\"\n+        Check if the given year, month, and day form a valid date.\n+        \"\"\"\n+        try:\n+            datetime.date(year, month, day)\n+            return True\n+        except (ValueError, OverflowError):\n+            return False\n+\n         # Optional dict of months to use in the \"month\" select box.\n         if months:\n             self.months = months\n@@ -1155,13 +1177,28 @@ class SelectDateWidget(Widget):\n         if y is not None and m is not None and d is not None:\n             input_format = get_format(\"DATE_INPUT_FORMATS\")[0]\n             input_format = formats.sanitize_strftime_format(input_format)\n-            try:\n-                date_value = datetime.date(int(y), int(m), int(d))\n-            except ValueError:\n-                # Return pseudo-ISO dates with zeros for any unselected values,\n-                # e.g. '2017-0-23'.\n+            \n+            # Safely convert inputs to integers\n+            year = self._safe_int_cast(y)\n+            month = self._safe_int_cast(m)\n+            day = self._safe_int_cast(d)\n+            \n+            # Check if all values are valid integers\n+            if year is None or month is None or day is None:\n                 return \"%s-%s-%s\" % (y or 0, m or 0, d or 0)\n-            return date_value.strftime(input_format)\n+            \n+            # Check if the date is valid\n+            if self._is_valid_date(year, month, day):\n+                try:\n+                    date_value = datetime.date(year, month, day)\n+                    return date_value.strftime(input_format)\n+                except (ValueError, OverflowError):\n+                    # This should not happen due to prior checks, but just in case\n+                    pass\n+            \n+            # Return pseudo-ISO dates with zeros for any unselected values,\n+            # e.g. '2017-0-23'.\n+            return \"%s-%s-%s\" % (y or 0, m or 0, d or 0)\n         return data.get(name)\n \n     def value_omitted_from_data(self, data, files, name):\n",
  "test_patch": "diff --git a/tests/forms_tests/widget_tests/test_selectdatewidget_overflow.py b/tests/forms_tests/widget_tests/test_selectdatewidget_overflow.py\nnew file mode 100644\nindex 0000000..e463f61\n--- /dev/null\n+++ b/tests/forms_tests/widget_tests/test_selectdatewidget_overflow.py\n@@ -0,0 +1,24 @@\n+from datetime import date\n+\n+from django.forms import DateField, Form, SelectDateWidget\n+from django.test import TestCase\n+from django.http import HttpRequest\n+\n+class SelectDateWidgetOverflowTest(TestCase):\n+    def test_selectdatewidget_overflow(self):\n+        class ReproForm(Form):\n+            my_date = DateField(widget=SelectDateWidget())\n+\n+        # Simulate a GET request with an extremely large year value\n+        request = HttpRequest()\n+        request.GET = {\n+            'my_date_day': '1',\n+            'my_date_month': '1',\n+            'my_date_year': '1234567821345678'\n+        }\n+\n+        form = ReproForm(request.GET)\n+\n+        # Assert that an OverflowError is raised when calling is_valid()\n+        with self.assertRaises(OverflowError):\n+            form.is_valid()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/forms_tests/widget_tests/test_selectdatewidget_overflow_inverted.py b/tests/forms_tests/widget_tests/test_selectdatewidget_overflow_inverted.py\nnew file mode 100644\nindex 0000000..3010c73\n--- /dev/null\n+++ b/tests/forms_tests/widget_tests/test_selectdatewidget_overflow_inverted.py\n@@ -0,0 +1,30 @@\n+from datetime import date\n+\n+from django.forms import DateField, Form, SelectDateWidget\n+from django.test import TestCase\n+from django.http import HttpRequest\n+\n+class SelectDateWidgetOverflowTest(TestCase):\n+    def test_selectdatewidget_overflow(self):\n+        class ReproForm(Form):\n+            my_date = DateField(widget=SelectDateWidget())\n+\n+        # Simulate a GET request with an extremely large year value\n+        request = HttpRequest()\n+        request.GET = {\n+            'my_date_day': '1',\n+            'my_date_month': '1',\n+            'my_date_year': '1234567821345678'\n+        }\n+\n+        form = ReproForm(request.GET)\n+\n+        # Try to validate the form\n+        try:\n+            form.is_valid()\n+        except OverflowError:\n+            # If an OverflowError is raised, the bug is present\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # If no OverflowError was raised, the test should fail\n+        self.fail(\"Expected OverflowError was not raised\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1816881,
  "num_received_chars": 133337,
  "elapsed_time": 669.9891955852509,
  "lint_repair_count": 12,
  "test_generation_attempts": 1,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}