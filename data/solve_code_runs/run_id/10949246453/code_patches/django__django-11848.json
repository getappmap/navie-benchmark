{
  "instance_id": "django__django-11848",
  "edit_test_file": "tests/sitemaps_tests/test_http.py",
  "code_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4..9beae6c 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -164,6 +164,16 @@ def parse_http_date(date):\n \n     Return an integer expressed in seconds since the epoch, in UTC.\n     \"\"\"\n+    def parse_two_digit_year(year):\n+        current_year = datetime.datetime.now().year\n+        current_century = current_year // 100 * 100\n+        current_two_digit_year = current_year % 100\n+        \n+        if year <= (current_two_digit_year + 50) % 100:\n+            return current_century + year\n+        else:\n+            return (current_century - 100) + year\n+\n     # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n     # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n     # our own RFC-compliant parsing.\n@@ -175,7 +185,9 @@ def parse_http_date(date):\n         raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n     try:\n         year = int(m.group('year'))\n-        if year < 100:\n+        if regex == RFC850_DATE:\n+            year = parse_two_digit_year(year)\n+        elif year < 100:\n             if year < 70:\n                 year += 2000\n             else:\n",
  "test_patch": "diff --git a/tests/sitemaps_tests/test_http_date_parsing.py b/tests/sitemaps_tests/test_http_date_parsing.py\nnew file mode 100644\nindex 0000000..fa780ae\n--- /dev/null\n+++ b/tests/sitemaps_tests/test_http_date_parsing.py\n@@ -0,0 +1,33 @@\n+import unittest\n+from datetime import datetime\n+from django.utils.http import parse_http_date\n+\n+class HTTPDateParsingTests(unittest.TestCase):\n+    def test_two_digit_year_parsing(self):\n+        # Get the current year\n+        current_year = datetime.now().year\n+        \n+        # Test a date 51 years in the future\n+        future_year = (current_year + 51) % 100\n+        future_date = f\"Sunday, 06-Nov-{future_year:02d} 08:49:37 GMT\"\n+        parsed_date = parse_http_date(future_date)\n+        \n+        # Convert the parsed timestamp to a datetime object\n+        parsed_datetime = datetime.utcfromtimestamp(parsed_date)\n+        \n+        # Assert that the parsed year is the most recent year in the past with the same last two digits\n+        expected_year = current_year - (100 - (future_year - (current_year % 100)))\n+        self.assertEqual(parsed_datetime.year, expected_year)\n+        \n+        # Assert that other parts of the date are correctly parsed\n+        self.assertEqual(parsed_datetime.month, 11)\n+        self.assertEqual(parsed_datetime.day, 6)\n+        self.assertEqual(parsed_datetime.hour, 8)\n+        self.assertEqual(parsed_datetime.minute, 49)\n+        self.assertEqual(parsed_datetime.second, 37)\n+\n+        # Test the current behavior (which is incorrect according to the issue description)\n+        if future_year < 70:\n+            self.assertEqual(parsed_datetime.year, 2000 + future_year)\n+        else:\n+            self.assertEqual(parsed_datetime.year, 1900 + future_year)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/sitemaps_tests/test_http_date_parsing_inverted.py b/tests/sitemaps_tests/test_http_date_parsing_inverted.py\nnew file mode 100644\nindex 0000000..e0423a3\n--- /dev/null\n+++ b/tests/sitemaps_tests/test_http_date_parsing_inverted.py\n@@ -0,0 +1,40 @@\n+import unittest\n+from datetime import datetime\n+from django.utils.http import parse_http_date\n+\n+class HTTPDateParsingTests(unittest.TestCase):\n+    def test_two_digit_year_parsing(self):\n+        # Get the current year\n+        current_year = datetime.now().year\n+        \n+        # Test a date 51 years in the future\n+        future_year = (current_year + 51) % 100\n+        future_date = f\"Sunday, 06-Nov-{future_year:02d} 08:49:37 GMT\"\n+        parsed_date = parse_http_date(future_date)\n+        \n+        # Convert the parsed timestamp to a datetime object\n+        parsed_datetime = datetime.utcfromtimestamp(parsed_date)\n+        \n+        # Calculate the expected year according to RFC 7231\n+        expected_year = current_year - (100 - (future_year - (current_year % 100)))\n+        \n+        # Assert that the parsed year is the most recent year in the past with the same last two digits\n+        try:\n+            self.assertEqual(parsed_datetime.year, expected_year)\n+        except AssertionError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        # Assert that other parts of the date are correctly parsed\n+        self.assertEqual(parsed_datetime.month, 11)\n+        self.assertEqual(parsed_datetime.day, 6)\n+        self.assertEqual(parsed_datetime.hour, 8)\n+        self.assertEqual(parsed_datetime.minute, 49)\n+        self.assertEqual(parsed_datetime.second, 37)\n+\n+        # Test the current behavior (which is incorrect according to the issue description)\n+        if future_year < 70:\n+            if parsed_datetime.year == 2000 + future_year:\n+                raise AssertionError(\"__BUG__HERE__\")\n+        else:\n+            if parsed_datetime.year == 1900 + future_year:\n+                raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1943617,
  "num_received_chars": 122558,
  "elapsed_time": 729.523099899292,
  "lint_repair_count": 12,
  "test_generation_attempts": 4,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}