{
  "instance_id": "django__django-14011",
  "edit_test_file": "tests/servers/test_liveserverthread.py",
  "code_patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex 14dab51..f6e6a07 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -81,6 +81,15 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n     \"\"\"A threaded version of the WSGIServer\"\"\"\n     daemon_threads = True\n \n+    def process_request_thread(self, request, client_address):\n+        try:\n+            super().process_request_thread(request, client_address)\n+        finally:\n+            # Ensure that the database connection is closed after each request\n+            from django.db import connections\n+            for conn in connections.all():\n+                conn.close()\n+\n \n class ServerHandler(simple_server.ServerHandler):\n     http_version = '1.1'\n@@ -212,4 +221,10 @@ def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGISe\n         # isn't terminating correctly.\n         httpd.daemon_threads = True\n     httpd.set_app(wsgi_handler)\n-    httpd.serve_forever()\n+    try:\n+        httpd.serve_forever()\n+    finally:\n+        # Ensure all database connections are closed on server shutdown\n+        from django.db import connections\n+        for conn in connections.all():\n+            conn.close()\n",
  "test_patch": "diff --git a/tests/servers/test_threadedwsgiserver_dbconnection.py b/tests/servers/test_threadedwsgiserver_dbconnection.py\nnew file mode 100644\nindex 0000000..c07b0f0\n--- /dev/null\n+++ b/tests/servers/test_threadedwsgiserver_dbconnection.py\n@@ -0,0 +1,35 @@\n+from django.db import OperationalError, connections\n+from django.test import LiveServerTestCase, TransactionTestCase\n+from django.core.servers.basehttp import ThreadedWSGIServer\n+from django.test.testcases import LiveServerThread, QuietWSGIRequestHandler\n+\n+class NonThreadedLiveServerThread(LiveServerThread):\n+    def _create_server(self):\n+        return ThreadedWSGIServer((self.host, self.port), QuietWSGIRequestHandler, allow_reuse_address=False)\n+\n+class ThreadedWSGIServerIssueTest(TransactionTestCase):\n+    available_apps = []\n+\n+    def test_database_connection_not_closed(self):\n+        class MyTest(LiveServerTestCase):\n+            server_thread_class = NonThreadedLiveServerThread\n+\n+        # Open a connection to the database.\n+        conn = connections['default']\n+        conn.connect()\n+        conn.inc_thread_sharing()\n+\n+        try:\n+            # Simulate the test case execution\n+            test_case = MyTest(methodName='setUpClass')\n+            test_case.setUpClass()\n+            test_case.tearDownClass()\n+\n+            # Assert that the connection is still open, which should not be the case\n+            self.assertIsNotNone(conn.connection)\n+        except OperationalError as e:\n+            # Check if the error is due to the database being accessed by other users\n+            self.assertIn(\"database is being accessed by other users\", str(e))\n+        finally:\n+            conn.dec_thread_sharing()\n+            conn.close()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/servers/test_threadedwsgiserver_dbconnection_inverted.py b/tests/servers/test_threadedwsgiserver_dbconnection_inverted.py\nnew file mode 100644\nindex 0000000..a24e7d1\n--- /dev/null\n+++ b/tests/servers/test_threadedwsgiserver_dbconnection_inverted.py\n@@ -0,0 +1,35 @@\n+from django.db import OperationalError, connections\n+from django.test import LiveServerTestCase, TransactionTestCase\n+from django.core.servers.basehttp import ThreadedWSGIServer\n+from django.test.testcases import LiveServerThread, QuietWSGIRequestHandler\n+\n+class NonThreadedLiveServerThread(LiveServerThread):\n+    def _create_server(self):\n+        return ThreadedWSGIServer((self.host, self.port), QuietWSGIRequestHandler, allow_reuse_address=False)\n+\n+class ThreadedWSGIServerIssueTest(TransactionTestCase):\n+    available_apps = []\n+\n+    def test_database_connection_not_closed(self):\n+        class MyTest(LiveServerTestCase):\n+            server_thread_class = NonThreadedLiveServerThread\n+\n+        # Open a connection to the database.\n+        conn = connections['default']\n+        conn.connect()\n+        conn.inc_thread_sharing()\n+\n+        try:\n+            # Simulate the test case execution\n+            test_case = MyTest(methodName='setUpClass')\n+            test_case.setUpClass()\n+            test_case.tearDownClass()\n+\n+            # Assert that the connection is closed, which should be the case\n+            self.assertIsNone(conn.connection, \"__BUG__HERE__\")\n+        except OperationalError as e:\n+            # Check if the error is due to the database being accessed by other users\n+            self.assertIn(\"database is being accessed by other users\", str(e))\n+        finally:\n+            conn.dec_thread_sharing()\n+            conn.close()\n\\ No newline at end of file\n",
  "num_sent_chars": 1518009,
  "num_received_chars": 67433,
  "elapsed_time": 409.57057428359985,
  "lint_repair_count": 3,
  "test_generation_attempts": 5,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}