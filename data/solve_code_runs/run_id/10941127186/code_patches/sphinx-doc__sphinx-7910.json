{
  "instance_id": "sphinx-doc__sphinx-7910",
  "edit_test_file": "tests/test_ext_autodoc_mock.py",
  "code_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 9300a2c..edc7b8f 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1314,6 +1314,14 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 return None\n             return attr\n \n+        def get_class_from_qualname(obj: Any) -> Optional[Type]:\n+            \"\"\"Attempt to retrieve the class from the __qualname__ of the method.\"\"\"\n+            qualname = getattr(obj, '__qualname__', None)\n+            if qualname and '.' in qualname:\n+                cls_name = qualname.rsplit('.', 1)[0]\n+                return self.env.app.registry.documenters.get(cls_name)\n+            return None\n+\n         # This sequence is copied from inspect._signature_from_callable.\n         # ValueError means that no signature could be found, so we keep going.\n \n@@ -1343,6 +1351,11 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n             except ValueError:\n                 pass\n \n+        # Attempt to retrieve class from __qualname__ if decorated\n+        cls_from_qualname = get_class_from_qualname(self.object)\n+        if cls_from_qualname:\n+            self._signature_class = cls_from_qualname\n+\n         # Finally, we should have at least __init__ implemented\n         init = get_user_defined_function_or_method(self.object, '__init__')\n         if init is not None:\n",
  "test_patch": "diff --git a/tests/test_ext_autodoc_decorated_init.py b/tests/test_ext_autodoc_decorated_init.py\nnew file mode 100644\nindex 0000000..6b19fb6\n--- /dev/null\n+++ b/tests/test_ext_autodoc_decorated_init.py\n@@ -0,0 +1,41 @@\n+\"\"\"\n+    test_ext_autodoc_decorated_init\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension for decorated __init__ methods.\n+\n+    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import functools\n+import sys\n+from importlib import import_module\n+from sphinx.ext.autodoc.mock import _MockModule, mock\n+\n+def test_decorated_init():\n+    class MockClass:\n+        @functools.wraps(object.__init__)\n+        def __init__(self):\n+            \"\"\"This is the init docstring.\"\"\"\n+            pass\n+\n+    modname = 'mocked_module'\n+    with mock([modname]):\n+        mock_module = _MockModule(modname)\n+        mock_module.MockClass = MockClass\n+\n+        # Simulate the behavior of Sphinx autodoc\n+        obj = mock_module.MockClass.__init__\n+        qualname = 'MockClass.__init__'\n+        name = '__init__'\n+        cls_path = qualname.rpartition('.')[0]\n+\n+        # Check if the decorated __init__ is documented\n+        try:\n+            cls = obj.__globals__[cls_path]\n+            cls_is_owner = (cls and hasattr(cls, name) and name in cls.__dict__)\n+        except Exception:\n+            cls_is_owner = False\n+\n+        assert not cls_is_owner, \"Decorated __init__ should not be documented\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_ext_autodoc_decorated_init_inverted.py b/tests/test_ext_autodoc_decorated_init_inverted.py\nnew file mode 100644\nindex 0000000..4fff535\n--- /dev/null\n+++ b/tests/test_ext_autodoc_decorated_init_inverted.py\n@@ -0,0 +1,42 @@\n+\"\"\"\n+    test_ext_autodoc_decorated_init\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension for decorated __init__ methods.\n+\n+    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import functools\n+import sys\n+from importlib import import_module\n+from sphinx.ext.autodoc.mock import _MockModule, mock\n+\n+def test_decorated_init():\n+    class MockClass:\n+        @functools.wraps(object.__init__)\n+        def __init__(self):\n+            \"\"\"This is the init docstring.\"\"\"\n+            pass\n+\n+    modname = 'mocked_module'\n+    with mock([modname]):\n+        mock_module = _MockModule(modname)\n+        mock_module.MockClass = MockClass\n+\n+        # Simulate the behavior of Sphinx autodoc\n+        obj = mock_module.MockClass.__init__\n+        qualname = 'MockClass.__init__'\n+        name = '__init__'\n+        cls_path = qualname.rpartition('.')[0]\n+\n+        # Check if the decorated __init__ is documented\n+        try:\n+            cls = obj.__globals__[cls_path]\n+            cls_is_owner = (cls and hasattr(cls, name) and name in cls.__dict__)\n+        except Exception:\n+            cls_is_owner = False\n+\n+        # Alter the assertion to fail when the bug is observed\n+        assert cls_is_owner, \"__BUG__HERE__\"\n\\ No newline at end of file\n",
  "num_sent_chars": 1808065,
  "num_received_chars": 109644,
  "elapsed_time": 586.669591665268,
  "lint_repair_count": 3,
  "test_generation_attempts": 4,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}