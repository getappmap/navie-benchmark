{
  "instance_id": "django__django-11149",
  "edit_test_file": "tests/admin_inlines/tests.py",
  "code_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 880a2cc..82111d0 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2115,18 +2115,22 @@ class InlineModelAdmin(BaseModelAdmin):\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n             # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # to have the change permission for the related model in order to\n+            # be able to add to the intermediate model.\n+            return self.has_change_permission(request, obj)\n         return super().has_add_permission(request)\n \n     def has_change_permission(self, request, obj=None):\n         if self.opts.auto_created:\n             # We're checking the rights to an auto-created intermediate model,\n-            # which doesn't have its own individual permissions. The user needs\n-            # to have the view permission for the related model in order to\n-            # be able to do anything with the intermediate model.\n-            return self.has_view_permission(request, obj)\n+            # which doesn't have its own individual permissions.\n+            # For ManyToMany relationships, check change permission on the related model\n+            for field in self.opts.fields:\n+                if field.remote_field and field.remote_field.model != self.parent_model:\n+                    opts = field.remote_field.model._meta\n+                    codename = get_permission_codename('change', opts)\n+                    return request.user.has_perm('%s.%s' % (opts.app_label, codename))\n+            return False\n         return super().has_change_permission(request)\n \n     def has_delete_permission(self, request, obj=None):\n",
  "test_patch": "diff --git a/tests/admin_inlines/test_admin_inline_permissions.py b/tests/admin_inlines/test_admin_inline_permissions.py\nnew file mode 100644\nindex 0000000..662eb61\n--- /dev/null\n+++ b/tests/admin_inlines/test_admin_inline_permissions.py\n@@ -0,0 +1,68 @@\n+from django.contrib.auth.models import Permission, User\n+from django.contrib.contenttypes.models import ContentType\n+from django.test import TestCase, override_settings\n+from django.urls import reverse\n+\n+from .models import Author, Book\n+\n+\n+@override_settings(ROOT_URLCONF='admin_inlines.urls')\n+class TestInlinePermissions(TestCase):\n+    \"\"\"Test inline permissions for ManyToManyField relationships.\"\"\"\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a user with view permission only\n+        cls.view_only_user = User.objects.create_user(\n+            username='viewonly',\n+            password='secret',\n+            is_staff=True\n+        )\n+        \n+        # Get content types\n+        cls.author_ct = ContentType.objects.get_for_model(Author)\n+        cls.book_ct = ContentType.objects.get_for_model(Book)\n+        \n+        # Give view permissions only\n+        view_author = Permission.objects.get(\n+            codename='view_author',\n+            content_type=cls.author_ct\n+        )\n+        view_book = Permission.objects.get(\n+            codename='view_book', \n+            content_type=cls.book_ct\n+        )\n+        cls.view_only_user.user_permissions.add(view_author, view_book)\n+\n+        # Create test data\n+        cls.author = Author.objects.create(name='Test Author')\n+        cls.book = Book.objects.create(name='Test Book')\n+        cls.author.books.add(cls.book)\n+\n+    def setUp(self):\n+        self.client.force_login(self.view_only_user)\n+\n+    def test_m2m_inline_view_only_permission(self):\n+        \"\"\"\n+        Users with only view permissions should not be able to modify M2M relationships,\n+        but the issue allows them to do so.\n+        \"\"\"\n+        # Try to remove the book from the author through the inline\n+        post_data = {\n+            'name': 'Test Author',\n+            'Author_books-TOTAL_FORMS': '1',\n+            'Author_books-INITIAL_FORMS': '1',\n+            'Author_books-MIN_NUM_FORMS': '0',\n+            'Author_books-MAX_NUM_FORMS': '1000',\n+            'Author_books-0-id': str(self.book.id),\n+            'Author_books-0-author': str(self.author.id),\n+            'Author_books-0-DELETE': 'on',  # Try to delete the relationship\n+        }\n+        \n+        change_url = reverse('admin:admin_inlines_author_change', args=[self.author.id])\n+        response = self.client.post(change_url, post_data)\n+        \n+        # The issue allows modification, so the book relationship is removed\n+        # despite only having view permission\n+        self.assertEqual(response.status_code, 302)  # Successful POST redirects\n+        self.assertEqual(self.author.books.count(), 0)  # Book was removed when it shouldn't be\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/admin_inlines/test_admin_inline_permissions_inverted.py b/tests/admin_inlines/test_admin_inline_permissions_inverted.py\nnew file mode 100644\nindex 0000000..81e46c9\n--- /dev/null\n+++ b/tests/admin_inlines/test_admin_inline_permissions_inverted.py\n@@ -0,0 +1,73 @@\n+from django.contrib.auth.models import Permission, User\n+from django.contrib.contenttypes.models import ContentType\n+from django.test import TestCase, override_settings\n+from django.urls import reverse\n+\n+from .models import Author, Book\n+\n+\n+@override_settings(ROOT_URLCONF='admin_inlines.urls')\n+class TestInlinePermissions(TestCase):\n+    \"\"\"Test inline permissions for ManyToManyField relationships.\"\"\"\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a user with view permission only\n+        cls.view_only_user = User.objects.create_user(\n+            username='viewonly',\n+            password='secret',\n+            is_staff=True\n+        )\n+        \n+        # Get content types\n+        cls.author_ct = ContentType.objects.get_for_model(Author)\n+        cls.book_ct = ContentType.objects.get_for_model(Book)\n+        \n+        # Give view permissions only\n+        view_author = Permission.objects.get(\n+            codename='view_author',\n+            content_type=cls.author_ct\n+        )\n+        view_book = Permission.objects.get(\n+            codename='view_book', \n+            content_type=cls.book_ct\n+        )\n+        cls.view_only_user.user_permissions.add(view_author, view_book)\n+\n+        # Create test data\n+        cls.author = Author.objects.create(name='Test Author')\n+        cls.book = Book.objects.create(name='Test Book')\n+        cls.author.books.add(cls.book)\n+\n+    def setUp(self):\n+        self.client.force_login(self.view_only_user)\n+\n+    def test_m2m_inline_view_only_permission(self):\n+        \"\"\"\n+        Users with only view permissions should not be able to modify M2M relationships.\n+        The test should fail if they can modify the relationships.\n+        \"\"\"\n+        # Try to remove the book from the author through the inline\n+        post_data = {\n+            'name': 'Test Author',\n+            'Author_books-TOTAL_FORMS': '1',\n+            'Author_books-INITIAL_FORMS': '1',\n+            'Author_books-MIN_NUM_FORMS': '0',\n+            'Author_books-MAX_NUM_FORMS': '1000',\n+            'Author_books-0-id': str(self.book.id),\n+            'Author_books-0-author': str(self.author.id),\n+            'Author_books-0-DELETE': 'on',  # Try to delete the relationship\n+        }\n+        \n+        change_url = reverse('admin:admin_inlines_author_change', args=[self.author.id])\n+        response = self.client.post(change_url, post_data)\n+        \n+        # If the response is a redirect (302) and the book was removed,\n+        # this indicates the bug is present and the test should fail\n+        if response.status_code == 302 and self.author.books.count() == 0:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        # The correct behavior: request should be forbidden\n+        self.assertEqual(response.status_code, 403)\n+        # Relationship should remain intact\n+        self.assertEqual(self.author.books.count(), 1)\n\\ No newline at end of file\n",
  "num_sent_chars": 4948929,
  "num_received_chars": 92251,
  "elapsed_time": 832.209555387497,
  "lint_repair_count": 6,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}