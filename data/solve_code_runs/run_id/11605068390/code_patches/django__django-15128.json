{
  "instance_id": "django__django-15128",
  "edit_test_file": "tests/or_lookups/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee..7dadf57 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -761,7 +761,19 @@ class Query(BaseExpression):\n \n         # Create a new alias for this table.\n         if alias_list:\n-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n+            # Find the highest numbered alias with this prefix to avoid collisions\n+            # when combining queries\n+            max_suffix = 0\n+            prefix_len = len(self.alias_prefix)\n+            for existing_alias in self.alias_map:\n+                if existing_alias.startswith(self.alias_prefix):\n+                    try:\n+                        suffix = int(existing_alias[prefix_len:])\n+                        max_suffix = max(max_suffix, suffix)\n+                    except ValueError:\n+                        continue\n+            # Create new alias with next available number\n+            alias = '%s%d' % (self.alias_prefix, max_suffix + 1)\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n@@ -845,8 +857,22 @@ class Query(BaseExpression):\n         Change the aliases in change_map (which maps old-alias -> new-alias),\n         relabelling any references to them in select columns and the where\n         clause.\n-        \"\"\"\n-        assert set(change_map).isdisjoint(change_map.values())\n+\n+        The change_map dictionary maps old aliases to new aliases. An alias can\n+        only be mapped once to prevent incorrect query construction. For example,\n+        if we had {'T1': 'T2', 'T2': 'T3'}, then 'T2' would be both a target\n+        alias and a source alias, which could lead to incorrect alias substitution\n+        and invalid SQL generation.\n+\n+        Raises AssertionError if any alias appears as both a source and target\n+        in the mapping, which would cause ambiguous or incorrect relabeling.\n+        \"\"\"\n+        source_aliases = set(change_map)\n+        target_aliases = set(change_map.values())\n+        if not source_aliases.isdisjoint(target_aliases):\n+            overlapping = source_aliases.intersection(target_aliases)\n+            raise AssertionError(\n+                f\"Alias mapping conflict: {overlapping} appear as both source and target aliases\")\n \n         # 1. Update references in \"select\" (normal columns plus aliases),\n         # \"group by\" and \"where\".\n",
  "test_patch": "diff --git a/tests/or_lookups/test_queryset_alias_combination.py b/tests/or_lookups/test_queryset_alias_combination.py\nnew file mode 100644\nindex 0000000..58888a5\n--- /dev/null\n+++ b/tests/or_lookups/test_queryset_alias_combination.py\n@@ -0,0 +1,48 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+\n+class Baz(models.Model):\n+    pass\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\")\n+\n+\n+class QuerySetAliasCombinationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.baz = Baz.objects.create()\n+        cls.qux = Qux.objects.create()\n+        cls.qux.bazes.add(cls.baz)\n+        cls.foo = Foo.objects.create(qux=cls.qux)\n+        cls.bar1 = Bar.objects.create(foo=cls.foo, another_foo=cls.foo, baz=cls.baz)\n+\n+    def test_queryset_combination_alias_assertion(self):\n+        \"\"\"\n+        Test that combining querysets with OR operation raises AssertionError\n+        when the change_map's keys intersect with its values.\n+        \"\"\"\n+        # Create the two querysets that will cause the issue\n+        qs1 = self.qux.foos.all()\n+        qs2 = Foo.objects.filter(\n+            models.Q(bars__baz__in=self.qux.bazes.all()) |\n+            models.Q(other_bars__baz__in=self.qux.bazes.all())\n+        )\n+\n+        # This combination works fine\n+        combined1 = qs2 | qs1\n+        self.assertEqual(list(combined1), [self.foo])\n+\n+        # This combination should raise AssertionError due to alias conflict\n+        with self.assertRaises(AssertionError):\n+            list(qs1 | qs2)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/or_lookups/test_queryset_alias_combination_inverted.py b/tests/or_lookups/test_queryset_alias_combination_inverted.py\nnew file mode 100644\nindex 0000000..f1d959f\n--- /dev/null\n+++ b/tests/or_lookups/test_queryset_alias_combination_inverted.py\n@@ -0,0 +1,53 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+\n+class Baz(models.Model):\n+    pass\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\")\n+\n+\n+class QuerySetAliasCombinationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.baz = Baz.objects.create()\n+        cls.qux = Qux.objects.create()\n+        cls.qux.bazes.add(cls.baz)\n+        cls.foo = Foo.objects.create(qux=cls.qux)\n+        cls.bar1 = Bar.objects.create(foo=cls.foo, another_foo=cls.foo, baz=cls.baz)\n+\n+    def test_queryset_combination_alias_assertion(self):\n+        \"\"\"\n+        Test that combining querysets with OR operation should not raise AssertionError\n+        when the change_map's keys intersect with its values.\n+        \"\"\"\n+        # Create the two querysets that will cause the issue\n+        qs1 = self.qux.foos.all()\n+        qs2 = Foo.objects.filter(\n+            models.Q(bars__baz__in=self.qux.bazes.all()) |\n+            models.Q(other_bars__baz__in=self.qux.bazes.all())\n+        )\n+\n+        # This combination works fine\n+        combined1 = qs2 | qs1\n+        self.assertEqual(list(combined1), [self.foo])\n+\n+        # This combination should NOT raise AssertionError, but it does\n+        try:\n+            list(qs1 | qs2)\n+        except AssertionError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # If we get here, the test passes (which means the bug is fixed)\n+        self.assertTrue(True)\n\\ No newline at end of file\n",
  "num_sent_chars": 751726,
  "num_received_chars": 11780,
  "elapsed_time": 120.6167106628418,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}