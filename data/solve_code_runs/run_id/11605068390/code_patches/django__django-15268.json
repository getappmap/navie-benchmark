{
  "instance_id": "django__django-15268",
  "edit_test_file": "tests/migrations/test_optimizer.py",
  "code_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex bf9c2ac..004943b 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -1176,11 +1176,11 @@ class MigrationAutodetector:\n             model_name,\n             dependencies,\n         ) in self._get_altered_foo_together_operations(operation.option_name):\n-            removal_value = new_value.intersection(old_value)\n-            if removal_value or old_value:\n+            # Only generate removal operation if there are values to remove\n+            if old_value and old_value != new_value:\n                 self.add_operation(\n                     app_label,\n-                    operation(name=model_name, **{operation.option_name: removal_value}),\n+                    operation(name=model_name, **{operation.option_name: old_value}),\n                     dependencies=dependencies,\n                 )\n \n@@ -1198,8 +1198,8 @@ class MigrationAutodetector:\n             model_name,\n             dependencies,\n         ) in self._get_altered_foo_together_operations(operation.option_name):\n-            removal_value = new_value.intersection(old_value)\n-            if new_value != removal_value:\n+            # Only generate operation if there are actual changes\n+            if old_value != new_value:\n                 self.add_operation(\n                     app_label,\n                     operation(name=model_name, **{operation.option_name: new_value}),\n",
  "test_patch": "diff --git a/tests/migrations/test_optimize_alter_foo_together.py b/tests/migrations/test_optimize_alter_foo_together.py\nnew file mode 100644\nindex 0000000..3ac6b8f\n--- /dev/null\n+++ b/tests/migrations/test_optimize_alter_foo_together.py\n@@ -0,0 +1,35 @@\n+from django.db import migrations\n+from django.test import SimpleTestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+class OptimizeAlterFooTogetherTests(SimpleTestCase):\n+    def optimize(self, operations, app_label='migrations'):\n+        optimizer = MigrationOptimizer()\n+        return optimizer.optimize(operations, app_label)\n+\n+    def test_optimize_multiple_alter_foo_together(self):\n+        \"\"\"\n+        Test that multiple AlterFooTogether operations are not optimized into one.\n+        \"\"\"\n+        operations = [\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together=set(),\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together=set(),\n+            ),\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together={(\"col\",)},\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together={(\"col\",)},\n+            ),\n+        ]\n+        optimized_operations = self.optimize(operations)\n+        # The issue is that these operations should not be optimized into one.\n+        # We expect the same number of operations as input.\n+        self.assertEqual(len(optimized_operations), len(operations))\n",
  "test_inverted_patch": "diff --git a/tests/migrations/test_optimize_alter_foo_together_inverted.py b/tests/migrations/test_optimize_alter_foo_together_inverted.py\nnew file mode 100644\nindex 0000000..5137c0b\n--- /dev/null\n+++ b/tests/migrations/test_optimize_alter_foo_together_inverted.py\n@@ -0,0 +1,36 @@\n+from django.db import migrations\n+from django.test import SimpleTestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+class OptimizeAlterFooTogetherTests(SimpleTestCase):\n+    def optimize(self, operations, app_label='migrations'):\n+        optimizer = MigrationOptimizer()\n+        return optimizer.optimize(operations, app_label)\n+\n+    def test_optimize_multiple_alter_foo_together(self):\n+        \"\"\"\n+        Test that multiple AlterFooTogether operations are optimized into one.\n+        \"\"\"\n+        operations = [\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together=set(),\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together=set(),\n+            ),\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together={(\"col\",)},\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together={(\"col\",)},\n+            ),\n+        ]\n+        optimized_operations = self.optimize(operations)\n+        # The issue is that these operations should be optimized into one.\n+        # We expect fewer operations than input.\n+        if len(optimized_operations) == len(operations):\n+            raise AssertionError(\"__BUG__HERE__\")\n",
  "num_sent_chars": 3344013,
  "num_received_chars": 70732,
  "elapsed_time": 623.786199092865,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}