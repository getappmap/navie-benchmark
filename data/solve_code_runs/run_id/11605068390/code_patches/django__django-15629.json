{
  "instance_id": "django__django-15629",
  "edit_test_file": "tests/schema/tests.py",
  "code_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 696bfd7..c04698f 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -775,6 +775,7 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"Perform a \"physical\" (non-ManyToMany) field update.\"\"\"\n         # Drop any FK constraints, we'll remake them later\n         fks_dropped = set()\n+        collation_changed = old_db_params.get(\"collation\") != new_db_params.get(\"collation\")\n         if (\n             self.connection.features.supports_foreign_keys\n             and old_field.remote_field\n@@ -829,7 +830,7 @@ class BaseDatabaseSchemaEditor:\n                 (old_field.primary_key and new_field.primary_key)\n                 or (old_field.unique and new_field.unique)\n             )\n-            and old_type != new_type\n+            and (old_type != new_type or collation_changed)\n         )\n         if drop_foreign_keys:\n             # '_meta.related_field' also contains M2M reverse fields, these\n@@ -1038,6 +1039,8 @@ class BaseDatabaseSchemaEditor:\n         for old_rel, new_rel in rels_to_update:\n             rel_db_params = new_rel.field.db_parameters(connection=self.connection)\n             rel_type = rel_db_params[\"type\"]\n+            \n+            # Handle type changes\n             fragment, other_actions = self._alter_column_type_sql(\n                 new_rel.related_model, old_rel.field, new_rel.field, rel_type\n             )\n@@ -1051,6 +1054,19 @@ class BaseDatabaseSchemaEditor:\n             )\n             for sql, params in other_actions:\n                 self.execute(sql, params)\n+                \n+            # Handle collation changes for foreign keys when primary key collation changes\n+            if collation_changed and new_field.primary_key:\n+                rel_collation_fragment = self._alter_column_collation_sql(\n+                    new_rel.related_model, new_rel.field, rel_type, new_db_params[\"collation\"]\n+                )\n+                self.execute(\n+                    self.sql_alter_column % {\n+                        \"table\": self.quote_name(new_rel.related_model._meta.db_table),\n+                        \"changes\": rel_collation_fragment[0],\n+                    },\n+                    rel_collation_fragment[1],\n+                )\n         # Does it have a foreign key?\n         if (\n             self.connection.features.supports_foreign_keys\n",
  "test_patch": "diff --git a/tests/schema/test_db_collation_foreign_keys.py b/tests/schema/test_db_collation_foreign_keys.py\nnew file mode 100644\nindex 0000000..d33a168\n--- /dev/null\n+++ b/tests/schema/test_db_collation_foreign_keys.py\n@@ -0,0 +1,51 @@\n+from django.db import connection\n+from django.db.models import CharField, ForeignKey, CASCADE\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.db import models\n+\n+class DBCollationForeignKeyTests(TestCase):\n+    @skipUnlessDBFeature(\"supports_collation_on_charfield\")\n+    def test_db_collation_not_propagated_to_foreign_keys(self):\n+        \"\"\"\n+        db_collation specified on a primary key field should be propagated to \n+        foreign key fields that reference it.\n+        \"\"\"\n+        # Only run on MySQL where this is known to fail\n+        if connection.vendor != 'mysql':\n+            self.skipTest(\"This test only applies to MySQL.\")\n+\n+        # Create the models dynamically\n+        class Account(models.Model):\n+            id = CharField(\n+                primary_key=True,\n+                max_length=22,\n+                db_collation='utf8_bin',\n+                db_index=True\n+            )\n+\n+            class Meta:\n+                app_label = 'schema'\n+\n+        class Profile(models.Model):\n+            id = CharField(\n+                primary_key=True,\n+                max_length=22,\n+                db_collation='utf8_bin',\n+                db_index=True\n+            )\n+            account = ForeignKey(Account, on_delete=CASCADE)\n+\n+            class Meta:\n+                app_label = 'schema'\n+\n+        # Create the tables\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Account)\n+            # This will fail because db_collation is not propagated to foreign key\n+            with self.assertRaises(Exception):\n+                editor.create_model(Profile)\n+\n+        # Clean up\n+        with connection.schema_editor() as editor:\n+            editor.delete_model(Profile)\n+            editor.delete_model(Account)\n\\ No newline at end of file\n",
  "test_inverted_patch": null,
  "num_sent_chars": 6120838,
  "num_received_chars": 120966,
  "elapsed_time": 1437.5212969779968,
  "lint_repair_count": 2,
  "test_generation_attempts": 9,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}