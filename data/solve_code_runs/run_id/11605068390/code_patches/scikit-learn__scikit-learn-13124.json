{
  "instance_id": "scikit-learn__scikit-learn-13124",
  "edit_test_file": "sklearn/model_selection/tests/test_split.py",
  "code_patch": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 24394f8..d62baa2 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -620,7 +620,7 @@ class StratifiedKFold(_BaseKFold):\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\n-        rng = self.random_state\n+        rng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n@@ -651,15 +651,24 @@ class StratifiedKFold(_BaseKFold):\n         # NOTE: Passing the data corresponding to ith class say X[y==class_i]\n         # will break when the data is not 100% stratifiable for all classes.\n         # So we pass np.zeroes(max(c, n_splits)) as data to the KFold\n+        test_folds = np.zeros(n_samples, dtype=np.int)\n+        \n+        # If shuffle is True, shuffle indices within each class separately\n+        class_indices = []\n+        for cls in unique_y:\n+            cls_idx = np.where(y == cls)[0]\n+            if self.shuffle:\n+                rng.shuffle(cls_idx)\n+            class_indices.append(cls_idx)\n+            \n         per_cls_cvs = [\n-            KFold(self.n_splits, shuffle=self.shuffle,\n-                  random_state=rng).split(np.zeros(max(count, self.n_splits)))\n+            KFold(self.n_splits, shuffle=False,\n+                  random_state=None).split(np.zeros(max(count, self.n_splits)))\n             for count in y_counts]\n \n-        test_folds = np.zeros(n_samples, dtype=np.int)\n         for test_fold_indices, per_cls_splits in enumerate(zip(*per_cls_cvs)):\n-            for cls, (_, test_split) in zip(unique_y, per_cls_splits):\n-                cls_test_folds = test_folds[y == cls]\n+            for cls_idx, (_, test_split) in zip(class_indices, per_cls_splits):\n+                cls_test_folds = test_folds[cls_idx]\n                 # the test split can be too big because we used\n                 # KFold(...).split(X[:max(c, n_splits)]) when data is not 100%\n                 # stratifiable for all the classes\n@@ -667,7 +676,7 @@ class StratifiedKFold(_BaseKFold):\n                 # If this is the case, let's trim it:\n                 test_split = test_split[test_split < len(cls_test_folds)]\n                 cls_test_folds[test_split] = test_fold_indices\n-                test_folds[y == cls] = cls_test_folds\n+                test_folds[cls_idx] = cls_test_folds\n \n         return test_folds\n \n",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py b/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py\nnew file mode 100644\nindex 0000000..29f0534\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py\n@@ -0,0 +1,37 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+from sklearn.utils.testing import assert_array_equal\n+\n+def test_stratified_kfold_shuffle_consistency():\n+    \"\"\"Test that StratifiedKFold with shuffle=True only changes batch order.\n+    \n+    This test verifies that when shuffle=True, the actual sample pairs within\n+    each fold remain consistent (just in different orders) rather than truly\n+    shuffling samples within strata as suggested by the documentation.\n+    \"\"\"\n+    # Create a simple dataset with 10 samples per class\n+    samples_per_class = 10\n+    X = np.linspace(0, samples_per_class * 2 - 1, samples_per_class * 2)\n+    y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)))\n+    \n+    # Get splits with shuffle=False\n+    kf_no_shuffle = StratifiedKFold(n_splits=10, shuffle=False, random_state=1)\n+    splits_no_shuffle = list(kf_no_shuffle.split(X, y))\n+    \n+    # Get splits with shuffle=True and two different random states\n+    kf_shuffle_1 = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)\n+    splits_shuffle_1 = list(kf_shuffle_1.split(X, y))\n+    \n+    kf_shuffle_2 = StratifiedKFold(n_splits=10, shuffle=True, random_state=2)\n+    splits_shuffle_2 = list(kf_shuffle_2.split(X, y))\n+    \n+    # For each fold, verify that the same pairs of indices appear in test sets\n+    # regardless of shuffling, just in different orders\n+    pairs_no_shuffle = {tuple(sorted(test)) for _, test in splits_no_shuffle}\n+    pairs_shuffle_1 = {tuple(sorted(test)) for _, test in splits_shuffle_1}\n+    pairs_shuffle_2 = {tuple(sorted(test)) for _, test in splits_shuffle_2}\n+    \n+    # The sets of pairs should be identical regardless of shuffling\n+    assert_array_equal(len(pairs_no_shuffle), 10)\n+    assert_array_equal(pairs_no_shuffle, pairs_shuffle_1)\n+    assert_array_equal(pairs_shuffle_1, pairs_shuffle_2)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py b/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py\nnew file mode 100644\nindex 0000000..a32a600\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py\n@@ -0,0 +1,44 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+from sklearn.utils.testing import assert_raises_regex\n+\n+def test_stratified_kfold_shuffle_consistency():\n+    \"\"\"Test that StratifiedKFold with shuffle=True properly shuffles within strata.\n+    \n+    This test verifies that when shuffle=True, the samples within strata are\n+    actually shuffled, rather than just reordering the batches. The test will\n+    fail if the shuffling is not working as documented.\n+    \"\"\"\n+    # Create a simple dataset with 10 samples per class\n+    samples_per_class = 10\n+    X = np.linspace(0, samples_per_class * 2 - 1, samples_per_class * 2)\n+    y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)))\n+    \n+    # Get splits with shuffle=True and two different random states\n+    kf_shuffle_1 = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)\n+    splits_shuffle_1 = list(kf_shuffle_1.split(X, y))\n+    \n+    kf_shuffle_2 = StratifiedKFold(n_splits=10, shuffle=True, random_state=2)\n+    splits_shuffle_2 = list(kf_shuffle_2.split(X, y))\n+    \n+    # Extract test sets and sort them for comparison\n+    test_sets_1 = [tuple(sorted(test)) for _, test in splits_shuffle_1]\n+    test_sets_2 = [tuple(sorted(test)) for _, test in splits_shuffle_2]\n+    \n+    # Convert to sets for comparison\n+    unique_pairs_1 = set(test_sets_1)\n+    unique_pairs_2 = set(test_sets_2)\n+    \n+    # If the sets are equal, it means the shuffling is only reordering batches\n+    # rather than actually shuffling within strata\n+    if unique_pairs_1 == unique_pairs_2:\n+        raise AssertionError(\"__BUG__HERE__\")\n+        \n+    # Additional verification that pairs should be different\n+    # Count how many pairs are identical between the two splits\n+    identical_pairs = sum(1 for pair1, pair2 in zip(sorted(test_sets_1), sorted(test_sets_2)) \n+                         if pair1 == pair2)\n+    \n+    # With proper shuffling, we expect most pairs to be different\n+    if identical_pairs > len(test_sets_1) // 2:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 787441,
  "num_received_chars": 10601,
  "elapsed_time": 116.1466429233551,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}