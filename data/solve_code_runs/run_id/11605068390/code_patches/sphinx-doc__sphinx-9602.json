{
  "instance_id": "sphinx-doc__sphinx-9602",
  "edit_test_file": "tests/test_config.py",
  "code_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976..9da1da7 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -35,6 +35,7 @@ from sphinx.util.inspect import (evaluate_signature, getdoc, object_description,\n                                  stringify_signature)\n from sphinx.util.typing import OptionSpec, get_type_hints, restify\n from sphinx.util.typing import stringify as stringify_typehint\n+from typing import get_origin, Literal\n \n if TYPE_CHECKING:\n     from sphinx.ext.autodoc.directive import DocumenterBridge\n@@ -1298,6 +1299,14 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n+            # Handle Literal type annotations specially\n+            for param in sig.parameters.values():\n+                if param.annotation is not param.empty:\n+                    origin = get_origin(param.annotation)\n+                    if origin is Literal:\n+                        # Convert Literal values to strings without cross-references\n+                        kwargs.setdefault('no_type_check', True)\n+                        break\n             args = stringify_signature(sig, **kwargs)\n         except TypeError as exc:\n             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n",
  "test_patch": "diff --git a/tests/test_ext_literal_nitpick.py b/tests/test_ext_literal_nitpick.py\nnew file mode 100644\nindex 0000000..0cb5bab\n--- /dev/null\n+++ b/tests/test_ext_literal_nitpick.py\n@@ -0,0 +1,39 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import SphinxError\n+from sphinx.testing.path import path\n+\n+class TestLiteralAnnotationNitpick(unittest.TestCase):\n+    def test_literal_annotation_nitpick_warning(self):\n+        # Create a temporary directory for the test\n+        tempdir = path(self._testMethodName)\n+        tempdir.makedirs(exist_ok=True)\n+\n+        # Create a temporary conf.py file\n+        (tempdir / 'conf.py').write_text(\"\"\"\n+extensions = ['sphinx.ext.autodoc']\n+nitpicky = True\n+\"\"\", encoding='utf-8')\n+\n+        # Create a temporary module with Literal annotations\n+        (tempdir / 'module.py').write_text(\"\"\"\n+import typing\n+\n+@typing.overload\n+def foo(x: \"typing.Literal[True]\") -> int: ...\n+@typing.overload\n+def foo(x: \"typing.Literal[False]\") -> str: ...\n+def foo(x: bool):\n+    '''a func'''\n+    return 1 if x else \"foo\"\n+\"\"\", encoding='utf-8')\n+\n+        # Initialize a Sphinx application\n+        app = Sphinx(srcdir=tempdir, confdir=tempdir, outdir=tempdir / '_build', doctreedir=tempdir / '_doctrees', buildername='html')\n+        \n+        # Expecting a SphinxError due to nitpick warning on Literal\n+        with self.assertRaises(SphinxError):\n+            app.builder.build_all()\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/tests/test_ext_literal_nitpick_inverted.py b/tests/test_ext_literal_nitpick_inverted.py\nnew file mode 100644\nindex 0000000..3faa809\n--- /dev/null\n+++ b/tests/test_ext_literal_nitpick_inverted.py\n@@ -0,0 +1,41 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import SphinxError\n+from sphinx.testing.path import path\n+\n+class TestLiteralAnnotationNitpick(unittest.TestCase):\n+    def test_literal_annotation_nitpick_warning(self):\n+        # Create a temporary directory for the test\n+        tempdir = path(self._testMethodName)\n+        tempdir.makedirs(exist_ok=True)\n+\n+        # Create a temporary conf.py file\n+        (tempdir / 'conf.py').write_text(\"\"\"\n+extensions = ['sphinx.ext.autodoc']\n+nitpicky = True\n+\"\"\", encoding='utf-8')\n+\n+        # Create a temporary module with Literal annotations\n+        (tempdir / 'module.py').write_text(\"\"\"\n+import typing\n+\n+@typing.overload\n+def foo(x: \"typing.Literal[True]\") -> int: ...\n+@typing.overload\n+def foo(x: \"typing.Literal[False]\") -> str: ...\n+def foo(x: bool):\n+    '''a func'''\n+    return 1 if x else \"foo\"\n+\"\"\", encoding='utf-8')\n+\n+        # Initialize a Sphinx application\n+        app = Sphinx(srcdir=tempdir, confdir=tempdir, outdir=tempdir / '_build', doctreedir=tempdir / '_doctrees', buildername='html')\n+        \n+        # Expecting a SphinxError due to nitpick warning on Literal\n+        try:\n+            app.builder.build_all()\n+        except SphinxError:\n+            self.fail(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 6684266,
  "num_received_chars": 50925,
  "elapsed_time": 948.1380512714386,
  "lint_repair_count": 12,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}