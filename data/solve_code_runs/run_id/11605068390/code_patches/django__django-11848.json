{
  "instance_id": "django__django-11848",
  "edit_test_file": "tests/utils_tests/test_http.py",
  "code_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4..2a52d2a 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -176,10 +176,20 @@ def parse_http_date(date):\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n-            if year < 70:\n-                year += 2000\n+            # RFC 7231 Section 7.1.1.1 says:\n+            # A sender that generates a date with a two-digit year SHOULD generate\n+            # the year using the \"50-year rule\": interpret two-digit years as \n+            # the greater of the two possible years that end in that value, \n+            # unless doing so would make it more than 50 years in the future.\n+            current_year = datetime.datetime.now().year\n+            current_century = current_year // 100 * 100\n+            candidate_year = current_century + year\n+            if candidate_year > current_year + 50:\n+                # If the candidate year is more than 50 years in the future,\n+                # use the previous century\n+                year = (current_century - 100) + year\n             else:\n-                year += 1900\n+                year = candidate_year\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n",
  "test_patch": "diff --git a/tests/utils_tests/test_parse_http_date.py b/tests/utils_tests/test_parse_http_date.py\nnew file mode 100644\nindex 0000000..11949c8\n--- /dev/null\n+++ b/tests/utils_tests/test_parse_http_date.py\n@@ -0,0 +1,18 @@\n+import unittest\n+from datetime import datetime\n+from django.utils.http import parse_http_date\n+\n+class ParseHttpDateIssueTests(unittest.TestCase):\n+    def test_rfc850_two_digit_year(self):\n+        # This test is designed to reproduce the issue with two-digit year parsing.\n+        # According to RFC 7231, a two-digit year that appears to be more than 50 years\n+        # in the future should be interpreted as the most recent year in the past with\n+        # the same last two digits.\n+\n+        # The current logic incorrectly interprets '70' as 1970 instead of 2070.\n+        parsed = parse_http_date('Sunday, 06-Nov-70 08:49:37 GMT')\n+        # The expected incorrect behavior is that it will interpret the year as 1970.\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1970, 11, 6, 8, 49, 37))\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "test_inverted_patch": "diff --git a/tests/utils_tests/test_parse_http_date_inverted.py b/tests/utils_tests/test_parse_http_date_inverted.py\nnew file mode 100644\nindex 0000000..d161ac7\n--- /dev/null\n+++ b/tests/utils_tests/test_parse_http_date_inverted.py\n@@ -0,0 +1,21 @@\n+import unittest\n+from datetime import datetime\n+from django.utils.http import parse_http_date\n+\n+class ParseHttpDateIssueTests(unittest.TestCase):\n+    def test_rfc850_two_digit_year(self):\n+        # This test is designed to reproduce the issue with two-digit year parsing.\n+        # According to RFC 7231, a two-digit year that appears to be more than 50 years\n+        # in the future should be interpreted as the most recent year in the past with\n+        # the same last two digits.\n+\n+        # The current logic incorrectly interprets '70' as 1970 instead of 2070.\n+        parsed = parse_http_date('Sunday, 06-Nov-70 08:49:37 GMT')\n+        # The expected correct behavior is that it should interpret the year as 2070.\n+        # Therefore, the test should fail if the year is interpreted as 1970.\n+        if datetime.utcfromtimestamp(parsed) == datetime(1970, 11, 6, 8, 49, 37):\n+            raise AssertionError(\"__BUG__HERE__\")\n+        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2070, 11, 6, 8, 49, 37))\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "num_sent_chars": 517421,
  "num_received_chars": 7285,
  "elapsed_time": 87.66011691093445,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}