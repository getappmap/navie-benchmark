{
  "instance_id": "django__django-15732",
  "edit_test_file": "tests/invalid_models_tests/test_models.py",
  "code_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8..24d760c 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -568,15 +568,26 @@ class BaseDatabaseSchemaEditor:\n             exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs,\n         )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n-                % (\n-                    len(constraint_names),\n-                    model._meta.db_table,\n-                    \", \".join(columns),\n-                )\n-            )\n+        if not constraint_names:\n+            # No matching constraints found - nothing to remove\n+            return\n+        \n+        # For unique_together, we need to be careful about which constraint to remove\n+        if constraint_kwargs.get('unique', False):\n+            # Look for a constraint that matches the unique_together pattern\n+            # This will typically be named something like tablename_col1_col2_uniq\n+            table_prefix = model._meta.db_table.lower()\n+            col_names = '_'.join(columns).lower()\n+            unique_together_pattern = f\"{table_prefix}_{col_names}_\"\n+            \n+            for name in constraint_names:\n+                if name.lower().startswith(unique_together_pattern):\n+                    # Found the unique_together constraint - remove it\n+                    self.execute(self._delete_constraint_sql(sql, model, name))\n+                    return\n+                    \n+        # If we're not dealing with unique_together or didn't find a matching constraint,\n+        # remove the first constraint found (maintaining backward compatibility)\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_unique_constraints.py b/tests/invalid_models_tests/test_unique_constraints.py\nnew file mode 100644\nindex 0000000..dc28cfe\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_unique_constraints.py\n@@ -0,0 +1,30 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class UniqueConstraintsTests(TestCase):\n+    def test_unique_together_with_unique_field(self):\n+        \"\"\"\n+        Test that unique_together constraint on a field that already has unique=True\n+        creates duplicate unique constraints.\n+        \"\"\"\n+        class DuplicateUniqueModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+            name = models.CharField(max_length=100, unique=True)\n+\n+            class Meta:\n+                unique_together = (('name',),)\n+\n+        # Get all unique constraints on the model\n+        constraints = [\n+            c for c in DuplicateUniqueModel._meta.constraints\n+            if isinstance(c, models.UniqueConstraint)\n+        ]\n+        unique_together_constraints = DuplicateUniqueModel._meta.unique_together\n+\n+        # Assert that we have both constraints - one from unique=True and one from unique_together\n+        self.assertEqual(len(unique_together_constraints), 1)\n+        self.assertEqual(unique_together_constraints[0], ('name',))\n+\n+        # The field should have its own unique constraint from unique=True\n+        self.assertTrue(DuplicateUniqueModel._meta.get_field('name').unique)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/invalid_models_tests/test_unique_constraints_inverted.py b/tests/invalid_models_tests/test_unique_constraints_inverted.py\nnew file mode 100644\nindex 0000000..de4c637\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_unique_constraints_inverted.py\n@@ -0,0 +1,39 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class UniqueConstraintsTests(TestCase):\n+    def test_unique_together_with_unique_field(self):\n+        \"\"\"\n+        Test that unique_together constraint on a field that already has unique=True\n+        should not create duplicate unique constraints.\n+        \"\"\"\n+        class DuplicateUniqueModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+            name = models.CharField(max_length=100, unique=True)\n+\n+            class Meta:\n+                unique_together = (('name',),)\n+\n+        # Get all unique constraints on the model\n+        constraints = [\n+            c for c in DuplicateUniqueModel._meta.constraints\n+            if isinstance(c, models.UniqueConstraint)\n+        ]\n+        unique_together_constraints = DuplicateUniqueModel._meta.unique_together\n+\n+        # Count total number of unique constraints (including field-level and model-level)\n+        total_unique_constraints = (\n+            len(unique_together_constraints) +\n+            (1 if DuplicateUniqueModel._meta.get_field('name').unique else 0)\n+        )\n+\n+        # If we have more than one unique constraint on the same field,\n+        # this is the bug we're testing for\n+        if total_unique_constraints > 1:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # We should only have one unique constraint, either from unique=True\n+        # or from unique_together, but not both\n+        self.assertEqual(total_unique_constraints, 1,\n+                        \"Should only have one unique constraint on the field\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3203282,
  "num_received_chars": 62950,
  "elapsed_time": 599.3955733776093,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}