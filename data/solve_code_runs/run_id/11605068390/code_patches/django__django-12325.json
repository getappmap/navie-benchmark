{
  "instance_id": "django__django-12325",
  "edit_test_file": "tests/model_inheritance/tests.py",
  "code_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05..ad76274 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -8,8 +8,8 @@ from django.apps import apps\n from django.conf import settings\n from django.core import checks\n from django.core.exceptions import (\n-    NON_FIELD_ERRORS, FieldDoesNotExist, FieldError, MultipleObjectsReturned,\n-    ObjectDoesNotExist, ValidationError,\n+    NON_FIELD_ERRORS, FieldDoesNotExist, FieldError, ImproperlyConfigured,\n+    MultipleObjectsReturned, ObjectDoesNotExist, ValidationError,\n )\n from django.db import (\n     DEFAULT_DB_ALIAS, DJANGO_VERSION_PICKLE_KEY, DatabaseError, connection,\n@@ -193,6 +193,7 @@ class ModelBase(type):\n \n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n+        explicit_parent_links = {}\n         for base in reversed([new_class] + parents):\n             # Conceptually equivalent to `if base is Model`.\n             if not hasattr(base, '_meta'):\n@@ -200,11 +201,25 @@ class ModelBase(type):\n             # Skip concrete parent classes.\n             if base != new_class and not base._meta.abstract:\n                 continue\n-            # Locate OneToOneField instances.\n+            # First pass: collect fields explicitly marked as parent_link=True\n             for field in base._meta.local_fields:\n-                if isinstance(field, OneToOneField):\n+                if isinstance(field, OneToOneField) and field.remote_field.parent_link:\n                     related = resolve_relation(new_class, field.remote_field.model)\n-                    parent_links[make_model_tuple(related)] = field\n+                    key = make_model_tuple(related)\n+                    if key in explicit_parent_links:\n+                        raise ImproperlyConfigured(\n+                            \"Multiple parent links to '%s' model found in '%s'. \"\n+                            \"Only one parent link is allowed.\" % (related, new_class.__name__)\n+                        )\n+                    explicit_parent_links[key] = field\n+            # Second pass: collect remaining OneToOneFields as fallback\n+            for field in base._meta.local_fields:\n+                if isinstance(field, OneToOneField) and not field.remote_field.parent_link:\n+                    related = resolve_relation(new_class, field.remote_field.model)\n+                    if make_model_tuple(related) not in explicit_parent_links:\n+                        parent_links[make_model_tuple(related)] = field\n+        # Use explicit parent links first, fall back to discovered links\n+        parent_links.update(explicit_parent_links)\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -238,6 +253,10 @@ class ModelBase(type):\n                 base_key = make_model_tuple(base)\n                 if base_key in parent_links:\n                     field = parent_links[base_key]\n+                    if not field.remote_field.parent_link:\n+                        # If we're using a discovered parent link that wasn't explicitly marked,\n+                        # ensure it's properly configured\n+                        field.remote_field.parent_link = True\n                 elif not is_proxy:\n                     attr_name = '%s_ptr' % base._meta.model_name\n                     field = OneToOneField(\n",
  "test_patch": "diff --git a/tests/model_inheritance/test_mti_one_to_one_ordering_issue.py b/tests/model_inheritance/test_mti_one_to_one_ordering_issue.py\nnew file mode 100644\nindex 0000000..7e9f15f\n--- /dev/null\n+++ b/tests/model_inheritance/test_mti_one_to_one_ordering_issue.py\n@@ -0,0 +1,13 @@\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+class OneToOneOrderIssueTests(SimpleTestCase):\n+    def test_onetoone_order_issue(self):\n+        class Document(models.Model):\n+            pass\n+\n+        with self.assertRaisesMessage(ImproperlyConfigured, \"Add parent_link=True to model_inheritance.Picking.origin.\"):\n+            class Picking(Document):\n+                document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+                origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n",
  "test_inverted_patch": "diff --git a/tests/model_inheritance/test_mti_one_to_one_ordering_issue_inverted.py b/tests/model_inheritance/test_mti_one_to_one_ordering_issue_inverted.py\nnew file mode 100644\nindex 0000000..4a7b02b\n--- /dev/null\n+++ b/tests/model_inheritance/test_mti_one_to_one_ordering_issue_inverted.py\n@@ -0,0 +1,14 @@\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+class OneToOneOrderIssueTests(SimpleTestCase):\n+    def test_onetoone_order_issue(self):\n+        class Document(models.Model):\n+            pass\n+\n+        # Alter the test to expect the bug and raise the specific error message\n+        with self.assertRaisesMessage(ImproperlyConfigured, \"__BUG__HERE__\"):\n+            class Picking(Document):\n+                document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+                origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n",
  "num_sent_chars": 4534485,
  "num_received_chars": 111614,
  "elapsed_time": 959.1578495502472,
  "lint_repair_count": 5,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}