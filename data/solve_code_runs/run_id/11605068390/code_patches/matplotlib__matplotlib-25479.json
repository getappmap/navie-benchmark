{
  "instance_id": "matplotlib__matplotlib-25479",
  "edit_test_file": "lib/matplotlib/tests/test_colorbar.py",
  "code_patch": "diff --git a/lib/matplotlib/cm.py b/lib/matplotlib/cm.py\nindex 38158db..e85ac52 100644\n--- a/lib/matplotlib/cm.py\n+++ b/lib/matplotlib/cm.py\n@@ -110,7 +110,7 @@ class ColormapRegistry(Mapping):\n         The colormap registry stores a copy of the given colormap, so that\n         future changes to the original colormap instance do not affect the\n         registered colormap. Think of this as the registry taking a snapshot\n-        of the colormap at registration.\n+        of the colormap at registration. The registered name becomes the colormap's name.\n \n         Parameters\n         ----------\n@@ -127,7 +127,11 @@ class ColormapRegistry(Mapping):\n         \"\"\"\n         _api.check_isinstance(colors.Colormap, cmap=cmap)\n \n-        name = name or cmap.name\n+        if name is None:\n+            name = cmap.name\n+        if name is None:\n+            raise ValueError(\"A name must be provided either through the name parameter \"\n+                           \"or the colormap's name attribute\")\n         if name in self:\n             if not force:\n                 # don't allow registering an already existing cmap\n@@ -145,7 +149,9 @@ class ColormapRegistry(Mapping):\n             _api.warn_external(f\"Overwriting the cmap {name!r} \"\n                                \"that was already in the registry.\")\n \n-        self._cmaps[name] = cmap.copy()\n+        registered_cmap = cmap.copy()\n+        registered_cmap.name = name  # Update the internal name to match registration\n+        self._cmaps[name] = registered_cmap\n \n     def unregister(self, name):\n         \"\"\"\n@@ -705,7 +711,7 @@ def _ensure_cmap(cmap):\n     ----------\n     cmap : None, str, Colormap\n \n-        - if a `Colormap`, return it\n+        - if a `Colormap`, return it (preserving its registered name if available)\n         - if a string, look it up in mpl.colormaps\n         - if None, look up the default color map in mpl.colormaps\n \n@@ -715,6 +721,10 @@ def _ensure_cmap(cmap):\n \n     \"\"\"\n     if isinstance(cmap, colors.Colormap):\n+        # If this colormap instance exists in the registry, ensure its name matches\n+        for name, registered_cmap in _colormaps.items():\n+            if registered_cmap is cmap:\n+                cmap.name = name\n         return cmap\n     cmap_name = cmap if cmap is not None else mpl.rcParams[\"image.cmap\"]\n     # use check_in_list to ensure type stability of the exception raised by\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_colormap_registration.py b/lib/matplotlib/tests/test_colormap_registration.py\nnew file mode 100644\nindex 0000000..bb35acc\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_colormap_registration.py\n@@ -0,0 +1,33 @@\n+import pytest\n+import matplotlib.pyplot as plt\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib as mpl\n+\n+def test_colormap_name_mismatch():\n+    \"\"\"\n+    Test that verifies the issue where a mismatch between a colormap's internal\n+    name and its registered name causes an error in plt.imshow().\n+    \"\"\"\n+    # Create colormap data\n+    cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],\n+                 [2.3e-03, 1.3e-03, 1.8e-02],\n+                 [3.3e-03, 2.3e-03, 2.4e-02]]\n+\n+    # Create colormap with internal name 'some_cmap_name'\n+    my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', cmap_data)\n+\n+    # Register colormap with different name 'my_cmap_name'\n+    plt.colormaps.register(cmap=my_cmap, name='my_cmap_name')\n+\n+    # Set the colormap\n+    plt.set_cmap('my_cmap_name')\n+\n+    # Attempt to use the colormap should raise ValueError due to name mismatch\n+    with pytest.raises(ValueError) as exc_info:\n+        plt.imshow([[1, 1], [2, 2]])\n+\n+    # Verify the error message contains the expected text\n+    assert \"'some_cmap_name' is not a valid value for cmap\" in str(exc_info.value)\n+\n+    # Clean up\n+    plt.close()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_colormap_registration_inverted.py b/lib/matplotlib/tests/test_colormap_registration_inverted.py\nnew file mode 100644\nindex 0000000..e9fd470\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_colormap_registration_inverted.py\n@@ -0,0 +1,38 @@\n+import pytest\n+import matplotlib.pyplot as plt\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib as mpl\n+\n+def test_colormap_name_mismatch():\n+    \"\"\"\n+    Test that verifies the issue where a mismatch between a colormap's internal\n+    name and its registered name causes an error in plt.imshow().\n+    \"\"\"\n+    # Create colormap data\n+    cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],\n+                 [2.3e-03, 1.3e-03, 1.8e-02],\n+                 [3.3e-03, 2.3e-03, 2.4e-02]]\n+\n+    # Create colormap with internal name 'some_cmap_name'\n+    my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', cmap_data)\n+\n+    # Register colormap with different name 'my_cmap_name'\n+    plt.colormaps.register(cmap=my_cmap, name='my_cmap_name')\n+\n+    # Set the colormap\n+    plt.set_cmap('my_cmap_name')\n+\n+    # The test should fail here because the colormap name mismatch is a bug\n+    try:\n+        plt.imshow([[1, 1], [2, 2]])\n+        # If we reach this point, the bug is not present (which is unexpected)\n+        plt.close()\n+        raise AssertionError(\"Expected ValueError due to colormap name mismatch\")\n+    except ValueError as e:\n+        if \"'some_cmap_name' is not a valid value for cmap\" in str(e):\n+            plt.close()\n+            raise AssertionError(\"__BUG__HERE__\")\n+        else:\n+            # If we get a different ValueError, re-raise it\n+            plt.close()\n+            raise\n\\ No newline at end of file\n",
  "num_sent_chars": 3348118,
  "num_received_chars": 61161,
  "elapsed_time": 781.5917553901672,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}