{
  "instance_id": "sphinx-doc__sphinx-9258",
  "edit_test_file": "tests/test_util_inspect.py",
  "code_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 7d39d80..6bb0424 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -113,11 +113,15 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n             return [nodes.Text(\"%s.%s\" % (unparse(node.value)[0], node.attr))]\n         elif isinstance(node, ast.BinOp):\n             result: List[Node] = unparse(node.left)\n-            result.extend(unparse(node.op))\n+            if isinstance(node.op, ast.BitOr):\n+                # Handle union type syntax (|)\n+                result.append(addnodes.desc_sig_punctuation('', ' | '))\n+            else:\n+                result.extend(unparse(node.op))\n             result.extend(unparse(node.right))\n             return result\n         elif isinstance(node, ast.BitOr):\n-            return [nodes.Text(' '), addnodes.desc_sig_punctuation('', '|'), nodes.Text(' ')]\n+            return [addnodes.desc_sig_punctuation('', ' | ')]\n         elif isinstance(node, ast.Constant):  # type: ignore\n             if node.value is Ellipsis:\n                 return [addnodes.desc_sig_punctuation('', \"...\")]\n@@ -175,7 +179,11 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n         result = unparse(tree)\n         for i, node in enumerate(result):\n             if isinstance(node, nodes.Text) and node.strip():\n-                result[i] = type_to_xref(str(node), env)\n+                # Convert each type name to a cross-reference\n+                result[i] = type_to_xref(str(node).strip(), env)\n+            elif isinstance(node, addnodes.desc_sig_punctuation) and node.astext() == ' | ':\n+                # Ensure consistent spacing around union operator\n+                result[i] = addnodes.desc_sig_punctuation('', ' | ')\n         return result\n     except SyntaxError:\n         return [type_to_xref(annotation, env)]\n",
  "test_patch": "diff --git a/tests/test_ext_autodoc_union_types.py b/tests/test_ext_autodoc_union_types.py\nnew file mode 100644\nindex 0000000..a6be89e\n--- /dev/null\n+++ b/tests/test_ext_autodoc_union_types.py\n@@ -0,0 +1,25 @@\n+\"\"\"\n+    test_ext_autodoc_union_types\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension with union types using | syntax.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import pytest\n+from sphinx.util import inspect\n+\n+\n+def test_signature_from_str_union_types():\n+    \"\"\"Test that union types using | syntax are not properly handled.\"\"\"\n+    signature = '(text: bytes | str) -> None'\n+    sig = inspect.signature_from_str(signature)\n+    \n+    # The test should verify that the current implementation doesn't properly parse\n+    # the bytes | str syntax and instead treats it as a literal string\n+    assert sig.parameters['text'].annotation == 'bytes | str'\n+    \n+    # This would be the expected behavior once the feature is implemented:\n+    # assert sig.parameters['text'].annotation == 'Union[bytes, str]'\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_ext_autodoc_union_types_inverted.py b/tests/test_ext_autodoc_union_types_inverted.py\nnew file mode 100644\nindex 0000000..589a70f\n--- /dev/null\n+++ b/tests/test_ext_autodoc_union_types_inverted.py\n@@ -0,0 +1,29 @@\n+\"\"\"\n+    test_ext_autodoc_union_types\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension with union types using | syntax.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import pytest\n+from sphinx.util import inspect\n+\n+\n+def test_signature_from_str_union_types():\n+    \"\"\"Test that union types using | syntax are properly handled.\"\"\"\n+    signature = '(text: bytes | str) -> None'\n+    sig = inspect.signature_from_str(signature)\n+    \n+    # The test should fail if the implementation doesn't properly parse\n+    # the bytes | str syntax into Union[bytes, str]\n+    actual_annotation = sig.parameters['text'].annotation\n+    expected_annotation = 'Union[bytes, str]'\n+    \n+    if actual_annotation == 'bytes | str':\n+        raise AssertionError('__BUG__HERE__')\n+        \n+    assert actual_annotation == expected_annotation, \\\n+        f\"Expected {expected_annotation}, but got {actual_annotation}\"\n\\ No newline at end of file\n",
  "num_sent_chars": 3536278,
  "num_received_chars": 69523,
  "elapsed_time": 608.185284614563,
  "lint_repair_count": 1,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}