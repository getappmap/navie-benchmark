{
  "instance_id": "django__django-15280",
  "edit_test_file": "tests/select_related_onetoone/tests.py",
  "code_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex fb66397..f4b6495 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1653,7 +1653,8 @@ class Prefetch:\n \n     def get_current_queryset(self, level):\n         if self.get_current_prefetch_to(level) == self.prefetch_to:\n-            return self.queryset\n+            # Return a clone to preserve deferred field settings\n+            return self.queryset._chain() if self.queryset else None\n         return None\n \n     def __eq__(self, other):\n@@ -1889,8 +1890,9 @@ def prefetch_one_level(instances, prefetcher, lookup, level):\n     # The 'values to be matched' must be hashable as they will be used\n     # in a dictionary.\n \n+    current_queryset = lookup.get_current_queryset(level)\n     rel_qs, rel_obj_attr, instance_attr, single, cache_name, is_descriptor = (\n-        prefetcher.get_prefetch_queryset(instances, lookup.get_current_queryset(level)))\n+        prefetcher.get_prefetch_queryset(instances, current_queryset))\n     # We have to handle the possibility that the QuerySet we just got back\n     # contains some prefetch_related lookups. We don't want to trigger the\n     # prefetch_related functionality by evaluating the query. Rather, we need\n@@ -1906,6 +1908,9 @@ def prefetch_one_level(instances, prefetcher, lookup, level):\n         # instance, so we access an internal instead of using public interface\n         # for performance reasons.\n         rel_qs._prefetch_related_lookups = ()\n+    # Preserve deferred field settings from the current queryset\n+    if current_queryset is not None:\n+        rel_qs.query.deferred_loading = current_queryset.query.deferred_loading\n \n     all_related_objects = list(rel_qs)\n \n@@ -1944,6 +1949,9 @@ def prefetch_one_level(instances, prefetcher, lookup, level):\n                 # cache_name points to a field name in obj.\n                 # This field is a descriptor for a related object.\n                 setattr(obj, cache_name, val)\n+                # Ensure deferred field settings are preserved on the cached instance\n+                if val is not None and lookup.queryset is not None:\n+                    val._deferred_fields = lookup.queryset.query.deferred_loading[0]\n             else:\n                 # No to_attr has been given for this prefetch operation and the\n                 # cache_name does not point to a descriptor. Store the value of\n",
  "test_patch": "diff --git a/tests/select_related_onetoone/test_deferred_fields_prefetch.py b/tests/select_related_onetoone/test_deferred_fields_prefetch.py\nnew file mode 100644\nindex 0000000..4a7a94b\n--- /dev/null\n+++ b/tests/select_related_onetoone/test_deferred_fields_prefetch.py\n@@ -0,0 +1,46 @@\n+from django.test import TestCase\n+from django.db.models import Prefetch\n+\n+from .models import User, UserProfile, UserStat, UserStatResult\n+\n+\n+class DeferredFieldsPrefetchTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test user\n+        cls.user = User.objects.create(username=\"test\")\n+        # Create profile for user\n+        cls.profile = UserProfile.objects.create(user=cls.user, state=\"CA\", city=\"San Francisco\")\n+        # Create results\n+        cls.results = UserStatResult.objects.create(results=\"test results\")\n+        # Create user stats\n+        cls.userstat = UserStat.objects.create(user=cls.user, posts=100, results=cls.results)\n+\n+    def test_deferred_fields_with_prefetch(self):\n+        \"\"\"\n+        Test that deferred fields work correctly when following prefetches back to the parent object.\n+        This reproduces the issue where accessing a deferred field on a prefetched parent object\n+        causes an unexpected database query.\n+        \"\"\"\n+        # Create a queryset that defers the 'posts' field on the outer UserStat query\n+        # and the 'results' field on the inner UserStat query through the prefetch\n+        queryset = UserStat.objects.only('user').prefetch_related(\n+            Prefetch(\n+                'user',\n+                queryset=User.objects.prefetch_related(\n+                    Prefetch(\n+                        'userstat',\n+                        queryset=UserStat.objects.only('results')\n+                    )\n+                )\n+            )\n+        )\n+\n+        # First query should execute the main queries\n+        with self.assertNumQueries(3):\n+            userstat = queryset.first()\n+\n+        # This should not cause any additional queries since 'results' was included\n+        # in the prefetch, but due to the bug it will cause an extra query\n+        with self.assertNumQueries(1):  # This assertion passes due to the bug\n+            self.assertEqual(userstat.user.userstat.posts, 100)\n",
  "test_inverted_patch": "diff --git a/tests/select_related_onetoone/test_deferred_fields_prefetch_inverted.py b/tests/select_related_onetoone/test_deferred_fields_prefetch_inverted.py\nnew file mode 100644\nindex 0000000..72a159c\n--- /dev/null\n+++ b/tests/select_related_onetoone/test_deferred_fields_prefetch_inverted.py\n@@ -0,0 +1,48 @@\n+from django.test import TestCase\n+from django.db.models import Prefetch\n+\n+from .models import User, UserProfile, UserStat, UserStatResult\n+\n+\n+class DeferredFieldsPrefetchTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test user\n+        cls.user = User.objects.create(username=\"test\")\n+        # Create profile for user\n+        cls.profile = UserProfile.objects.create(user=cls.user, state=\"CA\", city=\"San Francisco\")\n+        # Create results\n+        cls.results = UserStatResult.objects.create(results=\"test results\")\n+        # Create user stats\n+        cls.userstat = UserStat.objects.create(user=cls.user, posts=100, results=cls.results)\n+\n+    def test_deferred_fields_with_prefetch(self):\n+        \"\"\"\n+        Test that deferred fields work correctly when following prefetches back to the parent object.\n+        This test should FAIL when the bug is present (when an unexpected database query occurs).\n+        \"\"\"\n+        # Create a queryset that defers the 'posts' field on the outer UserStat query\n+        # and the 'results' field on the inner UserStat query through the prefetch\n+        queryset = UserStat.objects.only('user').prefetch_related(\n+            Prefetch(\n+                'user',\n+                queryset=User.objects.prefetch_related(\n+                    Prefetch(\n+                        'userstat',\n+                        queryset=UserStat.objects.only('results')\n+                    )\n+                )\n+            )\n+        )\n+\n+        # First query should execute the main queries\n+        with self.assertNumQueries(3):\n+            userstat = queryset.first()\n+\n+        # This should not cause any additional queries since 'posts' was included\n+        # in the prefetch. If an extra query occurs, the test should fail.\n+        try:\n+            with self.assertNumQueries(0):\n+                _ = userstat.user.userstat.posts\n+        except AssertionError:\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3842569,
  "num_received_chars": 90588,
  "elapsed_time": 795.33331990242,
  "lint_repair_count": 2,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}