{
  "instance_id": "astropy__astropy-14995",
  "edit_test_file": "astropy/nddata/tests/test_nddata.py",
  "code_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfc..40cc5b1 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -487,7 +487,7 @@ class NDArithmeticMixin:\n         Calculate the resulting mask.\n \n         This is implemented as the piecewise ``or`` operation if both have a\n-        mask.\n+        mask. If only one operand has a mask, that mask is copied to the result.\n \n         Parameters\n         ----------\n@@ -512,19 +512,26 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n-        # If only one mask is present we need not bother about any type checks\n-        if (\n-            self.mask is None and operand is not None and operand.mask is None\n-        ) or handle_mask is None:\n+        # If handle_mask is None, no mask propagation is requested\n+        if handle_mask is None:\n+            return None\n+\n+        # For collapse operations (operand is None), just copy the existing mask\n+        if operand is None:\n+            return deepcopy(self.mask) if self.mask is not None else None\n+\n+        # If neither operand has a mask, return None\n+        if self.mask is None and operand.mask is None:\n             return None\n-        elif self.mask is None and operand is not None:\n-            # Make a copy so there is no reference in the result.\n+\n+        # If only one operand has a mask, return a copy of that mask\n+        if self.mask is None:\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        if operand.mask is None:\n             return deepcopy(self.mask)\n-        else:\n-            # Now lets calculate the resulting mask (operation enforces copy)\n-            return handle_mask(self.mask, operand.mask, **kwds)\n+\n+        # Both operands have masks, apply the handle_mask operation\n+        return handle_mask(self.mask, operand.mask, **kwds)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n         \"\"\"\n",
  "test_patch": "diff --git a/astropy/nddata/tests/test_nddataref_mask_propagation.py b/astropy/nddata/tests/test_nddataref_mask_propagation.py\nnew file mode 100644\nindex 0000000..abf1a43\n--- /dev/null\n+++ b/astropy/nddata/tests/test_nddataref_mask_propagation.py\n@@ -0,0 +1,20 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+import pytest\n+\n+def test_nddataref_mask_propagation_issue():\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Test multiplication of mask by constant (mask * no mask)\n+    with pytest.raises(TypeError, match=\"unsupported operand type(s) for |: 'int' and 'NoneType'\"):\n+        nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\n+\n+    # Test multiplication of mask by no mask (mask * no mask)\n+    with pytest.raises(TypeError, match=\"unsupported operand type(s) for |: 'int' and 'NoneType'\"):\n+        nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\n",
  "test_inverted_patch": "diff --git a/astropy/nddata/tests/test_nddataref_mask_propagation_inverted.py b/astropy/nddata/tests/test_nddataref_mask_propagation_inverted.py\nnew file mode 100644\nindex 0000000..f826be0\n--- /dev/null\n+++ b/astropy/nddata/tests/test_nddataref_mask_propagation_inverted.py\n@@ -0,0 +1,24 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+import pytest\n+\n+def test_nddataref_mask_propagation_issue():\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Test multiplication of mask by constant (mask * no mask)\n+    with pytest.raises(Exception, match=\"__BUG__HERE__\"):\n+        result_mask = nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\n+        if result_mask is not None:\n+            raise Exception(\"__BUG__HERE__\")\n+\n+    # Test multiplication of mask by no mask (mask * no mask)\n+    with pytest.raises(Exception, match=\"__BUG__HERE__\"):\n+        result_mask = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\n+        if result_mask is not None:\n+            raise Exception(\"__BUG__HERE__\")\n",
  "num_sent_chars": 774582,
  "num_received_chars": 9165,
  "elapsed_time": 135.78294730186462,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 3,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}