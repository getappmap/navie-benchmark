{
  "instance_id": "sphinx-doc__sphinx-8638",
  "edit_test_file": "tests/test_ext_autodoc_autoclass.py",
  "code_patch": "diff --git a/sphinx/pycode/parser.py b/sphinx/pycode/parser.py\nindex d157c7c..0f062c4 100644\n--- a/sphinx/pycode/parser.py\n+++ b/sphinx/pycode/parser.py\n@@ -240,11 +240,11 @@ class VariableCommentPicker(ast.NodeVisitor):\n         if self.current_function:\n             if self.current_classes and self.context[-1] == \"__init__\":\n                 # store variable comments inside __init__ method of classes\n-                return self.context[:-1] + [name]\n+                return self.current_classes + [self.context[-1], name]\n             else:\n                 return None\n         else:\n-            return self.context + [name]\n+            return self.current_classes + self.context + [name]\n \n     def add_entry(self, name: str) -> None:\n         qualname = self.get_qualname_for(name)\n@@ -363,6 +363,10 @@ class VariableCommentPicker(ast.NodeVisitor):\n             for varname in varnames:\n                 self.add_variable_annotation(varname, node.type_comment)  # type: ignore\n \n+        # Ensure variable is linked to the correct context\n+        for varname in varnames:\n+            self.add_entry(varname)\n+\n         # check comments after assignment\n         parser = AfterCommentParser([current_line[node.col_offset:]] +\n                                     self.buffers[node.lineno:])\n",
  "test_patch": "diff --git a/tests/test_variable_link_resolution.py b/tests/test_variable_link_resolution.py\nnew file mode 100644\nindex 0000000..8a4d412\n--- /dev/null\n+++ b/tests/test_variable_link_resolution.py\n@@ -0,0 +1,40 @@\n+import pytest\n+from .test_ext_autodoc import do_autodoc\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_variable_link_resolution(app):\n+    # This test is designed to reproduce the issue where instance variables\n+    # link to other variables of the same name in the project.\n+    options = {'members': True, 'inherited-members': True}\n+    actual = do_autodoc(app, 'class', 'target.instance_variable.Bar', options)\n+    \n+    # Check if the output incorrectly links to other variables of the same name\n+    # The expected output should not contain any links to unrelated variables\n+    expected_output = [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.instance_variable',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring foo',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr3',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+    ]\n+    \n+    # Assert that the actual output matches the expected output\n+    # If the issue is present, this assertion will fail\n+    assert list(actual) == expected_output\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_variable_link_resolution_inverted.py b/tests/test_variable_link_resolution_inverted.py\nnew file mode 100644\nindex 0000000..352fc86\n--- /dev/null\n+++ b/tests/test_variable_link_resolution_inverted.py\n@@ -0,0 +1,41 @@\n+import pytest\n+from .test_ext_autodoc import do_autodoc\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_variable_link_resolution(app):\n+    # This test is designed to reproduce the issue where instance variables\n+    # link to other variables of the same name in the project.\n+    options = {'members': True, 'inherited-members': True}\n+    actual = do_autodoc(app, 'class', 'target.instance_variable.Bar', options)\n+    \n+    # Check if the output incorrectly links to other variables of the same name\n+    # The expected output should not contain any links to unrelated variables\n+    expected_output = [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.instance_variable',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring foo',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr3',\n+        '      :module: target.instance_variable',\n+        '',\n+        '      docstring bar',\n+        '',\n+    ]\n+    \n+    # Assert that the actual output does not match the expected output\n+    # If the issue is present, this assertion will fail with the specified error message\n+    if list(actual) == expected_output:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 3951391,
  "num_received_chars": 80502,
  "elapsed_time": 1401.205501794815,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": false,
  "pass_to_fail": true,
  "fail_to_pass": true,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}