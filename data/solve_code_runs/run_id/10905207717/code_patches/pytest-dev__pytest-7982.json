{
  "instance_id": "pytest-dev__pytest-7982",
  "edit_test_file": null,
  "code_patch": "diff --git a/doc/en/example/pythoncollection.rst b/doc/en/example/pythoncollection.rst\nindex c2f0348..7129633 100644\n--- a/doc/en/example/pythoncollection.rst\n+++ b/doc/en/example/pythoncollection.rst\n@@ -25,6 +25,8 @@ by passing the ``--ignore=path`` option on the cli. ``pytest`` allows multiple\n             |-- test_world_02.py\n             '-- test_world_03.py\n \n+Note: Symlinked directories within these paths will also be collected by default.\n+\n Now if you invoke ``pytest`` with ``--ignore=tests/foobar/test_foobar_03.py --ignore=tests/hello/``,\n you will see that ``pytest`` only collects test-modules, which do not match the patterns specified:\n \n@@ -237,6 +239,8 @@ You can easily instruct ``pytest`` to discover tests from every Python file:\n     [pytest]\n     python_files = *.py\n \n+Note: Symlinked directories will be followed and their contents collected by default.\n+\n However, many projects will have a ``setup.py`` which they don't want to be\n imported. Moreover, there may files only importable by a specific python\n version. For such cases you can dynamically define files to be ignored by\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 418405,
  "num_received_chars": 7437,
  "elapsed_time": 131.7261757850647,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}