{
  "instance_id": "astropy__astropy-13579",
  "edit_test_file": null,
  "code_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b0..2f2c781 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -140,6 +140,9 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n \n         self._slices_pixel = self._slices_array[::-1]\n \n+        # Adjust PCij matrix for sliced dimensions\n+        self._adjust_pc_matrix()\n+\n         # figure out which pixel dimensions have been kept, then use axis correlation\n         # matrix to figure out which world dims are kept\n         self._pixel_keep = np.nonzero([not isinstance(self._slices_pixel[ip], numbers.Integral)\n@@ -251,7 +254,7 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                world_arrays_new.append(0.)  # Use 0 instead of 1 for dropped dimensions\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 579344,
  "num_received_chars": 9214,
  "elapsed_time": 143.75673151016235,
  "lint_repair_count": 0,
  "test_generation_attempts": 0,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}