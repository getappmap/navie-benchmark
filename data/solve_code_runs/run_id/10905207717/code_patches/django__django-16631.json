{
  "instance_id": "django__django-16631",
  "edit_test_file": "tests/auth_tests/test_tokens.py",
  "code_patch": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 09cc2b5..87fcb68 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -42,11 +42,15 @@ class PasswordResetTokenGenerator:\n         Return a token that can be used once to do a password reset\n         for the given user.\n         \"\"\"\n-        return self._make_token_with_timestamp(\n-            user,\n-            self._num_seconds(self._now()),\n-            self.secret,\n-        )\n+        for secret in [self.secret, *self.secret_fallbacks]:\n+            token = self._make_token_with_timestamp(\n+                user,\n+                self._num_seconds(self._now()),\n+                secret,\n+            )\n+            if token:\n+                return token\n+        return None\n \n     def check_token(self, user, token):\n         \"\"\"\n@@ -71,15 +75,10 @@ class PasswordResetTokenGenerator:\n                 self._make_token_with_timestamp(user, ts, secret),\n                 token,\n             ):\n-                break\n-        else:\n-            return False\n-\n-        # Check the timestamp is within limit.\n-        if (self._num_seconds(self._now()) - ts) > settings.PASSWORD_RESET_TIMEOUT:\n-            return False\n-\n-        return True\n+                # Check the timestamp is within limit.\n+                if (self._num_seconds(self._now()) - ts) <= settings.PASSWORD_RESET_TIMEOUT:\n+                    return True\n+        return False\n \n     def _make_token_with_timestamp(self, user, timestamp, secret):\n         # timestamp is number of seconds since 2001-1-1. Converted to base 36,\n",
  "test_patch": "diff --git a/tests/auth_tests/test_secret_key_fallbacks.py b/tests/auth_tests/test_secret_key_fallbacks.py\nnew file mode 100644\nindex 0000000..bfb206e\n--- /dev/null\n+++ b/tests/auth_tests/test_secret_key_fallbacks.py\n@@ -0,0 +1,40 @@\n+from django.test import TestCase, override_settings\n+from django.contrib.auth import get_user_model\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.contrib.sessions.middleware import SessionMiddleware\n+from django.test.client import RequestFactory\n+\n+User = get_user_model()\n+\n+class SecretKeyFallbacksSessionTest(TestCase):\n+    @override_settings(\n+        SECRET_KEY=\"newsecret\",\n+        SECRET_KEY_FALLBACKS=[\"oldsecret\"],\n+    )\n+    def test_secret_key_fallbacks_not_used_for_sessions(self):\n+        # Create a user and simulate a login\n+        user = User.objects.create_user(\"sessiontestuser\", \"test@example.com\", \"testpw\")\n+        request = RequestFactory().get('/')\n+        middleware = SessionMiddleware(lambda req: None)\n+        middleware.process_request(request)\n+        request.session.save()\n+\n+        # Simulate setting the session auth hash with the old secret\n+        token_generator = PasswordResetTokenGenerator()\n+        token_generator.secret = \"oldsecret\"\n+        session_auth_hash = token_generator.make_token(user)\n+        request.session['HASH_SESSION_KEY'] = session_auth_hash\n+\n+        # Rotate the secret key\n+        with self.settings(SECRET_KEY=\"newsecret\", SECRET_KEY_FALLBACKS=[\"oldsecret\"]):\n+            # Simulate a request with the new secret key\n+            request = RequestFactory().get('/')\n+            middleware.process_request(request)\n+            request.session.save()\n+\n+            # Check if the session is still valid\n+            self.assertNotEqual(\n+                request.session.get('HASH_SESSION_KEY'),\n+                session_auth_hash,\n+                \"Session should be invalidated due to secret key rotation.\"\n+            )\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/auth_tests/test_secret_key_fallbacks_inverted.py b/tests/auth_tests/test_secret_key_fallbacks_inverted.py\nnew file mode 100644\nindex 0000000..cadd658\n--- /dev/null\n+++ b/tests/auth_tests/test_secret_key_fallbacks_inverted.py\n@@ -0,0 +1,40 @@\n+from django.test import TestCase, override_settings\n+from django.contrib.auth import get_user_model\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.contrib.sessions.middleware import SessionMiddleware\n+from django.test.client import RequestFactory\n+\n+User = get_user_model()\n+\n+class SecretKeyFallbacksSessionTest(TestCase):\n+    @override_settings(\n+        SECRET_KEY=\"newsecret\",\n+        SECRET_KEY_FALLBACKS=[\"oldsecret\"],\n+    )\n+    def test_secret_key_fallbacks_not_used_for_sessions(self):\n+        # Create a user and simulate a login\n+        user = User.objects.create_user(\"sessiontestuser\", \"test@example.com\", \"testpw\")\n+        request = RequestFactory().get('/')\n+        middleware = SessionMiddleware(lambda req: None)\n+        middleware.process_request(request)\n+        request.session.save()\n+\n+        # Simulate setting the session auth hash with the old secret\n+        token_generator = PasswordResetTokenGenerator()\n+        token_generator.secret = \"oldsecret\"\n+        session_auth_hash = token_generator.make_token(user)\n+        request.session['HASH_SESSION_KEY'] = session_auth_hash\n+\n+        # Rotate the secret key\n+        with self.settings(SECRET_KEY=\"newsecret\", SECRET_KEY_FALLBACKS=[\"oldsecret\"]):\n+            # Simulate a request with the new secret key\n+            request = RequestFactory().get('/')\n+            middleware.process_request(request)\n+            request.session.save()\n+\n+            # Check if the session is still valid\n+            self.assertEqual(\n+                request.session.get('HASH_SESSION_KEY'),\n+                session_auth_hash,\n+                \"__BUG__HERE__\"\n+            )\n\\ No newline at end of file\n",
  "num_sent_chars": 2420469,
  "num_received_chars": 51498,
  "elapsed_time": 1096.3710868358612,
  "lint_repair_count": 8,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}