{
  "instance_id": "django__django-16631",
  "edit_test_file": "tests/auth_tests/test_tokens.py",
  "code_patch": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c..2d7511b 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -89,6 +89,9 @@ def authenticate(request=None, **credentials):\n     user_login_failed.send(\n         sender=__name__, credentials=_clean_credentials(credentials), request=request\n     )\n+    # Attempt to re-sign the session with the current secret key\n+    if request and request.user.is_authenticated:\n+        update_session_auth_hash(request, request.user)\n \n \n def login(request, user, backend=None):\n\ndiff --git a/django/contrib/sessions/backends/base.py b/django/contrib/sessions/backends/base.py\nindex 050e738..1be5f27 100644\n--- a/django/contrib/sessions/backends/base.py\n+++ b/django/contrib/sessions/backends/base.py\n@@ -100,10 +100,15 @@ class SessionBase:\n \n     def decode(self, session_data):\n         try:\n-            return signing.loads(\n-                session_data, salt=self.key_salt, serializer=self.serializer\n-            )\n-        except signing.BadSignature:\n+            # Attempt to decode using the current secret and fallbacks\n+            secrets_to_try = [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', [])\n+            for secret in secrets_to_try:\n+                try:\n+                    return signing.loads(\n+                        session_data, salt=self.key_salt, serializer=self.serializer, secret=secret\n+                    )\n+                except signing.BadSignature:\n+                    continue\n             logger = logging.getLogger(\"django.security.SuspiciousSession\")\n             logger.warning(\"Session data corrupted\")\n         except Exception:\n\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e700..feeb543 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,7 +15,7 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n+def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\", fallbacks=None):\n     \"\"\"\n     Return the HMAC of 'value', using a key generated from key_salt and a\n     secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n@@ -34,14 +34,15 @@ def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n         raise InvalidAlgorithm(\n             \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n         ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+\n+    # Attempt to validate using the current secret and fallbacks\n+    secrets_to_try = [secret] + (fallbacks or [])\n+    for secret in secrets_to_try:\n+        key = hasher(key_salt + secret).digest()\n+        hmac_result = hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        if hmac_result:\n+            return hmac_result\n+    return None\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
  "test_patch": "diff --git a/tests/auth_tests/test_secret_key_fallbacks.py b/tests/auth_tests/test_secret_key_fallbacks.py\nnew file mode 100644\nindex 0000000..bfb206e\n--- /dev/null\n+++ b/tests/auth_tests/test_secret_key_fallbacks.py\n@@ -0,0 +1,40 @@\n+from django.test import TestCase, override_settings\n+from django.contrib.auth import get_user_model\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.contrib.sessions.middleware import SessionMiddleware\n+from django.test.client import RequestFactory\n+\n+User = get_user_model()\n+\n+class SecretKeyFallbacksSessionTest(TestCase):\n+    @override_settings(\n+        SECRET_KEY=\"newsecret\",\n+        SECRET_KEY_FALLBACKS=[\"oldsecret\"],\n+    )\n+    def test_secret_key_fallbacks_not_used_for_sessions(self):\n+        # Create a user and simulate a login\n+        user = User.objects.create_user(\"sessiontestuser\", \"test@example.com\", \"testpw\")\n+        request = RequestFactory().get('/')\n+        middleware = SessionMiddleware(lambda req: None)\n+        middleware.process_request(request)\n+        request.session.save()\n+\n+        # Simulate setting the session auth hash with the old secret\n+        token_generator = PasswordResetTokenGenerator()\n+        token_generator.secret = \"oldsecret\"\n+        session_auth_hash = token_generator.make_token(user)\n+        request.session['HASH_SESSION_KEY'] = session_auth_hash\n+\n+        # Rotate the secret key\n+        with self.settings(SECRET_KEY=\"newsecret\", SECRET_KEY_FALLBACKS=[\"oldsecret\"]):\n+            # Simulate a request with the new secret key\n+            request = RequestFactory().get('/')\n+            middleware.process_request(request)\n+            request.session.save()\n+\n+            # Check if the session is still valid\n+            self.assertNotEqual(\n+                request.session.get('HASH_SESSION_KEY'),\n+                session_auth_hash,\n+                \"Session should be invalidated due to secret key rotation.\"\n+            )\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/auth_tests/test_secret_key_fallbacks_inverted.py b/tests/auth_tests/test_secret_key_fallbacks_inverted.py\nnew file mode 100644\nindex 0000000..cadd658\n--- /dev/null\n+++ b/tests/auth_tests/test_secret_key_fallbacks_inverted.py\n@@ -0,0 +1,40 @@\n+from django.test import TestCase, override_settings\n+from django.contrib.auth import get_user_model\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.contrib.sessions.middleware import SessionMiddleware\n+from django.test.client import RequestFactory\n+\n+User = get_user_model()\n+\n+class SecretKeyFallbacksSessionTest(TestCase):\n+    @override_settings(\n+        SECRET_KEY=\"newsecret\",\n+        SECRET_KEY_FALLBACKS=[\"oldsecret\"],\n+    )\n+    def test_secret_key_fallbacks_not_used_for_sessions(self):\n+        # Create a user and simulate a login\n+        user = User.objects.create_user(\"sessiontestuser\", \"test@example.com\", \"testpw\")\n+        request = RequestFactory().get('/')\n+        middleware = SessionMiddleware(lambda req: None)\n+        middleware.process_request(request)\n+        request.session.save()\n+\n+        # Simulate setting the session auth hash with the old secret\n+        token_generator = PasswordResetTokenGenerator()\n+        token_generator.secret = \"oldsecret\"\n+        session_auth_hash = token_generator.make_token(user)\n+        request.session['HASH_SESSION_KEY'] = session_auth_hash\n+\n+        # Rotate the secret key\n+        with self.settings(SECRET_KEY=\"newsecret\", SECRET_KEY_FALLBACKS=[\"oldsecret\"]):\n+            # Simulate a request with the new secret key\n+            request = RequestFactory().get('/')\n+            middleware.process_request(request)\n+            request.session.save()\n+\n+            # Check if the session is still valid\n+            self.assertEqual(\n+                request.session.get('HASH_SESSION_KEY'),\n+                session_auth_hash,\n+                \"__BUG__HERE__\"\n+            )\n\\ No newline at end of file\n",
  "num_sent_chars": 1934787,
  "num_received_chars": 85013,
  "elapsed_time": 654.8553273677826,
  "lint_repair_count": 12,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": 200897
}