{
  "instance_id": "sphinx-doc__sphinx-8551",
  "edit_test_file": "tests/test_pycode.py",
  "code_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex 76db00d..f317992 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -820,6 +820,15 @@ class GoogleDocstring:\n                     self._annotations = get_type_hints(self._obj, None, localns)\n                 if _name in self._annotations:\n                     return stringify_annotation(self._annotations[_name])\n+        \n+        # Attempt to resolve the name within the current module context\n+        if self._app and self._app.env:\n+            current_module = self._app.env.temp_data.get('py:module')\n+            if current_module:\n+                qualified_name = f\"{current_module}.{_name}\"\n+                if qualified_name in self._annotations:\n+                    return stringify_annotation(self._annotations[qualified_name])\n+        \n         # No annotation found\n         return \"\"\n \n",
  "test_patch": "diff --git a/tests/test_cross_reference_warnings.py b/tests/test_cross_reference_warnings.py\nnew file mode 100644\nindex 0000000..03e3da3\n--- /dev/null\n+++ b/tests/test_cross_reference_warnings.py\n@@ -0,0 +1,115 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import ApplicationError\n+from io import StringIO\n+import os\n+\n+class TestCrossReferenceWarnings(unittest.TestCase):\n+    def setUp(self):\n+        self.srcdir = os.path.abspath('source')\n+        self.outdir = os.path.abspath('build')\n+        self.doctreedir = os.path.abspath('build/doctrees')\n+        self.confdir = self.srcdir\n+\n+        # Create necessary directories\n+        os.makedirs(self.srcdir, exist_ok=True)\n+        os.makedirs(self.outdir, exist_ok=True)\n+        os.makedirs(self.doctreedir, exist_ok=True)\n+\n+        # Create a minimal conf.py\n+        with open(os.path.join(self.srcdir, 'conf.py'), 'w') as f:\n+            f.write(\"extensions = []\\n\")\n+\n+        # Create the index.rst file with the content that reproduces the issue\n+        with open(os.path.join(self.srcdir, 'index.rst'), 'w') as f:\n+            f.write(\"\"\"\n+.. py:class:: mod.A\n+.. py:class:: mod.submod.A\n+\n+.. py:function:: f()\n+\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param mod.A a:\n+    :param mod.submod.A b:\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a:\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod.submod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a: BUG: links to mod.A instead of mod.submod.A\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\"\"\")\n+\n+    def test_cross_reference_warnings(self):\n+        # Capture the warnings\n+        warning_stream = StringIO()\n+        app = Sphinx(\n+            srcdir=self.srcdir,\n+            confdir=self.confdir,\n+            outdir=self.outdir,\n+            doctreedir=self.doctreedir,\n+            buildername='html',\n+            warning=warning_stream\n+        )\n+\n+        try:\n+            app.build()\n+        except ApplicationError as e:\n+            self.fail(f\"Sphinx build failed with ApplicationError: {e}\")\n+\n+        warnings = warning_stream.getvalue()\n+        self.assertIn(\"more than one target found for cross-reference 'A'\", warnings)\n+\n+    def tearDown(self):\n+        # Clean up the created directories and files\n+        if os.path.exists(self.srcdir):\n+            for root, dirs, files in os.walk(self.srcdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.srcdir)\n+        if os.path.exists(self.outdir):\n+            for root, dirs, files in os.walk(self.outdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.outdir)\n+        if os.path.exists(self.doctreedir):\n+            for root, dirs, files in os.walk(self.doctreedir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.doctreedir)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_cross_reference_warnings_inverted.py b/tests/test_cross_reference_warnings_inverted.py\nnew file mode 100644\nindex 0000000..8a84290\n--- /dev/null\n+++ b/tests/test_cross_reference_warnings_inverted.py\n@@ -0,0 +1,117 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import ApplicationError\n+from io import StringIO\n+import os\n+\n+class TestCrossReferenceWarnings(unittest.TestCase):\n+    def setUp(self):\n+        self.srcdir = os.path.abspath('source')\n+        self.outdir = os.path.abspath('build')\n+        self.doctreedir = os.path.abspath('build/doctrees')\n+        self.confdir = self.srcdir\n+\n+        # Create necessary directories\n+        os.makedirs(self.srcdir, exist_ok=True)\n+        os.makedirs(self.outdir, exist_ok=True)\n+        os.makedirs(self.doctreedir, exist_ok=True)\n+\n+        # Create a minimal conf.py\n+        with open(os.path.join(self.srcdir, 'conf.py'), 'w') as f:\n+            f.write(\"extensions = []\\n\")\n+\n+        # Create the index.rst file with the content that reproduces the issue\n+        with open(os.path.join(self.srcdir, 'index.rst'), 'w') as f:\n+            f.write(\"\"\"\n+.. py:class:: mod.A\n+.. py:class:: mod.submod.A\n+\n+.. py:function:: f()\n+\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param mod.A a:\n+    :param mod.submod.A b:\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a:\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\n+.. py:currentmodule:: mod.submod\n+\n+.. py:function:: f()\n+\n+    - :py:class:`A`\n+    - :py:class:`mod.A`\n+    - :py:class:`mod.submod.A`\n+\n+    :param A a: BUG: links to mod.A instead of mod.submod.A\n+    :param mod.A b:\n+    :param mod.submod.A c:\n+    :rtype: A\n+    :rtype: mod.A\n+    :rtype: mod.submod.A\n+\"\"\")\n+\n+    def test_cross_reference_warnings(self):\n+        # Capture the warnings\n+        warning_stream = StringIO()\n+        app = Sphinx(\n+            srcdir=self.srcdir,\n+            confdir=self.confdir,\n+            outdir=self.outdir,\n+            doctreedir=self.doctreedir,\n+            buildername='html',\n+            warning=warning_stream\n+        )\n+\n+        try:\n+            app.build()\n+        except ApplicationError as e:\n+            self.fail(f\"Sphinx build failed with ApplicationError: {e}\")\n+\n+        warnings = warning_stream.getvalue()\n+        # Alter the test to fail when the issue is observed\n+        if \"more than one target found for cross-reference 'A'\" in warnings:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+    def tearDown(self):\n+        # Clean up the created directories and files\n+        if os.path.exists(self.srcdir):\n+            for root, dirs, files in os.walk(self.srcdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.srcdir)\n+        if os.path.exists(self.outdir):\n+            for root, dirs, files in os.walk(self.outdir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.outdir)\n+        if os.path.exists(self.doctreedir):\n+            for root, dirs, files in os.walk(self.doctreedir, topdown=False):\n+                for name in files:\n+                    os.remove(os.path.join(root, name))\n+                for name in dirs:\n+                    os.rmdir(os.path.join(root, name))\n+            os.rmdir(self.doctreedir)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 2206255,
  "num_received_chars": 55296,
  "elapsed_time": 448.73525762557983,
  "lint_repair_count": 3,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": 370470
}