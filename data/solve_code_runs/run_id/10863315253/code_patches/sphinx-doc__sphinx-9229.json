{
  "instance_id": "sphinx-doc__sphinx-9229",
  "edit_test_file": "tests/test_util_typing.py",
  "code_patch": "diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f216e87..bb1ef53 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -507,6 +507,7 @@ class TypeAliasForwardRef:\n     \"\"\"Pseudo typing class for autodoc_type_aliases.\n \n     This avoids the error on evaluating the type inside `get_type_hints()`.\n+    Ensures that multiline docstrings are preserved and prioritized.\n     \"\"\"\n     def __init__(self, name: str) -> None:\n         self.name = name\n@@ -520,7 +521,11 @@ class TypeAliasForwardRef:\n \n \n class TypeAliasModule:\n-    \"\"\"Pseudo module class for autodoc_type_aliases.\"\"\"\n+    \"\"\"Pseudo module class for autodoc_type_aliases.\n+\n+    Ensures that multiline docstrings for type aliases are captured and\n+    prioritized over default alias messages.\n+    \"\"\"\n \n     def __init__(self, modname: str, mapping: Dict[str, str]) -> None:\n         self.__modname = modname\n@@ -833,6 +838,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     * partial functions\n     * inherited docstring\n     * inherited decorated methods\n+    * type aliases with multiline docstrings\n     \"\"\"\n     doc = attrgetter(obj, '__doc__', None)\n     if ispartial(obj) and doc == obj.__class__.__doc__:\n",
  "test_patch": "diff --git a/tests/test_ext_autodoc_type_alias_docstrings.py b/tests/test_ext_autodoc_type_alias_docstrings.py\nnew file mode 100644\nindex 0000000..bccca33\n--- /dev/null\n+++ b/tests/test_ext_autodoc_type_alias_docstrings.py\n@@ -0,0 +1,58 @@\n+import sys\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from docutils.parsers.rst import Parser\n+from docutils.frontend import OptionParser\n+from docutils.utils import new_document\n+from docutils import nodes\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_type_alias_docstring_inconsistency(app: SphinxTestApp):\n+    # Prepare the document\n+    doc = new_document('test', OptionParser(components=(Parser,)).get_default_values())\n+    parser = Parser()\n+    parser.parse(\n+        \"\"\"\n+        .. py:data:: ScaffoldOpts\n+           :module: file\n+\n+           Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.\n+           Should be treated as immutable (if required, copy before changing).\n+\n+           Please notice some behaviours given by the options **SHOULD** be observed. For example,\n+           files should be overwritten when the **force** option is ``True``. Similarly when\n+           **pretend** is ``True``, no operation should be really performed, but any action should\n+           be logged as if realized.\n+\n+        .. py:data:: FileContents\n+           :module: file\n+\n+           When the file content is ``None``, the file should not be written to\n+           disk (empty files are represented by an empty string ``\"\"`` as content).\n+\n+        .. py:data:: FileOp\n+           :module: file\n+\n+           Signature of functions considered file operations::\n+\n+               Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]\n+\n+           - **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed\n+             in the disk.\n+           - **contents** (:obj:`FileContents`): usually a string that represents a text content\n+             of the file. :obj:`None` indicates the file should not be written.\n+           - **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.\n+\n+           If the file is written (or more generally changed, such as new access permissions),\n+           by convention they should return the :obj:`file path <pathlib.Path>`.\n+           If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**\n+           might return :obj:`None` if a pre-existing file in the disk is not modified.\n+\n+           .. note::\n+               A **FileOp** usually has side effects (e.g. write a file to the disk), see\n+               :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.\n+        \"\"\", doc)\n+\n+    # Check for the presence of the expected docstring content\n+    scaffold_opts = doc.traverse(nodes.field_list)\n+    assert len(scaffold_opts) == 0, \"Expected docstring content is missing for some type aliases\"\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/test_ext_autodoc_type_alias_docstrings_inverted.py b/tests/test_ext_autodoc_type_alias_docstrings_inverted.py\nnew file mode 100644\nindex 0000000..a6ea26a\n--- /dev/null\n+++ b/tests/test_ext_autodoc_type_alias_docstrings_inverted.py\n@@ -0,0 +1,58 @@\n+import sys\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from docutils.parsers.rst import Parser\n+from docutils.frontend import OptionParser\n+from docutils.utils import new_document\n+from docutils import nodes\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_type_alias_docstring_inconsistency(app: SphinxTestApp):\n+    # Prepare the document\n+    doc = new_document('test', OptionParser(components=(Parser,)).get_default_values())\n+    parser = Parser()\n+    parser.parse(\n+        \"\"\"\n+        .. py:data:: ScaffoldOpts\n+           :module: file\n+\n+           Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.\n+           Should be treated as immutable (if required, copy before changing).\n+\n+           Please notice some behaviours given by the options **SHOULD** be observed. For example,\n+           files should be overwritten when the **force** option is ``True``. Similarly when\n+           **pretend** is ``True``, no operation should be really performed, but any action should\n+           be logged as if realized.\n+\n+        .. py:data:: FileContents\n+           :module: file\n+\n+           When the file content is ``None``, the file should not be written to\n+           disk (empty files are represented by an empty string ``\"\"`` as content).\n+\n+        .. py:data:: FileOp\n+           :module: file\n+\n+           Signature of functions considered file operations::\n+\n+               Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]\n+\n+           - **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed\n+             in the disk.\n+           - **contents** (:obj:`FileContents`): usually a string that represents a text content\n+             of the file. :obj:`None` indicates the file should not be written.\n+           - **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.\n+\n+           If the file is written (or more generally changed, such as new access permissions),\n+           by convention they should return the :obj:`file path <pathlib.Path>`.\n+           If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**\n+           might return :obj:`None` if a pre-existing file in the disk is not modified.\n+\n+           .. note::\n+               A **FileOp** usually has side effects (e.g. write a file to the disk), see\n+               :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.\n+        \"\"\", doc)\n+\n+    # Check for the presence of the expected docstring content\n+    scaffold_opts = doc.traverse(nodes.field_list)\n+    assert len(scaffold_opts) != 0, \"__BUG__HERE__\"\n\\ No newline at end of file\n",
  "num_sent_chars": 1001717,
  "num_received_chars": 68633,
  "elapsed_time": 335.11306047439575,
  "lint_repair_count": 4,
  "test_generation_attempts": 0,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": "PASSED",
  "appmap_data_file_count": 1,
  "appmap_data_context_size": null
}