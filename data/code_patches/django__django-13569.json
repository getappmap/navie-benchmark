{
  "instance_id": "django__django-13569",
  "edit_test_file": "tests/ordering/tests.py",
  "code_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 1391846..f336862 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -348,6 +348,9 @@ class BaseExpression:\n \n     def get_group_by_cols(self, alias=None):\n         if not self.contains_aggregate:\n+            # Exclude Random() from GROUP BY\n+            if isinstance(self, Func) and self.function == 'RANDOM':\n+                return []\n             return [self]\n         cols = []\n         for source in self.get_source_expressions():\n",
  "test_patch": "diff --git a/tests/ordering/test_order_by_random_breaks_queryset_aggregation.py b/tests/ordering/test_order_by_random_breaks_queryset_aggregation.py\nnew file mode 100644\nindex 0000000..eebcc63\n--- /dev/null\n+++ b/tests/ordering/test_order_by_random_breaks_queryset_aggregation.py\n@@ -0,0 +1,20 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Count\n+\n+class Thing(models.Model):\n+    pass\n+\n+class Related(models.Model):\n+    thing = models.ForeignKey(Thing, on_delete=models.CASCADE)\n+\n+class OrderByRandomBreaksAggregationTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.thing = Thing.objects.create()\n+        cls.related_objects = [Related.objects.create(thing=cls.thing) for _ in range(2)]\n+\n+    def test_order_by_random_breaks_aggregation(self):\n+        queryset = Thing.objects.annotate(rc=Count('related')).order_by('?').values('id', 'rc')\n+        expected_output = [{'id': self.thing.id, 'rc': 1}, {'id': self.thing.id, 'rc': 1}]\n+        self.assertQuerysetEqual(queryset, expected_output, transform=lambda x: x)\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/tests/ordering/test_order_by_random_breaks_queryset_aggregation_inverted.py b/tests/ordering/test_order_by_random_breaks_queryset_aggregation_inverted.py\nnew file mode 100644\nindex 0000000..27a43f4\n--- /dev/null\n+++ b/tests/ordering/test_order_by_random_breaks_queryset_aggregation_inverted.py\n@@ -0,0 +1,23 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Count\n+\n+class Thing(models.Model):\n+    pass\n+\n+class Related(models.Model):\n+    thing = models.ForeignKey(Thing, on_delete=models.CASCADE)\n+\n+class OrderByRandomBreaksAggregationTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.thing = Thing.objects.create()\n+        cls.related_objects = [Related.objects.create(thing=cls.thing) for _ in range(2)]\n+\n+    def test_order_by_random_breaks_aggregation(self):\n+        queryset = Thing.objects.annotate(rc=Count('related')).order_by('?').values('id', 'rc')\n+        # The expected output should reflect the correct aggregation count\n+        expected_output = [{'id': self.thing.id, 'rc': 2}]\n+        # This assertion will now fail if the bug is present, raising the specified error message\n+        if list(queryset) != expected_output:\n+            raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 1846383,
  "num_received_chars": 78958,
  "elapsed_time": 579.0363178253174,
  "lint_repair_count": 5,
  "test_generation_attempts": 2,
  "code_generation_attempts": 7,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null,
  "code_patch_issue-46": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 04e430a..7a3e5f0 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -128,7 +128,8 @@ class SQLCompiler:\n         for expr, (sql, params, is_ref) in order_by:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n-            if not is_ref:\n+            # Also, skip RANDOM() expressions as they should not affect grouping.\n+            if not is_ref and not isinstance(expr, Random):\n                 expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n"
}