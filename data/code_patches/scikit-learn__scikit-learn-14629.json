{
  "instance_id": "scikit-learn__scikit-learn-14629",
  "edit_test_file": "sklearn/model_selection/tests/test_validation.py",
  "code_patch": "diff --git a/sklearn/multioutput.py b/sklearn/multioutput.py\nindex 463b72d..f1280dd 100644\n--- a/sklearn/multioutput.py\n+++ b/sklearn/multioutput.py\n@@ -325,6 +325,11 @@ class MultiOutputClassifier(MultiOutputEstimator, ClassifierMixin):\n     def __init__(self, estimator, n_jobs=None):\n         super().__init__(estimator, n_jobs)\n \n+    @property\n+    def classes_(self):\n+        \"\"\"Collect classes_ from each estimator.\"\"\"\n+        return [estimator.classes_ for estimator in self.estimators_]\n+\n     def predict_proba(self, X):\n         \"\"\"Probability estimates.\n         Returns prediction probabilities for each class of each output.\n",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_cross_val_predict_multioutput.py b/sklearn/model_selection/tests/test_cross_val_predict_multioutput.py\nnew file mode 100644\nindex 0000000..11f1f38\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_cross_val_predict_multioutput.py\n@@ -0,0 +1,19 @@\n+\"\"\"Test cross_val_predict with MultiOutputClassifier\"\"\"\n+\n+import pytest\n+from sklearn.datasets import make_multilabel_classification\n+from sklearn.multioutput import MultiOutputClassifier\n+from sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n+from sklearn.model_selection import cross_val_predict\n+\n+def test_cross_val_predict_multioutput_predict_proba():\n+    X, Y = make_multilabel_classification()\n+\n+    mo_lda = MultiOutputClassifier(LinearDiscriminantAnalysis())\n+    \n+    # This should work fine\n+    pred = cross_val_predict(mo_lda, X, Y, cv=5)\n+    \n+    # This should raise an AttributeError\n+    with pytest.raises(AttributeError, match=\"'MultiOutputClassifier' object has no attribute 'classes_'\"):\n+        pred_proba = cross_val_predict(mo_lda, X, Y, cv=5, method='predict_proba')\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sklearn/model_selection/tests/test_cross_val_predict_multioutput_inverted.py b/sklearn/model_selection/tests/test_cross_val_predict_multioutput_inverted.py\nnew file mode 100644\nindex 0000000..dcc085b\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_cross_val_predict_multioutput_inverted.py\n@@ -0,0 +1,21 @@\n+\"\"\"Test cross_val_predict with MultiOutputClassifier\"\"\"\n+\n+import pytest\n+from sklearn.datasets import make_multilabel_classification\n+from sklearn.multioutput import MultiOutputClassifier\n+from sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n+from sklearn.model_selection import cross_val_predict\n+\n+def test_cross_val_predict_multioutput_predict_proba():\n+    X, Y = make_multilabel_classification()\n+\n+    mo_lda = MultiOutputClassifier(LinearDiscriminantAnalysis())\n+    \n+    # This should work fine\n+    pred = cross_val_predict(mo_lda, X, Y, cv=5)\n+    \n+    # This should raise an error indicating the presence of the bug\n+    try:\n+        pred_proba = cross_val_predict(mo_lda, X, Y, cv=5, method='predict_proba')\n+    except AttributeError as e:\n+        raise AssertionError(\"__BUG__HERE__\") from e\n\\ No newline at end of file\n",
  "num_sent_chars": 1183464,
  "num_received_chars": 43562,
  "elapsed_time": 524.0017807483673,
  "lint_repair_count": 4,
  "test_generation_attempts": 1,
  "code_generation_attempts": 4,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null,
  "code_patch_issue-46": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a2..70c76a4 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -28,6 +28,7 @@ from ..metrics.scorer import check_scoring, _check_multimetric_scoring\n from ..exceptions import FitFailedWarning\n from ._split import check_cv\n from ..preprocessing import LabelEncoder\n+from ..multioutput import MultiOutputClassifier\n \n \n __all__ = ['cross_validate', 'cross_val_score', 'cross_val_predict',\n@@ -748,14 +749,21 @@ def cross_val_predict(estimator, X, y=None, groups=None, cv=None,\n                         'predict_log_proba']\n     if encode:\n         y = np.asarray(y)\n-        if y.ndim == 1:\n-            le = LabelEncoder()\n-            y = le.fit_transform(y)\n-        elif y.ndim == 2:\n+        if isinstance(estimator, MultiOutputClassifier):\n             y_enc = np.zeros_like(y, dtype=np.int)\n-            for i_label in range(y.shape[1]):\n-                y_enc[:, i_label] = LabelEncoder().fit_transform(y[:, i_label])\n+            for i_label, estimator in enumerate(estimator.estimators_):\n+                le = LabelEncoder()\n+                y_enc[:, i_label] = le.fit_transform(y[:, i_label])\n             y = y_enc\n+        else:\n+            if y.ndim == 1:\n+                le = LabelEncoder()\n+                y = le.fit_transform(y)\n+            elif y.ndim == 2:\n+                y_enc = np.zeros_like(y, dtype=np.int)\n+                for i_label in range(y.shape[1]):\n+                    y_enc[:, i_label] = LabelEncoder().fit_transform(y[:, i_label])\n+                y = y_enc\n \n     # We clone the estimator to make sure that all the folds are\n     # independent, and that it is pickle-able.\n@@ -855,10 +863,16 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n     predictions = func(X_test)\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            if isinstance(estimator, MultiOutputClassifier):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n"
}