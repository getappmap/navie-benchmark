{
  "edit_test_file": "tests/test_config.py",
  "test_patch": "diff --git a/tests/test_ext_literal_nitpick.py b/tests/test_ext_literal_nitpick.py\nnew file mode 100644\nindex 0000000..0cb5bab\n--- /dev/null\n+++ b/tests/test_ext_literal_nitpick.py\n@@ -0,0 +1,39 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import SphinxError\n+from sphinx.testing.path import path\n+\n+class TestLiteralAnnotationNitpick(unittest.TestCase):\n+    def test_literal_annotation_nitpick_warning(self):\n+        # Create a temporary directory for the test\n+        tempdir = path(self._testMethodName)\n+        tempdir.makedirs(exist_ok=True)\n+\n+        # Create a temporary conf.py file\n+        (tempdir / 'conf.py').write_text(\"\"\"\n+extensions = ['sphinx.ext.autodoc']\n+nitpicky = True\n+\"\"\", encoding='utf-8')\n+\n+        # Create a temporary module with Literal annotations\n+        (tempdir / 'module.py').write_text(\"\"\"\n+import typing\n+\n+@typing.overload\n+def foo(x: \"typing.Literal[True]\") -> int: ...\n+@typing.overload\n+def foo(x: \"typing.Literal[False]\") -> str: ...\n+def foo(x: bool):\n+    '''a func'''\n+    return 1 if x else \"foo\"\n+\"\"\", encoding='utf-8')\n+\n+        # Initialize a Sphinx application\n+        app = Sphinx(srcdir=tempdir, confdir=tempdir, outdir=tempdir / '_build', doctreedir=tempdir / '_doctrees', buildername='html')\n+        \n+        # Expecting a SphinxError due to nitpick warning on Literal\n+        with self.assertRaises(SphinxError):\n+            app.builder.build_all()\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "inverted_patch": "diff --git a/tests/test_ext_literal_nitpick_inverted.py b/tests/test_ext_literal_nitpick_inverted.py\nnew file mode 100644\nindex 0000000..3faa809\n--- /dev/null\n+++ b/tests/test_ext_literal_nitpick_inverted.py\n@@ -0,0 +1,41 @@\n+import unittest\n+from sphinx.application import Sphinx\n+from sphinx.errors import SphinxError\n+from sphinx.testing.path import path\n+\n+class TestLiteralAnnotationNitpick(unittest.TestCase):\n+    def test_literal_annotation_nitpick_warning(self):\n+        # Create a temporary directory for the test\n+        tempdir = path(self._testMethodName)\n+        tempdir.makedirs(exist_ok=True)\n+\n+        # Create a temporary conf.py file\n+        (tempdir / 'conf.py').write_text(\"\"\"\n+extensions = ['sphinx.ext.autodoc']\n+nitpicky = True\n+\"\"\", encoding='utf-8')\n+\n+        # Create a temporary module with Literal annotations\n+        (tempdir / 'module.py').write_text(\"\"\"\n+import typing\n+\n+@typing.overload\n+def foo(x: \"typing.Literal[True]\") -> int: ...\n+@typing.overload\n+def foo(x: \"typing.Literal[False]\") -> str: ...\n+def foo(x: bool):\n+    '''a func'''\n+    return 1 if x else \"foo\"\n+\"\"\", encoding='utf-8')\n+\n+        # Initialize a Sphinx application\n+        app = Sphinx(srcdir=tempdir, confdir=tempdir, outdir=tempdir / '_build', doctreedir=tempdir / '_doctrees', buildername='html')\n+        \n+        # Expecting a SphinxError due to nitpick warning on Literal\n+        try:\n+            app.builder.build_all()\n+        except SphinxError:\n+            self.fail(\"__BUG__HERE__\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n"
}