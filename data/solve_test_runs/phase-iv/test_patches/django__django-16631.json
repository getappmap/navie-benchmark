{
  "edit_test_file": "tests/auth_tests/test_tokens.py",
  "test_patch": "diff --git a/tests/auth_tests/test_secret_key_fallbacks.py b/tests/auth_tests/test_secret_key_fallbacks.py\nnew file mode 100644\nindex 0000000..efdb2fa\n--- /dev/null\n+++ b/tests/auth_tests/test_secret_key_fallbacks.py\n@@ -0,0 +1,25 @@\n+from django.conf import settings\n+from django.contrib.auth.models import User\n+from django.test import TestCase, override_settings\n+from django.utils.crypto import salted_hmac\n+\n+class SecretKeyFallbacksSessionTest(TestCase):\n+    @override_settings(\n+        SECRET_KEY=\"newsecret\",\n+        SECRET_KEY_FALLBACKS=[\"oldsecret\"],\n+    )\n+    def test_session_auth_hash_with_secret_key_fallbacks(self):\n+        user = User.objects.create_user(\"sessiontestuser\", \"test@example.com\", \"testpw\")\n+        # Simulate session hash generation with the old secret key\n+        old_session_hash = salted_hmac(\n+            \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\",\n+            user.password,\n+            secret=\"oldsecret\",\n+            algorithm=\"sha256\",\n+        ).hexdigest()\n+\n+        # Check if the session hash generated with the new secret key matches the old one\n+        new_session_hash = user.get_session_auth_hash()\n+        \n+        # The test should pass if the session hash does not match, indicating the issue\n+        self.assertNotEqual(old_session_hash, new_session_hash)\n",
  "inverted_patch": null
}