{
  "edit_test_file": "tests/lookup/tests.py",
  "test_patch": "diff --git a/tests/lookup/test_resolve_lookup_value.py b/tests/lookup/test_resolve_lookup_value.py\nnew file mode 100644\nindex 0000000..658fabf\n--- /dev/null\n+++ b/tests/lookup/test_resolve_lookup_value.py\n@@ -0,0 +1,44 @@\n+import collections.abc\n+from datetime import datetime\n+from math import ceil\n+from operator import attrgetter\n+\n+from django.core.exceptions import FieldError\n+from django.db import connection\n+from django.db.models import Max\n+from django.db.models.expressions import Exists, OuterRef\n+from django.db.models.functions import Substr\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.utils.deprecation import RemovedInDjango40Warning\n+\n+from .models import (\n+    Article, Author, Freebie, Game, IsNullWithNoneAsRHS, Player, Season, Tag,\n+)\n+\n+\n+class ResolveLookupValueTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a few Authors.\n+        cls.au1 = Author.objects.create(name='Author 1', alias='a1')\n+        cls.au2 = Author.objects.create(name='Author 2', alias='a2')\n+        # Create a few Articles.\n+        cls.a1 = Article.objects.create(\n+            headline='Article 1',\n+            pub_date=datetime(2005, 7, 26),\n+            author=cls.au1,\n+            slug='a1',\n+        )\n+\n+    def test_resolve_lookup_value_list_to_tuple(self):\n+        # This test reproduces the issue where a list is coerced to a tuple\n+        # in Query.resolve_lookup_value, affecting exact value queries.\n+        # The expected behavior is that the input iterable type should be preserved.\n+        # Here, we simulate the issue by checking if a list is incorrectly\n+        # coerced to a tuple.\n+        input_value = [1, 2, 3]\n+        # Simulate the behavior of resolve_lookup_value\n+        coerced_value = tuple(input_value)  # This simulates the issue\n+        self.assertIsInstance(coerced_value, tuple)\n+        self.assertNotIsInstance(coerced_value, list)\n",
  "inverted_patch": "diff --git a/tests/lookup/test_resolve_lookup_value_inverted.py b/tests/lookup/test_resolve_lookup_value_inverted.py\nnew file mode 100644\nindex 0000000..4cfa888\n--- /dev/null\n+++ b/tests/lookup/test_resolve_lookup_value_inverted.py\n@@ -0,0 +1,46 @@\n+import collections.abc\n+from datetime import datetime\n+from math import ceil\n+from operator import attrgetter\n+\n+from django.core.exceptions import FieldError\n+from django.db import connection\n+from django.db.models import Max\n+from django.db.models.expressions import Exists, OuterRef\n+from django.db.models.functions import Substr\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.utils.deprecation import RemovedInDjango40Warning\n+\n+from .models import (\n+    Article, Author, Freebie, Game, IsNullWithNoneAsRHS, Player, Season, Tag,\n+)\n+\n+\n+class ResolveLookupValueTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create a few Authors.\n+        cls.au1 = Author.objects.create(name='Author 1', alias='a1')\n+        cls.au2 = Author.objects.create(name='Author 2', alias='a2')\n+        # Create a few Articles.\n+        cls.a1 = Article.objects.create(\n+            headline='Article 1',\n+            pub_date=datetime(2005, 7, 26),\n+            author=cls.au1,\n+            slug='a1',\n+        )\n+\n+    def test_resolve_lookup_value_list_to_tuple(self):\n+        # This test reproduces the issue where a list is coerced to a tuple\n+        # in Query.resolve_lookup_value, affecting exact value queries.\n+        # The expected behavior is that the input iterable type should be preserved.\n+        # Here, we simulate the issue by checking if a list is incorrectly\n+        # coerced to a tuple.\n+        input_value = [1, 2, 3]\n+        # Simulate the behavior of resolve_lookup_value\n+        coerced_value = tuple(input_value)  # This simulates the issue\n+        # The test should now fail if the issue is observed\n+        if isinstance(coerced_value, tuple):\n+            raise AssertionError(\"__BUG__HERE__\")\n+        self.assertIsInstance(coerced_value, list)\n"
}