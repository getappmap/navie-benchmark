{
  "edit_test_file": "tests/test_application.py",
  "test_patch": "diff --git a/tests/test_source_read_include.py b/tests/test_source_read_include.py\nnew file mode 100644\nindex 0000000..92d74f9\n--- /dev/null\n+++ b/tests/test_source_read_include.py\n@@ -0,0 +1,80 @@\n+\"\"\"Test source-read event handling with included files.\"\"\"\n+\n+import os\n+from io import StringIO\n+from pathlib import Path\n+from textwrap import dedent\n+\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html')\n+def test_source_read_include_replacement(tmp_path, monkeypatch):\n+    \"\"\"Test that source-read event properly handles included files.\n+    \n+    This test verifies the issue where source-read event does not properly\n+    modify content from included files, even though the handler is called\n+    for them.\n+    \"\"\"\n+    # Given\n+    srcdir = tmp_path / 'src'\n+    srcdir.mkdir()\n+\n+    # Create the test files\n+    (srcdir / 'conf.py').write_text(dedent('''\n+        extensions = ['test_extension']\n+    '''))\n+\n+    (srcdir / 'index.rst').write_text(dedent('''\n+        Test Document\n+        ============\n+\n+        .. include:: included.rst\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    (srcdir / 'included.rst').write_text(dedent('''\n+        Included Content\n+        ===============\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    # Create the test extension\n+    (srcdir / 'test_extension.py').write_text(dedent('''\n+        def source_read_handler(app, docname, source):\n+            result = source[0]\n+            result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+            source[0] = result\n+\n+        def setup(app):\n+            app.connect('source-read', source_read_handler)\n+            return {\n+                'version': '1.0',\n+                'parallel_read_safe': True,\n+                'parallel_write_safe': True\n+            }\n+    '''))\n+\n+    # When\n+    monkeypatch.syspath_prepend(srcdir)\n+    app = SphinxTestApp(\n+        srcdir=srcdir,\n+        status=StringIO(),\n+        warning=StringIO()\n+    )\n+    app.build()\n+\n+    # Then\n+    output_file = Path(app.outdir) / 'index.html'\n+    content = output_file.read_text()\n+\n+    # Verify that &REPLACE_ME; still appears in the output from the included file,\n+    # demonstrating the issue\n+    assert '&amp;REPLACE_ME;' in content, \\\n+        \"The replacement did not fail as expected - issue not reproduced\"\n+\n+    # Clean up\n+    app.cleanup()\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/test_source_read_include_inverted.py b/tests/test_source_read_include_inverted.py\nnew file mode 100644\nindex 0000000..ec7f069\n--- /dev/null\n+++ b/tests/test_source_read_include_inverted.py\n@@ -0,0 +1,80 @@\n+\"\"\"Test source-read event handling with included files.\"\"\"\n+\n+import os\n+from io import StringIO\n+from pathlib import Path\n+from textwrap import dedent\n+\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html')\n+def test_source_read_include_replacement(tmp_path, monkeypatch):\n+    \"\"\"Test that source-read event properly handles included files.\n+    \n+    This test verifies the issue where source-read event does not properly\n+    modify content from included files, even though the handler is called\n+    for them.\n+    \"\"\"\n+    # Given\n+    srcdir = tmp_path / 'src'\n+    srcdir.mkdir()\n+\n+    # Create the test files\n+    (srcdir / 'conf.py').write_text(dedent('''\n+        extensions = ['test_extension']\n+    '''))\n+\n+    (srcdir / 'index.rst').write_text(dedent('''\n+        Test Document\n+        ============\n+\n+        .. include:: included.rst\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    (srcdir / 'included.rst').write_text(dedent('''\n+        Included Content\n+        ===============\n+\n+        &REPLACE_ME;\n+    '''))\n+\n+    # Create the test extension\n+    (srcdir / 'test_extension.py').write_text(dedent('''\n+        def source_read_handler(app, docname, source):\n+            result = source[0]\n+            result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+            source[0] = result\n+\n+        def setup(app):\n+            app.connect('source-read', source_read_handler)\n+            return {\n+                'version': '1.0',\n+                'parallel_read_safe': True,\n+                'parallel_write_safe': True\n+            }\n+    '''))\n+\n+    # When\n+    monkeypatch.syspath_prepend(srcdir)\n+    app = SphinxTestApp(\n+        srcdir=srcdir,\n+        status=StringIO(),\n+        warning=StringIO()\n+    )\n+    app.build()\n+\n+    # Then\n+    output_file = Path(app.outdir) / 'index.html'\n+    content = output_file.read_text()\n+\n+    # Verify that all &REPLACE_ME; instances have been replaced\n+    if '&amp;REPLACE_ME;' in content:\n+        app.cleanup()\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Clean up\n+    app.cleanup()\n\\ No newline at end of file\n"
}