{
  "edit_test_file": "tests/template_tests/test_callables.py",
  "test_patch": "diff --git a/tests/template_tests/test_enum_in_templates.py b/tests/template_tests/test_enum_in_templates.py\nnew file mode 100644\nindex 0000000..56290c3\n--- /dev/null\n+++ b/tests/template_tests/test_enum_in_templates.py\n@@ -0,0 +1,44 @@\n+from unittest import TestCase\n+\n+from django.db import models\n+from django.template import Context, Engine\n+\n+\n+class YearInSchool(models.TextChoices):\n+    FRESHMAN = 'FR', 'Freshman'\n+    SOPHOMORE = 'SO', 'Sophomore'\n+    JUNIOR = 'JR', 'Junior'\n+    SENIOR = 'SR', 'Senior'\n+    GRADUATE = 'GR', 'Graduate'\n+\n+\n+class Student:\n+    def __init__(self, year_in_school):\n+        self.year_in_school = year_in_school\n+\n+\n+class EnumInTemplatesTest(TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.engine = Engine()\n+        super().setUpClass()\n+\n+    def test_enum_comparison_in_template(self):\n+        \"\"\"\n+        Test that demonstrates enums cannot be used in template comparisons\n+        because they are treated as callable objects.\n+        \"\"\"\n+        student = Student(YearInSchool.FRESHMAN)\n+        context = Context({\n+            'student': student,\n+            'YearInSchool': YearInSchool,\n+        })\n+\n+        template = self.engine.from_string(\n+            '{% if student.year_in_school == YearInSchool.FRESHMAN %}yes{% else %}no{% endif %}'\n+        )\n+        \n+        # The comparison should evaluate to 'yes' since student.year_in_school is FRESHMAN,\n+        # but instead it will be 'no' because YearInSchool is called as a function\n+        # rather than being used as an enum for comparison\n+        self.assertEqual(template.render(context), 'no')\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/template_tests/test_enum_in_templates_inverted.py b/tests/template_tests/test_enum_in_templates_inverted.py\nnew file mode 100644\nindex 0000000..20b2674\n--- /dev/null\n+++ b/tests/template_tests/test_enum_in_templates_inverted.py\n@@ -0,0 +1,47 @@\n+from unittest import TestCase\n+\n+from django.db import models\n+from django.template import Context, Engine\n+\n+\n+class YearInSchool(models.TextChoices):\n+    FRESHMAN = 'FR', 'Freshman'\n+    SOPHOMORE = 'SO', 'Sophomore'\n+    JUNIOR = 'JR', 'Junior'\n+    SENIOR = 'SR', 'Senior'\n+    GRADUATE = 'GR', 'Graduate'\n+\n+\n+class Student:\n+    def __init__(self, year_in_school):\n+        self.year_in_school = year_in_school\n+\n+\n+class EnumInTemplatesTest(TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.engine = Engine()\n+        super().setUpClass()\n+\n+    def test_enum_comparison_in_template(self):\n+        \"\"\"\n+        Test that verifies enum comparisons in templates work correctly.\n+        The test should fail when enums are treated as callable objects in templates.\n+        \"\"\"\n+        student = Student(YearInSchool.FRESHMAN)\n+        context = Context({\n+            'student': student,\n+            'YearInSchool': YearInSchool,\n+        })\n+\n+        template = self.engine.from_string(\n+            '{% if student.year_in_school == YearInSchool.FRESHMAN %}yes{% else %}no{% endif %}'\n+        )\n+        \n+        result = template.render(context)\n+        \n+        # This should fail when the bug is present (when result is 'no')\n+        if result != 'yes':\n+            raise AssertionError('__BUG__HERE__')\n+        \n+        self.assertEqual(result, 'yes')\n\\ No newline at end of file\n"
}