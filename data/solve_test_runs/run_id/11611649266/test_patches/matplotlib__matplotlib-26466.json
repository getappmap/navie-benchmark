{
  "edit_test_file": "lib/matplotlib/tests/test_axes.py",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_annotation_array_copy.py b/lib/matplotlib/tests/test_annotation_array_copy.py\nnew file mode 100644\nindex 0000000..dfb09ea\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_array_copy.py\n@@ -0,0 +1,32 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+def test_annotation_array_copy():\n+    \"\"\"\n+    Test that modifying arrays passed to annotate() affects the annotation.\n+    This reproduces the bug where arrays are not copied when creating annotations.\n+    \"\"\"\n+    # Create two figures - one with modified array and one without\n+    fig_test, ax_test = plt.subplots()\n+    fig_ref, ax_ref = plt.subplots()\n+    \n+    # Set same limits for both axes\n+    for ax in [ax_test, ax_ref]:\n+        ax.set_xlim(-5, 5)\n+        ax.set_ylim(-3, 3)\n+\n+    # Test figure - array will be modified after annotation\n+    xy_0 = np.array((-4, 1))\n+    xy_f = np.array((-1, 1))\n+    ax_test.annotate('', xytext=xy_f, xy=xy_0, arrowprops=dict(arrowstyle='<->'))\n+    xy_0[1] = 3  # This modifies the arrow position\n+    \n+    # Reference figure - array will not be modified\n+    xy_0_ref = np.array((-4, 1)) \n+    xy_f_ref = np.array((-1, 1))\n+    ax_ref.annotate('', xytext=xy_f_ref, xy=xy_0_ref, arrowprops=dict(arrowstyle='<->'))\n+    \n+    # The test passes if the figures are different, since this verifies\n+    # that modifying the array affects the annotation\n+    assert not np.allclose(xy_0, xy_0_ref)\n\\ No newline at end of file\n",
  "inverted_patch": null
}