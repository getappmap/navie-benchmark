{
  "edit_test_file": "tests/migrations/test_autodetector.py",
  "test_patch": "diff --git a/tests/migrations/test_migration_import_models.py b/tests/migrations/test_migration_import_models.py\nnew file mode 100644\nindex 0000000..79b71b9\n--- /dev/null\n+++ b/tests/migrations/test_migration_import_models.py\n@@ -0,0 +1,60 @@\n+from django.db import migrations, models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+class TestMigrationImportModels(TestCase):\n+    \"\"\"Test that migrations properly handle model imports.\"\"\"\n+\n+    def test_migration_missing_models_import(self):\n+        \"\"\"Test that migrations include models import when using custom model bases.\"\"\"\n+        # Define a custom mixin class\n+        class MyMixin:\n+            pass\n+\n+        # Define a custom field\n+        class MyField(models.TextField):\n+            pass\n+\n+        # Define the abstract base model\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        # Create the model states\n+        model = ModelState(\n+            \"app\",\n+            \"MyModel\",\n+            [\n+                (\"name\", MyField(primary_key=True)),\n+            ],\n+            bases=(\"app.models.MyMixin\", \"models.Model\"),\n+            options={\"abstract\": False},\n+        )\n+\n+        # Make the project states\n+        before = ProjectState()\n+        after = ProjectState()\n+        after.add_model(model)\n+\n+        # Make autodetector\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Get the CreateModel operation\n+        self.assertIn(\"app\", changes)\n+        self.assertEqual(len(changes[\"app\"]), 1)\n+        self.assertEqual(len(changes[\"app\"][0].operations), 1)\n+        operation = changes[\"app\"][0].operations[0]\n+\n+        # Verify the operation attributes\n+        self.assertEqual(operation.name, \"MyModel\")\n+        self.assertEqual(operation.bases, (\"app.models.MyMixin\", \"models.Model\"))\n+        self.assertEqual(operation.options, {\"abstract\": False})\n+\n+        # The fields should include the custom field\n+        self.assertEqual(len(operation.fields), 1)\n+        name_field = operation.fields[0]\n+        self.assertEqual(name_field[0], \"name\")\n+        self.assertIsInstance(name_field[1], MyField)\n+        self.assertTrue(name_field[1].primary_key)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/migrations/test_migration_import_models_inverted.py b/tests/migrations/test_migration_import_models_inverted.py\nnew file mode 100644\nindex 0000000..940c186\n--- /dev/null\n+++ b/tests/migrations/test_migration_import_models_inverted.py\n@@ -0,0 +1,62 @@\n+from django.db import migrations, models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.writer import MigrationWriter\n+\n+\n+class TestMigrationImportModels(TestCase):\n+    \"\"\"Test that migrations properly handle model imports.\"\"\"\n+\n+    def test_migration_missing_models_import(self):\n+        \"\"\"Test that migrations include models import when using custom model bases.\"\"\"\n+        # Define a custom mixin class\n+        class MyMixin:\n+            pass\n+\n+        # Define a custom field\n+        class MyField(models.TextField):\n+            pass\n+\n+        # Define the abstract base model\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        # Create the model states\n+        model = ModelState(\n+            \"app\",\n+            \"MyModel\",\n+            [\n+                (\"name\", MyField(primary_key=True)),\n+            ],\n+            bases=(\"app.models.MyMixin\", \"models.Model\"),\n+            options={\"abstract\": False},\n+        )\n+\n+        # Make the project states\n+        before = ProjectState()\n+        after = ProjectState()\n+        after.add_model(model)\n+\n+        # Make autodetector\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Get the migration\n+        migration = changes[\"app\"][0]\n+        \n+        # Write the migration to string\n+        writer = MigrationWriter(migration)\n+        migration_string = writer.as_string()\n+        \n+        # Check if 'from django.db import models' is in the imports\n+        if \"from django.db import models\" not in migration_string:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify the imports are correct by attempting to compile the migration\n+        try:\n+            compile(migration_string, \"migration.py\", \"exec\")\n+        except NameError as e:\n+            if \"name 'models' is not defined\" in str(e):\n+                raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n"
}