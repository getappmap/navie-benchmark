{
  "edit_test_file": "tests/staticfiles_tests/test_storage.py",
  "test_patch": "diff --git a/tests/staticfiles_tests/test_hashed_files_mixin_post_process.py b/tests/staticfiles_tests/test_hashed_files_mixin_post_process.py\nnew file mode 100644\nindex 0000000..00bc95b\n--- /dev/null\n+++ b/tests/staticfiles_tests/test_hashed_files_mixin_post_process.py\n@@ -0,0 +1,67 @@\n+import os\n+from io import StringIO\n+from unittest import mock\n+\n+from django.contrib.staticfiles import storage\n+from django.core.management import call_command\n+from django.test import override_settings\n+\n+from .cases import CollectionTestCase\n+from .settings import TEST_ROOT\n+\n+\n+class TestHashedFilesMixinPostProcess(CollectionTestCase):\n+    \"\"\"\n+    Test that HashedFilesMixin's post_process() yields multiple times for the same file.\n+    \"\"\"\n+    def setUp(self):\n+        super().setUp()\n+        self.output = StringIO()\n+\n+    @override_settings(\n+        STATICFILES_STORAGE='django.contrib.staticfiles.storage.ManifestStaticFilesStorage',\n+        STATICFILES_DIRS=[os.path.join(TEST_ROOT, 'project', 'css')],\n+    )\n+    def test_post_process_yields_multiple_times(self):\n+        \"\"\"\n+        Test that the same file is yielded multiple times during post-processing,\n+        which leads to incorrect stats and potentially redundant processing.\n+        \"\"\"\n+        # Create a CSS file that references another CSS file\n+        css_dir = os.path.join(TEST_ROOT, 'project', 'css')\n+        os.makedirs(css_dir, exist_ok=True)\n+        \n+        with open(os.path.join(css_dir, 'base.css'), 'w') as f:\n+            f.write('@import url(\"other.css\");')\n+        \n+        with open(os.path.join(css_dir, 'other.css'), 'w') as f:\n+            f.write('body { color: red; }')\n+\n+        # Mock the post_processed_files list to track how many times each file is processed\n+        processed_files = []\n+        original_post_process = storage.staticfiles_storage.post_process\n+\n+        def mock_post_process(*args, **kwargs):\n+            for item in original_post_process(*args, **kwargs):\n+                processed_files.append(item[0])  # item[0] is the original path\n+                yield item\n+\n+        with mock.patch.object(storage.staticfiles_storage, 'post_process', side_effect=mock_post_process):\n+            call_command('collectstatic', interactive=False, verbosity=0)\n+\n+        # Count occurrences of each file in processed_files\n+        file_counts = {}\n+        for file in processed_files:\n+            file_counts[file] = file_counts.get(file, 0) + 1\n+\n+        # Assert that at least one file was processed multiple times\n+        multiple_processed = any(count > 1 for count in file_counts.values())\n+        self.assertTrue(\n+            multiple_processed,\n+            \"Expected at least one file to be processed multiple times, \"\n+            \"but each file was only processed once\"\n+        )\n+\n+        # Clean up the test files\n+        os.unlink(os.path.join(css_dir, 'base.css'))\n+        os.unlink(os.path.join(css_dir, 'other.css'))\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/staticfiles_tests/test_hashed_files_mixin_post_process_inverted.py b/tests/staticfiles_tests/test_hashed_files_mixin_post_process_inverted.py\nnew file mode 100644\nindex 0000000..1394144\n--- /dev/null\n+++ b/tests/staticfiles_tests/test_hashed_files_mixin_post_process_inverted.py\n@@ -0,0 +1,71 @@\n+import os\n+from io import StringIO\n+from unittest import mock\n+\n+from django.contrib.staticfiles import storage\n+from django.core.management import call_command\n+from django.test import override_settings\n+\n+from .cases import CollectionTestCase\n+from .settings import TEST_ROOT\n+\n+\n+class TestHashedFilesMixinPostProcess(CollectionTestCase):\n+    \"\"\"\n+    Test that HashedFilesMixin's post_process() should not yield multiple times for the same file.\n+    \"\"\"\n+    def setUp(self):\n+        super().setUp()\n+        self.output = StringIO()\n+\n+    @override_settings(\n+        STATICFILES_STORAGE='django.contrib.staticfiles.storage.ManifestStaticFilesStorage',\n+        STATICFILES_DIRS=[os.path.join(TEST_ROOT, 'project', 'css')],\n+    )\n+    def test_post_process_should_not_yield_multiple_times(self):\n+        \"\"\"\n+        Test that files should not be yielded multiple times during post-processing,\n+        as this leads to incorrect stats and potentially redundant processing.\n+        \"\"\"\n+        # Create a CSS file that references another CSS file\n+        css_dir = os.path.join(TEST_ROOT, 'project', 'css')\n+        os.makedirs(css_dir, exist_ok=True)\n+        \n+        with open(os.path.join(css_dir, 'base.css'), 'w') as f:\n+            f.write('@import url(\"other.css\");')\n+        \n+        with open(os.path.join(css_dir, 'other.css'), 'w') as f:\n+            f.write('body { color: red; }')\n+\n+        # Track processed files\n+        processed_files = []\n+        original_post_process = storage.staticfiles_storage.post_process\n+\n+        def mock_post_process(*args, **kwargs):\n+            for item in original_post_process(*args, **kwargs):\n+                processed_files.append(item[0])  # item[0] is the original path\n+                yield item\n+\n+        with mock.patch.object(storage.staticfiles_storage, 'post_process', side_effect=mock_post_process):\n+            call_command('collectstatic', interactive=False, verbosity=0)\n+\n+        # Count occurrences of each file in processed_files\n+        file_counts = {}\n+        for file in processed_files:\n+            file_counts[file] = file_counts.get(file, 0) + 1\n+\n+        # Check if any file was processed multiple times\n+        multiple_processed_files = [\n+            file for file, count in file_counts.items() if count > 1\n+        ]\n+\n+        if multiple_processed_files:\n+            error_message = (\n+                f\"__BUG__HERE__ Files processed multiple times: {multiple_processed_files}. \"\n+                f\"Counts: {', '.join(f'{f}: {file_counts[f]}' for f in multiple_processed_files)}\"\n+            )\n+            raise AssertionError(error_message)\n+\n+        # Clean up the test files\n+        os.unlink(os.path.join(css_dir, 'base.css'))\n+        os.unlink(os.path.join(css_dir, 'other.css'))\n\\ No newline at end of file\n"
}