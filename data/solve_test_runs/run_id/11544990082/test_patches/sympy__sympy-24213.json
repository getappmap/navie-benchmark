{
  "edit_test_file": "sympy/physics/units/tests/test_unitsystem.py",
  "test_patch": "diff --git a/sympy/physics/units/tests/test_dimension_addition.py b/sympy/physics/units/tests/test_dimension_addition.py\nnew file mode 100644\nindex 0000000..a2aaf08\n--- /dev/null\n+++ b/sympy/physics/units/tests/test_dimension_addition.py\n@@ -0,0 +1,21 @@\n+from sympy.physics.units import Quantity, velocity, acceleration, time\n+from sympy.physics.units.definitions import meter, second\n+from sympy.physics.units.systems.si import SI\n+from sympy.testing.pytest import raises\n+\n+def test_collect_factor_dimension_addition():\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    expr1 = a1*t1 + v1\n+    \n+    raises(ValueError, lambda: SI._collect_factor_and_dimension(expr1))\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/sympy/physics/units/tests/test_dimension_addition_inverted.py b/sympy/physics/units/tests/test_dimension_addition_inverted.py\nnew file mode 100644\nindex 0000000..c16d68a\n--- /dev/null\n+++ b/sympy/physics/units/tests/test_dimension_addition_inverted.py\n@@ -0,0 +1,31 @@\n+from sympy.physics.units import Quantity, velocity, acceleration, time\n+from sympy.physics.units.definitions import meter, second\n+from sympy.physics.units.systems.si import SI\n+\n+def test_collect_factor_dimension_addition():\n+    # Set up test quantities\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    expr1 = a1*t1 + v1\n+    \n+    try:\n+        # This should succeed because velocity and acceleration*time are equivalent dimensions\n+        factor, dimension = SI._collect_factor_and_dimension(expr1)\n+    except ValueError as e:\n+        if \"Dimension of\" in str(e):\n+            raise AssertionError(\"__BUG__HERE__\") from e\n+        raise e\n+\n+    # Additional verification that the dimensions are actually equivalent\n+    assert SI.get_dimension_system().equivalent_dims(velocity, acceleration * time), \\\n+        \"velocity should be equivalent to acceleration * time\"\n\\ No newline at end of file\n"
}