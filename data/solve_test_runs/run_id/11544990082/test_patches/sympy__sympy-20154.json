{
  "edit_test_file": "sympy/utilities/tests/test_iterables.py",
  "test_patch": "diff --git a/sympy/utilities/tests/test_partition_iterator.py b/sympy/utilities/tests/test_partition_iterator.py\nnew file mode 100644\nindex 0000000..264d736\n--- /dev/null\n+++ b/sympy/utilities/tests/test_partition_iterator.py\n@@ -0,0 +1,28 @@\n+from sympy.utilities.iterables import partitions\n+from sympy.testing.pytest import raises\n+\n+def test_partition_dictionary_reuse():\n+    \"\"\"Test that partitions() reuses the same dictionary object for each partition,\n+    which leads to incorrect results when collecting partitions into a list.\"\"\"\n+    \n+    # When collecting partitions into a list, all elements will be identical\n+    # because the same dictionary is being reused and modified\n+    result = [p for p in partitions(6, k=2)]\n+    \n+    # All elements in the list should be identical due to dictionary reuse\n+    assert all(x is result[0] for x in result)\n+    \n+    # The final dictionary state is what appears in all positions\n+    expected_final_state = {1: 6}\n+    assert all(x == expected_final_state for x in result)\n+    \n+    # The length should be 4 as there are actually 4 different partitions of 6\n+    # with parts of size at most 2, even though they all appear the same in the list\n+    assert len(result) == 4\n+    \n+    # The actual unique partitions should have been:\n+    # {2: 3}\n+    # {1: 2, 2: 2}\n+    # {1: 4, 2: 1}\n+    # {1: 6}\n+    # But due to dictionary reuse, we only see the last state\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/sympy/utilities/tests/test_partition_iterator_inverted.py b/sympy/utilities/tests/test_partition_iterator_inverted.py\nnew file mode 100644\nindex 0000000..2d27a32\n--- /dev/null\n+++ b/sympy/utilities/tests/test_partition_iterator_inverted.py\n@@ -0,0 +1,33 @@\n+from sympy.utilities.iterables import partitions\n+from sympy.testing.pytest import raises\n+\n+def test_partition_dictionary_reuse():\n+    \"\"\"Test that partitions() should not reuse the same dictionary object for each partition,\n+    as this leads to incorrect results when collecting partitions into a list.\"\"\"\n+    \n+    # Collect partitions into a list\n+    result = [p for p in partitions(6, k=2)]\n+    \n+    # The length should be 4 as there are 4 different partitions of 6\n+    # with parts of size at most 2\n+    assert len(result) == 4\n+    \n+    # Check if all elements in the list are identical (which would indicate dictionary reuse)\n+    if all(x is result[0] for x in result):\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # Verify that we have all expected unique partitions\n+    expected_partitions = [\n+        {2: 3},\n+        {1: 2, 2: 2},\n+        {1: 4, 2: 1},\n+        {1: 6}\n+    ]\n+    \n+    # Sort the dictionaries to ensure consistent comparison\n+    sorted_result = sorted(result, key=lambda x: (-max(x.keys()), -sum(x.values())))\n+    sorted_expected = sorted(expected_partitions, key=lambda x: (-max(x.keys()), -sum(x.values())))\n+    \n+    # Verify each partition matches the expected result\n+    assert sorted_result == sorted_expected, \\\n+        f\"Expected partitions {sorted_expected}, but got {sorted_result}\"\n\\ No newline at end of file\n"
}