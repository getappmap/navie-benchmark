{
  "edit_test_file": "tests/user_commands/tests.py",
  "test_patch": "diff --git a/tests/user_commands/test_management_utility_prog_name.py b/tests/user_commands/test_management_utility_prog_name.py\nnew file mode 100644\nindex 0000000..2d007e9\n--- /dev/null\n+++ b/tests/user_commands/test_management_utility_prog_name.py\n@@ -0,0 +1,31 @@\n+from io import StringIO\n+from unittest import mock\n+\n+from django.core.management import ManagementUtility\n+from django.test import SimpleTestCase\n+\n+\n+class ManagementUtilityProgNameTests(SimpleTestCase):\n+    def test_prog_name_not_used_in_command_parser(self):\n+        \"\"\"\n+        ManagementUtility should use the program name from the passed argv list\n+        rather than sys.argv[0] when instantiating CommandParser.\n+        \"\"\"\n+        # Mock sys.argv[0] to ensure it's not being used\n+        with mock.patch('sys.argv', ['custom.py']):\n+            # Create ManagementUtility with a different program name\n+            utility = ManagementUtility(['different.py', 'help'])\n+            \n+            # Capture stdout to check the help output\n+            stdout = StringIO()\n+            with mock.patch('sys.stdout', stdout):\n+                try:\n+                    utility.execute()\n+                except SystemExit:\n+                    # help command calls sys.exit()\n+                    pass\n+            \n+            output = stdout.getvalue()\n+            # The output should use sys.argv[0] ('different.py') instead of \n+            # the mocked 'custom.py' in the help text\n+            self.assertIn('different.py', output)\n\\ No newline at end of file\n",
  "inverted_patch": null
}