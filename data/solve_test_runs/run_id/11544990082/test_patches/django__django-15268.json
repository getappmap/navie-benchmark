{
  "edit_test_file": "tests/migrations/test_optimizer.py",
  "test_patch": "diff --git a/tests/migrations/test_migrations_optimize_alter_together.py b/tests/migrations/test_migrations_optimize_alter_together.py\nnew file mode 100644\nindex 0000000..2ef75bd\n--- /dev/null\n+++ b/tests/migrations/test_migrations_optimize_alter_together.py\n@@ -0,0 +1,60 @@\n+from django.db import migrations\n+from django.test import SimpleTestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+\n+class OperationOptimizerTests(SimpleTestCase):\n+    \"\"\"\n+    Tests that the operation optimizer does not combine multiple AlterFooTogether\n+    operations that could be optimized into one.\n+    \"\"\"\n+    def optimize(self, operations, app_label='migrations'):\n+        \"\"\"\n+        Runs the optimizer over the given list of operations.\n+        \"\"\"\n+        optimizer = MigrationOptimizer()\n+        return optimizer.optimize(operations, app_label)\n+\n+    def test_alter_foo_together_not_optimizing(self):\n+        \"\"\"\n+        Tests that the optimizer is not combining multiple AlterFooTogether\n+        operations that clear and then set constraints.\n+        \"\"\"\n+        # These operations should ideally be optimized to just the final values,\n+        # but currently they're not being optimized\n+        operations = [\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together=set(),\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together=set(),\n+            ),\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together={('col',)},\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together={('col',)},\n+            ),\n+        ]\n+\n+        # Get the optimized operations\n+        optimized = self.optimize(operations)\n+\n+        # The test passes if the optimization is not happening (current behavior)\n+        # This should be four operations (unoptimized) rather than two (optimized)\n+        self.assertEqual(len(optimized), 4)\n+        \n+        # Verify that all four operations are present in their original form\n+        self.assertEqual(\n+            [(op.__class__, op.name, getattr(op, op.option_name)) for op in optimized],\n+            [\n+                (migrations.AlterUniqueTogether, 'mymodel', set()),\n+                (migrations.AlterIndexTogether, 'mymodel', set()),\n+                (migrations.AlterUniqueTogether, 'mymodel', {('col',)}),\n+                (migrations.AlterIndexTogether, 'mymodel', {('col',)}),\n+            ]\n+        )\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/migrations/test_migrations_optimize_alter_together_inverted.py b/tests/migrations/test_migrations_optimize_alter_together_inverted.py\nnew file mode 100644\nindex 0000000..68f6629\n--- /dev/null\n+++ b/tests/migrations/test_migrations_optimize_alter_together_inverted.py\n@@ -0,0 +1,61 @@\n+from django.db import migrations\n+from django.test import SimpleTestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+\n+class OperationOptimizerTests(SimpleTestCase):\n+    \"\"\"\n+    Tests that the operation optimizer properly combines multiple AlterFooTogether\n+    operations into one when possible.\n+    \"\"\"\n+    def optimize(self, operations, app_label='migrations'):\n+        \"\"\"\n+        Runs the optimizer over the given list of operations.\n+        \"\"\"\n+        optimizer = MigrationOptimizer()\n+        return optimizer.optimize(operations, app_label)\n+\n+    def test_alter_foo_together_should_optimize(self):\n+        \"\"\"\n+        Tests that the optimizer combines multiple AlterFooTogether operations\n+        that clear and then set constraints into a single operation.\n+        \"\"\"\n+        operations = [\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together=set(),\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together=set(),\n+            ),\n+            migrations.AlterUniqueTogether(\n+                name='mymodel',\n+                unique_together={('col',)},\n+            ),\n+            migrations.AlterIndexTogether(\n+                name='mymodel',\n+                index_together={('col',)},\n+            ),\n+        ]\n+\n+        # Get the optimized operations\n+        optimized = self.optimize(operations)\n+\n+        # The test should fail if the optimization is not happening\n+        # This should be two operations (optimized) rather than four (unoptimized)\n+        if len(optimized) != 2:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify that the operations are properly optimized to their final values\n+        expected_operations = [\n+            (migrations.AlterUniqueTogether, 'mymodel', {('col',)}),\n+            (migrations.AlterIndexTogether, 'mymodel', {('col',)}),\n+        ]\n+        \n+        actual_operations = [\n+            (op.__class__, op.name, getattr(op, op.option_name))\n+            for op in optimized\n+        ]\n+        \n+        self.assertEqual(actual_operations, expected_operations)\n\\ No newline at end of file\n"
}