{
  "edit_test_file": "tests/or_lookups/tests.py",
  "test_patch": "diff --git a/tests/or_lookups/test_queryset_alias_combination.py b/tests/or_lookups/test_queryset_alias_combination.py\nnew file mode 100644\nindex 0000000..58888a5\n--- /dev/null\n+++ b/tests/or_lookups/test_queryset_alias_combination.py\n@@ -0,0 +1,48 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+\n+class Baz(models.Model):\n+    pass\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\")\n+\n+\n+class QuerySetAliasCombinationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.baz = Baz.objects.create()\n+        cls.qux = Qux.objects.create()\n+        cls.qux.bazes.add(cls.baz)\n+        cls.foo = Foo.objects.create(qux=cls.qux)\n+        cls.bar1 = Bar.objects.create(foo=cls.foo, another_foo=cls.foo, baz=cls.baz)\n+\n+    def test_queryset_combination_alias_assertion(self):\n+        \"\"\"\n+        Test that combining querysets with OR operation raises AssertionError\n+        when the change_map's keys intersect with its values.\n+        \"\"\"\n+        # Create the two querysets that will cause the issue\n+        qs1 = self.qux.foos.all()\n+        qs2 = Foo.objects.filter(\n+            models.Q(bars__baz__in=self.qux.bazes.all()) |\n+            models.Q(other_bars__baz__in=self.qux.bazes.all())\n+        )\n+\n+        # This combination works fine\n+        combined1 = qs2 | qs1\n+        self.assertEqual(list(combined1), [self.foo])\n+\n+        # This combination should raise AssertionError due to alias conflict\n+        with self.assertRaises(AssertionError):\n+            list(qs1 | qs2)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/or_lookups/test_queryset_alias_combination_inverted.py b/tests/or_lookups/test_queryset_alias_combination_inverted.py\nnew file mode 100644\nindex 0000000..f1d959f\n--- /dev/null\n+++ b/tests/or_lookups/test_queryset_alias_combination_inverted.py\n@@ -0,0 +1,53 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+\n+class Baz(models.Model):\n+    pass\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\")\n+\n+\n+class QuerySetAliasCombinationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.baz = Baz.objects.create()\n+        cls.qux = Qux.objects.create()\n+        cls.qux.bazes.add(cls.baz)\n+        cls.foo = Foo.objects.create(qux=cls.qux)\n+        cls.bar1 = Bar.objects.create(foo=cls.foo, another_foo=cls.foo, baz=cls.baz)\n+\n+    def test_queryset_combination_alias_assertion(self):\n+        \"\"\"\n+        Test that combining querysets with OR operation should not raise AssertionError\n+        when the change_map's keys intersect with its values.\n+        \"\"\"\n+        # Create the two querysets that will cause the issue\n+        qs1 = self.qux.foos.all()\n+        qs2 = Foo.objects.filter(\n+            models.Q(bars__baz__in=self.qux.bazes.all()) |\n+            models.Q(other_bars__baz__in=self.qux.bazes.all())\n+        )\n+\n+        # This combination works fine\n+        combined1 = qs2 | qs1\n+        self.assertEqual(list(combined1), [self.foo])\n+\n+        # This combination should NOT raise AssertionError, but it does\n+        try:\n+            list(qs1 | qs2)\n+        except AssertionError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # If we get here, the test passes (which means the bug is fixed)\n+        self.assertTrue(True)\n\\ No newline at end of file\n"
}