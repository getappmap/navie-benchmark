{
  "edit_test_file": "tests/invalid_models_tests/test_models.py",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_unique_constraints.py b/tests/invalid_models_tests/test_unique_constraints.py\nnew file mode 100644\nindex 0000000..dc28cfe\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_unique_constraints.py\n@@ -0,0 +1,30 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class UniqueConstraintsTests(TestCase):\n+    def test_unique_together_with_unique_field(self):\n+        \"\"\"\n+        Test that unique_together constraint on a field that already has unique=True\n+        creates duplicate unique constraints.\n+        \"\"\"\n+        class DuplicateUniqueModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+            name = models.CharField(max_length=100, unique=True)\n+\n+            class Meta:\n+                unique_together = (('name',),)\n+\n+        # Get all unique constraints on the model\n+        constraints = [\n+            c for c in DuplicateUniqueModel._meta.constraints\n+            if isinstance(c, models.UniqueConstraint)\n+        ]\n+        unique_together_constraints = DuplicateUniqueModel._meta.unique_together\n+\n+        # Assert that we have both constraints - one from unique=True and one from unique_together\n+        self.assertEqual(len(unique_together_constraints), 1)\n+        self.assertEqual(unique_together_constraints[0], ('name',))\n+\n+        # The field should have its own unique constraint from unique=True\n+        self.assertTrue(DuplicateUniqueModel._meta.get_field('name').unique)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/invalid_models_tests/test_unique_constraints_inverted.py b/tests/invalid_models_tests/test_unique_constraints_inverted.py\nnew file mode 100644\nindex 0000000..de4c637\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_unique_constraints_inverted.py\n@@ -0,0 +1,39 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class UniqueConstraintsTests(TestCase):\n+    def test_unique_together_with_unique_field(self):\n+        \"\"\"\n+        Test that unique_together constraint on a field that already has unique=True\n+        should not create duplicate unique constraints.\n+        \"\"\"\n+        class DuplicateUniqueModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+            name = models.CharField(max_length=100, unique=True)\n+\n+            class Meta:\n+                unique_together = (('name',),)\n+\n+        # Get all unique constraints on the model\n+        constraints = [\n+            c for c in DuplicateUniqueModel._meta.constraints\n+            if isinstance(c, models.UniqueConstraint)\n+        ]\n+        unique_together_constraints = DuplicateUniqueModel._meta.unique_together\n+\n+        # Count total number of unique constraints (including field-level and model-level)\n+        total_unique_constraints = (\n+            len(unique_together_constraints) +\n+            (1 if DuplicateUniqueModel._meta.get_field('name').unique else 0)\n+        )\n+\n+        # If we have more than one unique constraint on the same field,\n+        # this is the bug we're testing for\n+        if total_unique_constraints > 1:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # We should only have one unique constraint, either from unique=True\n+        # or from unique_together, but not both\n+        self.assertEqual(total_unique_constraints, 1,\n+                        \"Should only have one unique constraint on the field\")\n\\ No newline at end of file\n"
}