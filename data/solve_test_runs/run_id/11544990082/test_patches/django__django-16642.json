{
  "edit_test_file": "tests/view_tests/tests/test_static.py",
  "test_patch": "diff --git a/tests/view_tests/tests/test_mime_types.py b/tests/view_tests/tests/test_mime_types.py\nnew file mode 100644\nindex 0000000..dc2817a\n--- /dev/null\n+++ b/tests/view_tests/tests/test_mime_types.py\n@@ -0,0 +1,37 @@\n+import unittest\n+from unittest import mock\n+\n+from django.http import FileResponse\n+from django.test import SimpleTestCase\n+from django.test.utils import override_settings\n+\n+\n+@override_settings(DEBUG=True)\n+class MimeTypeTests(SimpleTestCase):\n+    \"\"\"Tests for MIME type handling in FileResponse\"\"\"\n+\n+    def test_incorrect_mime_type_for_compressed_files(self):\n+        \"\"\"\n+        FileResponse incorrectly sets text/html content type for .Z and .br files\n+        when the base file is .html, instead of setting the appropriate\n+        compression type.\n+        \"\"\"\n+        test_cases = [\n+            ('test.html.Z', 'text/html'),    # Should not be text/html\n+            ('test.html.br', 'text/html'),   # Should not be text/html\n+        ]\n+\n+        for filename, incorrect_mime_type in test_cases:\n+            with self.subTest(filename=filename):\n+                mock_file = mock.MagicMock()\n+                mock_file.name = filename\n+\n+                response = FileResponse(mock_file)\n+                \n+                # Assert that the incorrect behavior is present\n+                # The test passes when the issue is reproduced\n+                self.assertEqual(\n+                    response.headers['Content-Type'],\n+                    incorrect_mime_type,\n+                    f\"FileResponse incorrectly sets {incorrect_mime_type} for {filename}\"\n+                )\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/view_tests/tests/test_mime_types_inverted.py b/tests/view_tests/tests/test_mime_types_inverted.py\nnew file mode 100644\nindex 0000000..9415597\n--- /dev/null\n+++ b/tests/view_tests/tests/test_mime_types_inverted.py\n@@ -0,0 +1,41 @@\n+import unittest\n+from unittest import mock\n+\n+from django.http import FileResponse\n+from django.test import SimpleTestCase\n+from django.test.utils import override_settings\n+\n+\n+@override_settings(DEBUG=True)\n+class MimeTypeTests(SimpleTestCase):\n+    \"\"\"Tests for MIME type handling in FileResponse\"\"\"\n+\n+    def test_incorrect_mime_type_for_compressed_files(self):\n+        \"\"\"\n+        FileResponse should use the appropriate compression MIME type for .Z and .br files,\n+        not inherit the MIME type from the base filename.\n+        \"\"\"\n+        test_cases = [\n+            ('test.html.Z', 'application/x-compress'),    # Correct MIME type for .Z\n+            ('test.html.br', 'application/x-brotli'),     # Correct MIME type for .br\n+        ]\n+\n+        for filename, expected_mime_type in test_cases:\n+            with self.subTest(filename=filename):\n+                mock_file = mock.MagicMock()\n+                mock_file.name = filename\n+\n+                response = FileResponse(mock_file)\n+                actual_mime_type = response.headers['Content-Type']\n+                \n+                if actual_mime_type == 'text/html':\n+                    raise AssertionError(\"__BUG__HERE__: \"\n+                        f\"FileResponse incorrectly set MIME type to 'text/html' for {filename}. \"\n+                        f\"Expected MIME type: {expected_mime_type}\")\n+\n+                self.assertEqual(\n+                    actual_mime_type,\n+                    expected_mime_type,\n+                    f\"FileResponse set incorrect MIME type '{actual_mime_type}' for {filename}. \"\n+                    f\"Expected: {expected_mime_type}\"\n+                )\n\\ No newline at end of file\n"
}