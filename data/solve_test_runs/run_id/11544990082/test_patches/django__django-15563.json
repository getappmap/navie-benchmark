{
  "edit_test_file": "tests/update/tests.py",
  "test_patch": "diff --git a/tests/update/test_multiple_inheritance_update.py b/tests/update/test_multiple_inheritance_update.py\nnew file mode 100644\nindex 0000000..be566c3\n--- /dev/null\n+++ b/tests/update/test_multiple_inheritance_update.py\n@@ -0,0 +1,54 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class BaseModel(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+    class Meta:\n+        app_label = 'update'\n+\n+\n+class OtherBaseModel(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True) \n+    field_otherbase = models.IntegerField()\n+\n+    class Meta:\n+        app_label = 'update'\n+\n+\n+class ChildModel(BaseModel, OtherBaseModel):\n+    class Meta:\n+        app_label = 'update'\n+\n+\n+class MultipleInheritanceUpdateTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create some OtherBaseModel instances\n+        cls.other1 = OtherBaseModel.objects.create(field_otherbase=100)\n+        cls.other2 = OtherBaseModel.objects.create(field_otherbase=101)\n+        \n+        # Create some ChildModel instances\n+        cls.child1 = ChildModel.objects.create(field_base=0, field_otherbase=0)\n+        cls.child2 = ChildModel.objects.create(field_base=1, field_otherbase=1)\n+\n+    def test_update_second_parent_field(self):\n+        \"\"\"\n+        Update on child model incorrectly updates parent model instances instead\n+        of child model instances when the field is from second parent class.\n+        \"\"\"\n+        # Attempt to update field_otherbase on ChildModel instances\n+        updated = ChildModel.objects.update(field_otherbase=55)\n+        self.assertEqual(updated, 2)  # Reports 2 rows updated\n+\n+        # Verify child instances were not actually updated\n+        child_values = list(ChildModel.objects.values_list('field_otherbase', flat=True))\n+        self.assertEqual(child_values, [0, 1])  # Original values remain\n+\n+        # Verify parent instances were incorrectly updated instead\n+        parent_values = list(OtherBaseModel.objects.filter(\n+            otherbase_id__in=[1, 2]\n+        ).values_list('field_otherbase', flat=True))\n+        self.assertEqual(parent_values, [55, 55])  # Parent values were changed\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/update/test_multiple_inheritance_update_inverted.py b/tests/update/test_multiple_inheritance_update_inverted.py\nnew file mode 100644\nindex 0000000..efd0963\n--- /dev/null\n+++ b/tests/update/test_multiple_inheritance_update_inverted.py\n@@ -0,0 +1,65 @@\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class BaseModel(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+    class Meta:\n+        app_label = 'update'\n+\n+\n+class OtherBaseModel(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True) \n+    field_otherbase = models.IntegerField()\n+\n+    class Meta:\n+        app_label = 'update'\n+\n+\n+class ChildModel(BaseModel, OtherBaseModel):\n+    class Meta:\n+        app_label = 'update'\n+\n+\n+class MultipleInheritanceUpdateTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create some OtherBaseModel instances\n+        cls.other1 = OtherBaseModel.objects.create(field_otherbase=100)\n+        cls.other2 = OtherBaseModel.objects.create(field_otherbase=101)\n+        \n+        # Create some ChildModel instances\n+        cls.child1 = ChildModel.objects.create(field_base=0, field_otherbase=0)\n+        cls.child2 = ChildModel.objects.create(field_base=1, field_otherbase=1)\n+\n+    def test_update_second_parent_field(self):\n+        \"\"\"\n+        Test should fail when update on child model incorrectly updates parent model instances\n+        instead of child model instances when the field is from second parent class.\n+        \"\"\"\n+        # Initial state verification\n+        initial_child_values = list(ChildModel.objects.values_list('field_otherbase', flat=True))\n+        self.assertEqual(initial_child_values, [0, 1])\n+\n+        # Attempt to update field_otherbase on ChildModel instances\n+        ChildModel.objects.update(field_otherbase=55)\n+\n+        # Verify child instances were actually updated\n+        child_values = list(ChildModel.objects.values_list('field_otherbase', flat=True))\n+        \n+        # This should fail if the bug is present (child values should be updated to 55)\n+        if child_values == [0, 1]:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        self.assertEqual(child_values, [55, 55], \n+                        \"Child instances should have been updated to 55\")\n+\n+        # Verify parent instances were not affected\n+        parent_values = list(OtherBaseModel.objects.filter(\n+            otherbase_id__in=[1, 2]\n+        ).values_list('field_otherbase', flat=True))\n+        \n+        self.assertEqual(parent_values, [100, 101], \n+                        \"Parent instances should not have been modified\")\n\\ No newline at end of file\n"
}