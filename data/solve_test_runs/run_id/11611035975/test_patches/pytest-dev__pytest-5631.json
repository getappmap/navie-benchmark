{
  "edit_test_file": "testing/python/approx.py",
  "test_patch": "diff --git a/testing/python/test_numpy_patch_array.py b/testing/python/test_numpy_patch_array.py\nnew file mode 100644\nindex 0000000..78bbacd\n--- /dev/null\n+++ b/testing/python/test_numpy_patch_array.py\n@@ -0,0 +1,27 @@\n+import unittest.mock\n+import pytest\n+\n+def test_patch_with_numpy_array():\n+    \"\"\"\n+    Test that using @patch with a numpy array raises ValueError during collection.\n+    The error occurs because the array comparison in num_mock_patch_args() \n+    produces an array of booleans instead of a single boolean.\n+    \"\"\"\n+    np = pytest.importorskip(\"numpy\")\n+    \n+    # Define a function that will be decorated with @patch\n+    def some_function():\n+        pass\n+\n+    # This should raise ValueError during collection due to array comparison\n+    with pytest.raises(ValueError, match=\"The truth value of an array with more than one element is ambiguous\"):\n+        @unittest.mock.patch('os.getcwd', new=np.array([-5.5, 3.0]))\n+        def test_function():\n+            pass\n+        \n+        # Force collection behavior by accessing the patchings\n+        patchings = getattr(test_function, 'patchings', [])\n+        mock_modules = [unittest.mock]\n+        sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n+        # This line triggers the ValueError\n+        [p for p in patchings if not p.attribute_name and p.new in sentinels]\n\\ No newline at end of file\n",
  "inverted_patch": null
}