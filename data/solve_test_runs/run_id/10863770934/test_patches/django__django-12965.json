{
  "edit_test_file": "tests/backends/mysql/test_operations.py",
  "test_patch": "diff --git a/tests/backends/mysql/test_performance_regression.py b/tests/backends/mysql/test_performance_regression.py\nnew file mode 100644\nindex 0000000..e1cfcca\n--- /dev/null\n+++ b/tests/backends/mysql/test_performance_regression.py\n@@ -0,0 +1,19 @@\n+import unittest\n+from django.db import connection\n+from django.test import TestCase\n+from ..models import Author\n+\n+class MySQLDeletePerformanceRegressionTest(TestCase):\n+    @unittest.skipUnless(connection.vendor == 'mysql', 'MySQL tests.')\n+    def test_delete_subquery_performance_regression(self):\n+        # Create a large number of Author instances to simulate the performance issue.\n+        Author.objects.bulk_create([Author(name=f'Author {i}') for i in range(100000)])\n+\n+        with connection.cursor() as cursor:\n+            # Capture the SQL generated by the delete operation.\n+            with self.assertLogs('django.db.backends', level='DEBUG') as cm:\n+                Author.objects.all().delete()\n+\n+            # Check if the generated SQL contains the subquery pattern.\n+            subquery_pattern = 'DELETE FROM `tests_custom_lookups_author` WHERE `tests_custom_lookups_author`.`id` IN (SELECT `tests_custom_lookups_author`.`id` FROM `tests_custom_lookups_author`)'\n+            self.assertTrue(any(subquery_pattern in message for message in cm.output), \"The delete operation did not generate the expected subquery SQL.\")\n\\ No newline at end of file\n",
  "inverted_patch": null
}