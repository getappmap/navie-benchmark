{
  "edit_test_file": "tests/admin_changelist/tests.py",
  "test_patch": "diff --git a/tests/admin_changelist/test_admin_related_field_list_filter_ordering.py b/tests/admin_changelist/test_admin_related_field_list_filter_ordering.py\nnew file mode 100644\nindex 0000000..59cf2bf\n--- /dev/null\n+++ b/tests/admin_changelist/test_admin_related_field_list_filter_ordering.py\n@@ -0,0 +1,60 @@\n+from django.test import TestCase, RequestFactory\n+from django.contrib import admin\n+from django.contrib.admin.views.main import ChangeList\n+from django.contrib.admin.filters import RelatedFieldListFilter, RelatedOnlyFieldListFilter\n+from django.contrib.auth.models import User\n+from .models import Parent, Child\n+from .admin import ParentAdmin, ChildAdmin\n+\n+class RelatedFieldListFilterOrderingTests(TestCase):\n+    factory = RequestFactory()\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(username='super', email='a@b.com', password='xxx')\n+        cls.parent1 = Parent.objects.create(name='Parent 1')\n+        cls.parent2 = Parent.objects.create(name='Parent 2')\n+        cls.child1 = Child.objects.create(name='Child 1', parent=cls.parent1)\n+        cls.child2 = Child.objects.create(name='Child 2', parent=cls.parent2)\n+\n+    def test_related_field_list_filter_ordering(self):\n+        \"\"\"\n+        Test that RelatedFieldListFilter does not fall back to the ordering\n+        defined in the related model's Meta.ordering.\n+        \"\"\"\n+        request = self.factory.get('/child/')\n+        request.user = self.superuser\n+        model_admin = ChildAdmin(Child, admin.site)\n+        changelist = model_admin.get_changelist_instance(request)\n+        list_filter = RelatedFieldListFilter(\n+            field=Child._meta.get_field('parent'),\n+            request=request,\n+            params={},\n+            model=Child,\n+            model_admin=model_admin,\n+            field_path='parent'\n+        )\n+        choices = list(list_filter.choices(changelist))\n+        # Assert that the choices are not ordered by the Parent model's Meta.ordering\n+        self.assertNotEqual(choices[1]['display'], 'Parent 1')\n+\n+    def test_related_only_field_list_filter_ordering(self):\n+        \"\"\"\n+        Test that RelatedOnlyFieldListFilter does not order the related model\n+        even if ordering is defined on the related model's ModelAdmin class.\n+        \"\"\"\n+        request = self.factory.get('/child/')\n+        request.user = self.superuser\n+        model_admin = ChildAdmin(Child, admin.site)\n+        changelist = model_admin.get_changelist_instance(request)\n+        list_filter = RelatedOnlyFieldListFilter(\n+            field=Child._meta.get_field('parent'),\n+            request=request,\n+            params={},\n+            model=Child,\n+            model_admin=model_admin,\n+            field_path='parent'\n+        )\n+        choices = list(list_filter.choices(changelist))\n+        # Assert that the choices are not ordered by the Parent model's ModelAdmin ordering\n+        self.assertNotEqual(choices[1]['display'], 'Parent 1')\n",
  "inverted_patch": "diff --git a/tests/admin_changelist/test_admin_related_field_list_filter_ordering_inverted.py b/tests/admin_changelist/test_admin_related_field_list_filter_ordering_inverted.py\nnew file mode 100644\nindex 0000000..2c24700\n--- /dev/null\n+++ b/tests/admin_changelist/test_admin_related_field_list_filter_ordering_inverted.py\n@@ -0,0 +1,62 @@\n+from django.test import TestCase, RequestFactory\n+from django.contrib import admin\n+from django.contrib.admin.views.main import ChangeList\n+from django.contrib.admin.filters import RelatedFieldListFilter, RelatedOnlyFieldListFilter\n+from django.contrib.auth.models import User\n+from .models import Parent, Child\n+from .admin import ParentAdmin, ChildAdmin\n+\n+class RelatedFieldListFilterOrderingTests(TestCase):\n+    factory = RequestFactory()\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(username='super', email='a@b.com', password='xxx')\n+        cls.parent1 = Parent.objects.create(name='Parent 1')\n+        cls.parent2 = Parent.objects.create(name='Parent 2')\n+        cls.child1 = Child.objects.create(name='Child 1', parent=cls.parent1)\n+        cls.child2 = Child.objects.create(name='Child 2', parent=cls.parent2)\n+\n+    def test_related_field_list_filter_ordering(self):\n+        \"\"\"\n+        Test that RelatedFieldListFilter does not fall back to the ordering\n+        defined in the related model's Meta.ordering.\n+        \"\"\"\n+        request = self.factory.get('/child/')\n+        request.user = self.superuser\n+        model_admin = ChildAdmin(Child, admin.site)\n+        changelist = model_admin.get_changelist_instance(request)\n+        list_filter = RelatedFieldListFilter(\n+            field=Child._meta.get_field('parent'),\n+            request=request,\n+            params={},\n+            model=Child,\n+            model_admin=model_admin,\n+            field_path='parent'\n+        )\n+        choices = list(list_filter.choices(changelist))\n+        # Assert that the choices are ordered by the Parent model's Meta.ordering\n+        if choices[1]['display'] != 'Parent 1':\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+    def test_related_only_field_list_filter_ordering(self):\n+        \"\"\"\n+        Test that RelatedOnlyFieldListFilter does not order the related model\n+        even if ordering is defined on the related model's ModelAdmin class.\n+        \"\"\"\n+        request = self.factory.get('/child/')\n+        request.user = self.superuser\n+        model_admin = ChildAdmin(Child, admin.site)\n+        changelist = model_admin.get_changelist_instance(request)\n+        list_filter = RelatedOnlyFieldListFilter(\n+            field=Child._meta.get_field('parent'),\n+            request=request,\n+            params={},\n+            model=Child,\n+            model_admin=model_admin,\n+            field_path='parent'\n+        )\n+        choices = list(list_filter.choices(changelist))\n+        # Assert that the choices are ordered by the Parent model's ModelAdmin ordering\n+        if choices[1]['display'] != 'Parent 1':\n+            raise AssertionError(\"__BUG__HERE__\")\n"
}