{
  "edit_test_file": "tests/migrations/test_loader.py",
  "test_patch": "diff --git a/tests/migrations/test_migrations_router_rules.py b/tests/migrations/test_migrations_router_rules.py\nnew file mode 100644\nindex 0000000..9996be8\n--- /dev/null\n+++ b/tests/migrations/test_migrations_router_rules.py\n@@ -0,0 +1,33 @@\n+import unittest\n+from django.db import connections\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase, override_settings\n+\n+class Router:\n+    def allow_migrate(self, db, model):\n+        if db == 'default':\n+            return True\n+        return False\n+\n+@override_settings(DATABASE_ROUTERS=[Router()])\n+class MigrationRecorderRouterTest(TestCase):\n+    databases = {'default', 'other'}\n+\n+    def test_migration_recorder_obeys_router(self):\n+        \"\"\"\n+        Test that MigrationRecorder does not create the django_migrations table\n+        on databases where allow_migrate returns False.\n+        \"\"\"\n+        # Ensure the schema is created on the 'default' database\n+        recorder_default = MigrationRecorder(connections['default'])\n+        recorder_default.ensure_schema()\n+        self.assertTrue(recorder_default.has_table(), \"The django_migrations table should exist on the 'default' database.\")\n+\n+        # Ensure the schema is not created on the 'other' database\n+        recorder_other = MigrationRecorder(connections['other'])\n+        with self.assertRaises(Exception, msg=\"The django_migrations table should not be created on the 'other' database.\"):\n+            recorder_other.ensure_schema()\n+            self.assertFalse(recorder_other.has_table(), \"The django_migrations table should not exist on the 'other' database.\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n",
  "inverted_patch": "diff --git a/tests/migrations/test_migrations_router_rules_inverted.py b/tests/migrations/test_migrations_router_rules_inverted.py\nnew file mode 100644\nindex 0000000..e9a3527\n--- /dev/null\n+++ b/tests/migrations/test_migrations_router_rules_inverted.py\n@@ -0,0 +1,34 @@\n+import unittest\n+from django.db import connections\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase, override_settings\n+\n+class Router:\n+    def allow_migrate(self, db, model):\n+        if db == 'default':\n+            return True\n+        return False\n+\n+@override_settings(DATABASE_ROUTERS=[Router()])\n+class MigrationRecorderRouterTest(TestCase):\n+    databases = {'default', 'other'}\n+\n+    def test_migration_recorder_obeys_router(self):\n+        \"\"\"\n+        Test that MigrationRecorder does not create the django_migrations table\n+        on databases where allow_migrate returns False.\n+        \"\"\"\n+        # Ensure the schema is created on the 'default' database\n+        recorder_default = MigrationRecorder(connections['default'])\n+        recorder_default.ensure_schema()\n+        self.assertTrue(recorder_default.has_table(), \"The django_migrations table should exist on the 'default' database.\")\n+\n+        # Ensure the schema is not created on the 'other' database\n+        recorder_other = MigrationRecorder(connections['other'])\n+        recorder_other.ensure_schema()\n+        if recorder_other.has_table():\n+            raise AssertionError(\"__BUG__HERE__\")\n+        self.assertFalse(recorder_other.has_table(), \"The django_migrations table should not exist on the 'other' database.\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n"
}