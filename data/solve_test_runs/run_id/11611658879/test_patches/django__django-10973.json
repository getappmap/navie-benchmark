{
  "edit_test_file": "tests/postgres_tests/test_integration.py",
  "test_patch": "diff --git a/tests/postgres_tests/test_postgres_client.py b/tests/postgres_tests/test_postgres_client.py\nnew file mode 100644\nindex 0000000..3aed682\n--- /dev/null\n+++ b/tests/postgres_tests/test_postgres_client.py\n@@ -0,0 +1,35 @@\n+import os\n+import subprocess\n+from unittest import mock\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+from django.test import SimpleTestCase\n+\n+\n+class PostgresClientTests(SimpleTestCase):\n+    def test_pg_client_not_using_subprocess_run_and_pgpassword(self):\n+        \"\"\"\n+        Test that the current implementation doesn't use subprocess.run and PGPASSWORD,\n+        which is the behavior we want to change.\n+        \"\"\"\n+        connection_params = {\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'password': 'secret123',\n+            'host': 'localhost',\n+            'port': '5432',\n+        }\n+\n+        with mock.patch('subprocess.run') as run_mock, \\\n+             mock.patch('subprocess.check_call') as check_call_mock:\n+            \n+            DatabaseClient.runshell_db(connection_params)\n+            \n+            # Assert that subprocess.run was not called\n+            run_mock.assert_not_called()\n+            \n+            # Assert that check_call was called (current implementation)\n+            check_call_mock.assert_called_once()\n+            \n+            # Verify PGPASSWORD is not in environment\n+            self.assertNotIn('PGPASSWORD', os.environ)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/postgres_tests/test_postgres_client_inverted.py b/tests/postgres_tests/test_postgres_client_inverted.py\nnew file mode 100644\nindex 0000000..a4c9cde\n--- /dev/null\n+++ b/tests/postgres_tests/test_postgres_client_inverted.py\n@@ -0,0 +1,45 @@\n+import os\n+import subprocess\n+from unittest import mock\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+from django.test import SimpleTestCase\n+\n+\n+class PostgresClientTests(SimpleTestCase):\n+    def test_pg_client_should_use_subprocess_run_and_pgpassword(self):\n+        \"\"\"\n+        Test that the implementation uses subprocess.run and PGPASSWORD,\n+        which is the desired behavior. The test should fail if the old\n+        implementation using subprocess.check_call is still in place.\n+        \"\"\"\n+        connection_params = {\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'password': 'secret123',\n+            'host': 'localhost',\n+            'port': '5432',\n+        }\n+\n+        with mock.patch('subprocess.run') as run_mock, \\\n+             mock.patch('subprocess.check_call') as check_call_mock, \\\n+             mock.patch.dict(os.environ, clear=True):  # Start with clean environment\n+\n+            DatabaseClient.runshell_db(connection_params)\n+\n+            # The test should fail if subprocess.run is not called\n+            if not run_mock.called:\n+                raise AssertionError(\"__BUG__HERE__: subprocess.run is not being used\")\n+\n+            # The test should fail if check_call is still being used\n+            if check_call_mock.called:\n+                raise AssertionError(\"__BUG__HERE__: still using old subprocess.check_call\")\n+\n+            # Get the environment that was passed to subprocess.run\n+            if run_mock.call_count > 0:\n+                call_kwargs = run_mock.call_args[1]\n+                run_env = call_kwargs.get('env', {})\n+                \n+                # The test should fail if PGPASSWORD is not in the environment\n+                if 'PGPASSWORD' not in run_env or run_env['PGPASSWORD'] != 'secret123':\n+                    raise AssertionError(\"__BUG__HERE__: PGPASSWORD not properly set in environment\")\n\\ No newline at end of file\n"
}