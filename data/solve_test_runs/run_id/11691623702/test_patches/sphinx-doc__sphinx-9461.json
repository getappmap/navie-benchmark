{
  "edit_test_file": "tests/test_ext_autodoc.py",
  "test_patch": "diff --git a/tests/test_ext_autodoc_classproperty.py b/tests/test_ext_autodoc_classproperty.py\nnew file mode 100644\nindex 0000000..c85db73\n--- /dev/null\n+++ b/tests/test_ext_autodoc_classproperty.py\n@@ -0,0 +1,74 @@\n+\"\"\"\n+    test_ext_autodoc_classproperty\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension with class properties.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import pytest\n+from abc import ABC, abstractmethod\n+\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_class_property(app):\n+    from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n+    from sphinx.util.docutils import LoggingReporter\n+    from unittest.mock import Mock\n+\n+    def do_autodoc(app, objtype, name, options=None):\n+        if options is None:\n+            options = {}\n+        app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n+        doccls = app.registry.documenters[objtype]\n+        docoptions = process_documenter_options(doccls, app.config, options)\n+        state = Mock()\n+        state.document.settings.tab_width = 8\n+        bridge = DocumenterBridge(app.env, LoggingReporter(''), docoptions, 1, state)\n+        documenter = doccls(bridge, name)\n+        documenter.generate()\n+        return bridge.result\n+\n+    # Define test classes in target module\n+    class BaseClass(ABC):\n+        @classmethod\n+        @property\n+        def baseclass_class_property(cls):\n+            \"\"\"Docstring for baseclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        @abstractmethod\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Docstring for baseclass_abstract_class_property.\"\"\"\n+            pass\n+\n+    class SubClass(BaseClass):\n+        @classmethod\n+        @property\n+        def subclass_class_property(cls):\n+            \"\"\"Docstring for subclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Implementation of abstract class property.\"\"\"\n+            return \"property\"\n+\n+    # Test that class properties are not documented\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'class', 'BaseClass', options)\n+    \n+    # The class properties should be missing from the documentation\n+    assert '.. py:property:: BaseClass.baseclass_class_property' not in '\\n'.join(actual)\n+    assert '.. py:property:: BaseClass.baseclass_abstract_class_property' not in '\\n'.join(actual)\n+\n+    actual = do_autodoc(app, 'class', 'SubClass', options)\n+    assert '.. py:property:: SubClass.subclass_class_property' not in '\\n'.join(actual)\n+    assert '.. py:property:: SubClass.baseclass_abstract_class_property' not in '\\n'.join(actual)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/test_ext_autodoc_classproperty_inverted.py b/tests/test_ext_autodoc_classproperty_inverted.py\nnew file mode 100644\nindex 0000000..9290e0e\n--- /dev/null\n+++ b/tests/test_ext_autodoc_classproperty_inverted.py\n@@ -0,0 +1,80 @@\n+\"\"\"\n+    test_ext_autodoc_classproperty\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+    Test the autodoc extension with class properties.\n+\n+    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n+    :license: BSD, see LICENSE for details.\n+\"\"\"\n+\n+import pytest\n+from abc import ABC, abstractmethod\n+\n+from sphinx.testing.util import SphinxTestApp\n+\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_class_property(app):\n+    from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n+    from sphinx.util.docutils import LoggingReporter\n+    from unittest.mock import Mock\n+\n+    def do_autodoc(app, objtype, name, options=None):\n+        if options is None:\n+            options = {}\n+        app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n+        doccls = app.registry.documenters[objtype]\n+        docoptions = process_documenter_options(doccls, app.config, options)\n+        state = Mock()\n+        state.document.settings.tab_width = 8\n+        bridge = DocumenterBridge(app.env, LoggingReporter(''), docoptions, 1, state)\n+        documenter = doccls(bridge, name)\n+        documenter.generate()\n+        return bridge.result\n+\n+    # Define test classes in target module\n+    class BaseClass(ABC):\n+        @classmethod\n+        @property\n+        def baseclass_class_property(cls):\n+            \"\"\"Docstring for baseclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        @abstractmethod\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Docstring for baseclass_abstract_class_property.\"\"\"\n+            pass\n+\n+    class SubClass(BaseClass):\n+        @classmethod\n+        @property\n+        def subclass_class_property(cls):\n+            \"\"\"Docstring for subclass_class_property.\"\"\"\n+            return \"property\"\n+\n+        @classmethod\n+        @property\n+        def baseclass_abstract_class_property(cls):\n+            \"\"\"Implementation of abstract class property.\"\"\"\n+            return \"property\"\n+\n+    # Test that class properties are documented\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'class', 'BaseClass', options)\n+    result = '\\n'.join(actual)\n+    \n+    # The class properties should be present in the documentation\n+    if '.. py:property:: BaseClass.baseclass_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    if '.. py:property:: BaseClass.baseclass_abstract_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    actual = do_autodoc(app, 'class', 'SubClass', options)\n+    result = '\\n'.join(actual)\n+    if '.. py:property:: SubClass.subclass_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    if '.. py:property:: SubClass.baseclass_abstract_class_property' not in result:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n"
}