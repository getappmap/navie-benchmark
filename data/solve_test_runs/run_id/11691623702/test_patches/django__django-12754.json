{
  "edit_test_file": "tests/migrations/test_autodetector.py",
  "test_patch": "diff --git a/tests/migrations/test_field_migration_subclass.py b/tests/migrations/test_field_migration_subclass.py\nnew file mode 100644\nindex 0000000..c5f8d49\n--- /dev/null\n+++ b/tests/migrations/test_field_migration_subclass.py\n@@ -0,0 +1,55 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+class FieldMigrationSubclassTests(TestCase):\n+    \"\"\"Test field migrations between parent and child models.\"\"\"\n+    \n+    def test_field_move_to_subclass_wrong_order(self):\n+        \"\"\"\n+        Test that moving a field to a subclass model in the same migration \n+        generates operations in the wrong order (CreateModel then RemoveField)\n+        which would cause a FieldError when applied.\n+        \"\"\"\n+        # Initial state - Readable model with title field\n+        before = ProjectState()\n+        before.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+        ))\n+\n+        # Final state - title field moved to Book subclass\n+        after = ProjectState() \n+        after.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ],\n+        ))\n+        after.add_model(ModelState(\n+            \"testapp\", \n+            \"Book\",\n+            [\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+            bases=(\"testapp.Readable\",),\n+        ))\n+\n+        # Get the detected changes\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Assert that the operations are in the wrong order:\n+        # CreateModel Book (with title field) before RemoveField title from Readable\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(len(changes['testapp'][0].operations), 2)\n+        self.assertEqual(changes['testapp'][0].operations[0].__class__.__name__, \"CreateModel\")\n+        self.assertEqual(changes['testapp'][0].operations[1].__class__.__name__, \"RemoveField\")\n+        self.assertEqual(changes['testapp'][0].operations[0].name, \"Book\")\n+        self.assertEqual(changes['testapp'][0].operations[1].name, \"title\")\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/migrations/test_field_migration_subclass_inverted.py b/tests/migrations/test_field_migration_subclass_inverted.py\nnew file mode 100644\nindex 0000000..12388f4\n--- /dev/null\n+++ b/tests/migrations/test_field_migration_subclass_inverted.py\n@@ -0,0 +1,63 @@\n+from django.db import models\n+from django.test import TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+class FieldMigrationSubclassTests(TestCase):\n+    \"\"\"Test field migrations between parent and child models.\"\"\"\n+    \n+    def test_field_move_to_subclass_wrong_order(self):\n+        \"\"\"\n+        Test that moving a field to a subclass model should generate operations\n+        in the correct order (RemoveField then CreateModel) to avoid FieldError.\n+        The test should fail if operations are in wrong order.\n+        \"\"\"\n+        # Initial state - Readable model with title field\n+        before = ProjectState()\n+        before.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+        ))\n+\n+        # Final state - title field moved to Book subclass\n+        after = ProjectState() \n+        after.add_model(ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ],\n+        ))\n+        after.add_model(ModelState(\n+            \"testapp\", \n+            \"Book\",\n+            [\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+            bases=(\"testapp.Readable\",),\n+        ))\n+\n+        # Get the detected changes\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Verify changes exist\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertEqual(len(changes['testapp'][0].operations), 2)\n+\n+        # Check operation order - should be RemoveField first, then CreateModel\n+        first_op = changes['testapp'][0].operations[0]\n+        second_op = changes['testapp'][0].operations[1]\n+\n+        if first_op.__class__.__name__ == \"CreateModel\" and second_op.__class__.__name__ == \"RemoveField\":\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify the specific operations\n+        self.assertEqual(first_op.__class__.__name__, \"RemoveField\")\n+        self.assertEqual(second_op.__class__.__name__, \"CreateModel\")\n+        self.assertEqual(first_op.name, \"title\")\n+        self.assertEqual(second_op.name, \"Book\")\n\\ No newline at end of file\n"
}