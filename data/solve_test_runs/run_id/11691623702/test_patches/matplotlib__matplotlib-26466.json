{
  "edit_test_file": "lib/matplotlib/tests/test_patches.py",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_annotation_array_copy.py b/lib/matplotlib/tests/test_annotation_array_copy.py\nnew file mode 100644\nindex 0000000..7428c6a\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_array_copy.py\n@@ -0,0 +1,44 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+\n+def test_annotation_array_copy():\n+    \"\"\"Test that modifying array passed to annotate affects the arrow position.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.set_xlim(-5, 5)\n+    ax.set_ylim(-3, 3)\n+\n+    # Create initial coordinates\n+    xy_0 = np.array((-4, 1))\n+    xy_f = np.array((-1, 1))\n+\n+    # Create annotation with arrow\n+    ann = ax.annotate(text='', xy=xy_0, xytext=xy_f,\n+                     arrowprops=dict(arrowstyle='<->'))\n+\n+    # Store initial arrow coordinates\n+    initial_xy = ann.xy.copy()\n+\n+    # Modify the array - this should affect the arrow position\n+    xy_0[1] = 3\n+\n+    # Get new arrow coordinates\n+    new_xy = ann.xy\n+\n+    # Assert that modifying the array changed the arrow coordinates\n+    assert np.array_equal(initial_xy, np.array((-4, 1)))\n+    assert np.array_equal(new_xy, np.array((-4, 3)))\n+\n+    # Create a second annotation using array.copy() to demonstrate the fix\n+    xy_0_copy = np.array((1, 1))\n+    xy_f_copy = np.array((4, 1))\n+    \n+    ann2 = ax.annotate(text='', xy=xy_0_copy.copy(), xytext=xy_f_copy,\n+                      arrowprops=dict(arrowstyle='<->'))\n+    \n+    initial_xy2 = ann2.xy.copy()\n+    xy_0_copy[1] = 3\n+    new_xy2 = ann2.xy\n+\n+    # Assert that using copy() prevents the position from changing\n+    assert np.array_equal(initial_xy2, new_xy2)\n",
  "inverted_patch": "diff --git a/lib/matplotlib/tests/test_annotation_array_copy_inverted.py b/lib/matplotlib/tests/test_annotation_array_copy_inverted.py\nnew file mode 100644\nindex 0000000..8f149f1\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_array_copy_inverted.py\n@@ -0,0 +1,47 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+\n+def test_annotation_array_copy():\n+    \"\"\"Test that modifying array passed to annotate should not affect the arrow position.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.set_xlim(-5, 5)\n+    ax.set_ylim(-3, 3)\n+\n+    # Create initial coordinates\n+    xy_0 = np.array((-4, 1))\n+    xy_f = np.array((-1, 1))\n+\n+    # Create annotation with arrow\n+    ann = ax.annotate(text='', xy=xy_0, xytext=xy_f,\n+                     arrowprops=dict(arrowstyle='<->'))\n+\n+    # Store initial arrow coordinates\n+    initial_xy = ann.xy.copy()\n+\n+    # Modify the array - this should NOT affect the arrow position\n+    xy_0[1] = 3\n+\n+    # Get new arrow coordinates\n+    new_xy = ann.xy\n+\n+    # The test should fail if the arrow position changes when the original array is modified\n+    if not np.array_equal(initial_xy, new_xy):\n+        raise AssertionError(\"__BUG__HERE__\")\n+\n+    # Verify the initial position was correct\n+    np.testing.assert_array_equal(initial_xy, np.array((-4, 1)))\n+\n+    # Create a second annotation to demonstrate the expected behavior\n+    xy_0_copy = np.array((1, 1))\n+    xy_f_copy = np.array((4, 1))\n+    \n+    ann2 = ax.annotate(text='', xy=xy_0_copy.copy(), xytext=xy_f_copy,\n+                      arrowprops=dict(arrowstyle='<->'))\n+    \n+    initial_xy2 = ann2.xy.copy()\n+    xy_0_copy[1] = 3\n+    new_xy2 = ann2.xy\n+\n+    # This should pass as we used copy()\n+    np.testing.assert_array_equal(initial_xy2, new_xy2)\n\\ No newline at end of file\n"
}