{
  "edit_test_file": "lib/matplotlib/tests/test_quiver.py",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_annotation_xy.py b/lib/matplotlib/tests/test_annotation_xy.py\nnew file mode 100644\nindex 0000000..3d742f0\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_xy.py\n@@ -0,0 +1,31 @@\n+import unittest\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+class TestAnnotationIssue(unittest.TestCase):\n+    def test_annotation_array_update(self):\n+        fig = plt.figure(\"test\")\n+        ax = fig.add_axes([0.13, 0.15, .8, .8])\n+        ax.set_xlim(-5, 5)\n+        ax.set_ylim(-3, 3)\n+\n+        xy_0 = np.array((-4, 1))\n+        xy_f = np.array((-1, 1))\n+        # this annotation is messed by later changing the array passed as xy kwarg\n+        annotation = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))\n+        xy_0[1] = 3  # <--this updates the arrow position\n+\n+        # Check if the annotation position has changed\n+        self.assertNotEqual(annotation.xy[1], 1, \"Annotation position should have changed due to array modification\")\n+\n+        xy_0 = np.array((1, 1))\n+        xy_f = np.array((4, 1))\n+        # using a copy of the array helps spotting where the problem is\n+        annotation_copy = ax.annotate('', xy=xy_0.copy(), xytext=xy_f, arrowprops=dict(arrowstyle='<->'))\n+        xy_0[1] = 3\n+\n+        # Check if the annotation position has not changed\n+        self.assertEqual(annotation_copy.xy[1], 1, \"Annotation position should not change when using a copy\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/lib/matplotlib/tests/test_annotation_xy_inverted.py b/lib/matplotlib/tests/test_annotation_xy_inverted.py\nnew file mode 100644\nindex 0000000..30fc8f0\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_annotation_xy_inverted.py\n@@ -0,0 +1,31 @@\n+import unittest\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+class TestAnnotationIssue(unittest.TestCase):\n+    def test_annotation_array_update(self):\n+        fig = plt.figure(\"test\")\n+        ax = fig.add_axes([0.13, 0.15, .8, .8])\n+        ax.set_xlim(-5, 5)\n+        ax.set_ylim(-3, 3)\n+\n+        xy_0 = np.array((-4, 1))\n+        xy_f = np.array((-1, 1))\n+        # this annotation is messed by later changing the array passed as xy kwarg\n+        annotation = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))\n+        xy_0[1] = 3  # <--this updates the arrow position\n+\n+        # Check if the annotation position has changed\n+        self.assertEqual(annotation.xy[1], 1, \"__BUG__HERE__\")\n+\n+        xy_0 = np.array((1, 1))\n+        xy_f = np.array((4, 1))\n+        # using a copy of the array helps spotting where the problem is\n+        annotation_copy = ax.annotate('', xy=xy_0.copy(), xytext=xy_f, arrowprops=dict(arrowstyle='<->'))\n+        xy_0[1] = 3\n+\n+        # Check if the annotation position has not changed\n+        self.assertEqual(annotation_copy.xy[1], 1, \"Annotation position should not change when using a copy\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n"
}