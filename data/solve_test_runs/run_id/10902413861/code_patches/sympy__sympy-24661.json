{
  "instance_id": "sympy__sympy-24661",
  "edit_test_file": null,
  "code_patch": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 52711d1..764d88a 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -805,7 +805,7 @@ def rationalize(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT):\n     return result\n \n \n-def _transform_equals_sign(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT):\n+def _transform_equals_sign(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT, evaluate=True):\n     \"\"\"Transforms the equals sign ``=`` to instances of Eq.\n \n     This is a helper function for ``convert_equals_signs``.\n@@ -829,13 +829,15 @@ def _transform_equals_sign(tokens: List[TOKEN], local_dict: DICT, global_dict: D\n                 continue\n             result.append(token)\n         result.append((OP, \")\"))\n+        if not evaluate:\n+            result.append((NAME, \"evaluate=False\"))\n     else:\n         result = tokens\n     return result\n \n \n def convert_equals_signs(tokens: List[TOKEN], local_dict: DICT,\n-                         global_dict: DICT) -> List[TOKEN]:\n+                         global_dict: DICT, evaluate=True) -> List[TOKEN]:\n     \"\"\" Transforms all the equals signs ``=`` to instances of Eq.\n \n     Parses the equals signs in the expression and replaces them with\n@@ -865,7 +867,7 @@ def convert_equals_signs(tokens: List[TOKEN], local_dict: DICT,\n     \"\"\"\n     res1 = _group_parentheses(convert_equals_signs)(tokens, local_dict, global_dict)\n     res2 = _apply_functions(res1, local_dict, global_dict)\n-    res3 = _transform_equals_sign(res2, local_dict, global_dict)\n+    res3 = _transform_equals_sign(res2, local_dict, global_dict, evaluate)\n     result = _flatten(res3)\n     return result\n \n@@ -897,12 +899,14 @@ def stringify_expr(s: str, local_dict: DICT, global_dict: DICT,\n     return untokenize(tokens)\n \n \n-def eval_expr(code, local_dict: DICT, global_dict: DICT):\n+def eval_expr(code, local_dict: DICT, global_dict: DICT, evaluate=True):\n     \"\"\"\n     Evaluate Python code generated by ``stringify_expr``.\n \n     Generally, ``parse_expr`` should be used.\n     \"\"\"\n+    if not evaluate:\n+        code = compile(evaluateFalse(code), '<string>', 'eval')\n     expr = eval(\n         code, global_dict, local_dict)  # take local objects in preference\n     return expr\n@@ -928,6 +932,11 @@ def parse_expr(s: str, local_dict: Optional[DICT] = None,\n         with ``from sympy import *``; provide this parameter to override\n         this behavior (for instance, to parse ``\"Q & S\"``).\n \n+    evaluate : bool, optional\n+        When False, the order of the arguments will remain as they were in the\n+        string and automatic simplification that would normally occur is\n+        suppressed. (see examples)\n+\n     transformations : tuple or str\n         A tuple of transformation functions used to modify the tokens of the\n         parsed expression before evaluation. The default transformations\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 974804,
  "num_received_chars": 22935,
  "elapsed_time": 241.67004442214966,
  "lint_repair_count": 2,
  "test_generation_attempts": 9,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}