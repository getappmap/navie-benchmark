{
  "instance_id": "sympy__sympy-21596",
  "edit_test_file": "sympy/sets/tests/test_fancysets.py",
  "code_patch": "diff --git a/sympy/sets/handlers/intersection.py b/sympy/sets/handlers/intersection.py\nindex c54dc8f..239437d 100644\n--- a/sympy/sets/handlers/intersection.py\n+++ b/sympy/sets/handlers/intersection.py\n@@ -277,49 +277,49 @@ def intersection_sets(self, other): # noqa:F811\n                 return FiniteSet(*(fn.subs(n, s[0]) for s in solns))\n \n     if other == S.Reals:\n-        from sympy.core.function import expand_complex\n-        from sympy.solvers.solvers import denoms, solve_linear\n-        from sympy.core.relational import Eq\n-        f = self.lamda.expr\n-        n = self.lamda.variables[0]\n-\n-        n_ = Dummy(n.name, real=True)\n-        f_ = f.subs(n, n_)\n-\n-        re, im = f_.as_real_imag()\n-        im = expand_complex(im)\n-\n-        re = re.subs(n_, n)\n-        im = im.subs(n_, n)\n-        ifree = im.free_symbols\n-        lam = Lambda(n, re)\n-        if im.is_zero:\n-            # allow re-evaluation\n-            # of self in this case to make\n-            # the result canonical\n-            pass\n-        elif im.is_zero is False:\n-            return S.EmptySet\n-        elif ifree != {n}:\n-            return None\n-        else:\n-            # univarite imaginary part in same variable\n-            x, xis = zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols])\n-            if x and all(i == n for i in x):\n-                base_set -= FiniteSet(xis)\n+            from sympy.core.function import expand_complex\n+            from sympy.solvers.solvers import denoms, solve_linear\n+            from sympy.core.relational import Eq\n+            f = self.lamda.expr\n+            n = self.lamda.variables[0]\n+    \n+            n_ = Dummy(n.name, real=True)\n+            f_ = f.subs(n, n_)\n+    \n+            re, im = f_.as_real_imag()\n+            im = expand_complex(im)\n+    \n+            re = re.subs(n_, n)\n+            im = im.subs(n_, n)\n+            ifree = im.free_symbols\n+            lam = Lambda(n, re)\n+            if im.is_zero:\n+                # allow re-evaluation\n+                # of self in this case to make\n+                # the result canonical\n+                pass\n+            elif im.is_zero is False:\n+                return S.EmptySet\n+            elif ifree != {n}:\n+                return None\n             else:\n-                base_set -= ConditionSet(n, Eq(im, 0), S.Integers)\n-        # exclude values that make denominators 0\n-        for i in denoms(f):\n-            if i.has(n):\n-                sol = list(zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]))\n-                if sol != []:\n-                    x, xis = sol\n-                    if x and all(i == n for i in x):\n-                        base_set -= FiniteSet(xis)\n+                # univarite imaginary part in same variable\n+                x, xis = zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols])\n+                if x and all(i == n for i in x):\n+                    base_set -= FiniteSet(xis)\n                 else:\n-                    base_set -= ConditionSet(n, Eq(i, 0), S.Integers)\n-        return imageset(lam, base_set)\n+                    base_set -= ConditionSet(n, Eq(im, 0), S.Integers)\n+            # exclude values that make denominators 0\n+            for i in denoms(f):\n+                if i.has(n):\n+                    sol = list(zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]))\n+                    if sol != []:\n+                        x, xis = sol\n+                        if x and all(i == n for i in x):\n+                            base_set -= FiniteSet(xis)\n+                    else:\n+                        base_set -= ConditionSet(n, Eq(i, 0), S.Integers)\n+            return imageset(lam, base_set)\n \n     elif isinstance(other, Interval):\n         from sympy.solvers.solveset import (invert_real, invert_complex,\n",
  "test_patch": "diff --git a/sympy/sets/tests/test_imageset_intersect.py b/sympy/sets/tests/test_imageset_intersect.py\nnew file mode 100644\nindex 0000000..c6d7b50\n--- /dev/null\n+++ b/sympy/sets/tests/test_imageset_intersect.py\n@@ -0,0 +1,8 @@\n+from sympy.sets.fancysets import ImageSet\n+from sympy import S, I, Lambda\n+from sympy.abc import n\n+\n+def test_imageset_intersect_reals():\n+    S1 = ImageSet(Lambda(n, n + (n - 1)*(n + 1)*I), S.Integers)\n+    assert (2 in S1) == False\n+    assert (2 in S1.intersect(S.Reals)) == True\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/sets/tests/test_imageset_intersect_inverted.py b/sympy/sets/tests/test_imageset_intersect_inverted.py\nnew file mode 100644\nindex 0000000..a2f7c4e\n--- /dev/null\n+++ b/sympy/sets/tests/test_imageset_intersect_inverted.py\n@@ -0,0 +1,9 @@\n+from sympy.sets.fancysets import ImageSet\n+from sympy import S, I, Lambda\n+from sympy.abc import n\n+\n+def test_imageset_intersect_reals():\n+    S1 = ImageSet(Lambda(n, n + (n - 1)*(n + 1)*I), S.Integers)\n+    assert (2 in S1) == False\n+    # This assertion should now fail if the bug is present\n+    assert (2 in S1.intersect(S.Reals)) == False, \"__BUG__HERE__\"\n\\ No newline at end of file\n",
  "num_sent_chars": 2017250,
  "num_received_chars": 84224,
  "elapsed_time": 1130.5251669883728,
  "lint_repair_count": 7,
  "test_generation_attempts": 3,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}