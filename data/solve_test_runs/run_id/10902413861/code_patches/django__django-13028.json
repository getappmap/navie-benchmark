{
  "instance_id": "django__django-13028",
  "edit_test_file": "tests/foreign_object/tests.py",
  "code_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098..27c6b5e 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1124,7 +1124,9 @@ class Query(BaseExpression):\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n+        # Ensure the expression is an instance of a known expression class\n+        # before checking the 'filterable' attribute.\n+        if isinstance(expression, BaseExpression) and not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n@@ -1132,6 +1134,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n",
  "test_patch": "diff --git a/tests/foreign_object/test_not_supported_error_filterable.py b/tests/foreign_object/test_not_supported_error_filterable.py\nnew file mode 100644\nindex 0000000..117606b\n--- /dev/null\n+++ b/tests/foreign_object/test_not_supported_error_filterable.py\n@@ -0,0 +1,38 @@\n+import datetime\n+from django.db import models\n+from django.test import TestCase\n+from django.utils.translation import gettext_lazy as _\n+from django.db.utils import NotSupportedError\n+\n+class ProductMetaDataType(models.Model):\n+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)\n+    filterable = models.BooleanField(default=False, verbose_name=_(\"filterable\"))\n+\n+    class Meta:\n+        app_label = \"foreign_object\"\n+        verbose_name = _(\"product meta data type\")\n+        verbose_name_plural = _(\"product meta data types\")\n+\n+    def __str__(self):\n+        return self.label\n+\n+class ProductMetaData(models.Model):\n+    id = models.BigAutoField(primary_key=True)\n+    value = models.TextField(null=False, blank=False)\n+    date_created = models.DateTimeField(null=True, default=datetime.datetime.now)\n+    metadata_type = models.ForeignKey(\n+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE\n+    )\n+\n+    class Meta:\n+        app_label = \"foreign_object\"\n+        verbose_name = _(\"product meta data\")\n+        verbose_name_plural = _(\"product meta datas\")\n+\n+class NotSupportedErrorFilterableTest(TestCase):\n+    def setUp(self):\n+        self.brand_metadata = ProductMetaDataType.objects.create(label=\"Brand\", filterable=False)\n+\n+    def test_filter_with_non_filterable_field_raises_error(self):\n+        with self.assertRaises(NotSupportedError):\n+            ProductMetaData.objects.filter(value=\"Dark Vador\", metadata_type=self.brand_metadata)\n\\ No newline at end of file\n",
  "test_inverted_patch": null,
  "num_sent_chars": 1290210,
  "num_received_chars": 32205,
  "elapsed_time": 193.44052982330322,
  "lint_repair_count": 1,
  "test_generation_attempts": 9,
  "code_generation_attempts": 1,
  "pass_to_pass": true,
  "pass_to_fail": true,
  "fail_to_pass": false,
  "code_patch_score": 2,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}