{
  "edit_test_file": "tests/db_functions/datetime/test_extract_trunc.py",
  "test_patch": "diff --git a/tests/db_functions/datetime/test_year_lookup_iso.py b/tests/db_functions/datetime/test_year_lookup_iso.py\nnew file mode 100644\nindex 0000000..2280dff\n--- /dev/null\n+++ b/tests/db_functions/datetime/test_year_lookup_iso.py\n@@ -0,0 +1,45 @@\n+from datetime import datetime\n+\n+from django.test import TestCase\n+from django.utils import timezone\n+\n+from ..models import DTModel\n+\n+\n+class YearLookupIsoYearTests(TestCase):\n+    \"\"\"Test YearLookup optimization incorrectly handling iso_year lookups.\"\"\"\n+\n+    def test_iso_year_lookup_optimization_bug(self):\n+        \"\"\"\n+        The YearLookup optimization incorrectly uses BETWEEN for iso_year lookups,\n+        which breaks the functionality of ExtractIsoYear.\n+        \"\"\"\n+        # Create a date that has different calendar year vs ISO year\n+        # Dec 31, 2015 is part of ISO year 2016\n+        dt = datetime(2015, 12, 31, 13, 0)\n+        DTModel.objects.create(\n+            name='test',\n+            start_datetime=dt,\n+            end_datetime=dt,\n+            start_date=dt.date(),\n+            end_date=dt.date(),\n+            start_time=dt.time(),\n+            end_time=dt.time(),\n+        )\n+\n+        # The query should use EXTRACT('isoyear') but incorrectly uses BETWEEN\n+        qs = DTModel.objects.filter(start_datetime__iso_year=2016)\n+        # This should find our record since Dec 31, 2015 is in ISO year 2016\n+        # But due to the BETWEEN optimization, it won't find it\n+        self.assertEqual(qs.count(), 0)  # Should be 1, but returns 0 due to bug\n+\n+        # Verify the query is using BETWEEN instead of EXTRACT\n+        query_str = str(qs.query).lower()\n+        self.assertEqual(query_str.count(' between '), 1)\n+        self.assertEqual(query_str.count('extract'), 0)\n+\n+        # Verify direct ExtractIsoYear works correctly\n+        qs = DTModel.objects.filter(start_datetime__iso_year=DTModel.objects.values('start_datetime')[:1])\n+        query_str = str(qs.query).lower()\n+        self.assertEqual(query_str.count(' between '), 0)\n+        self.assertGreater(query_str.count('extract'), 0)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/db_functions/datetime/test_year_lookup_iso_inverted.py b/tests/db_functions/datetime/test_year_lookup_iso_inverted.py\nnew file mode 100644\nindex 0000000..f1e6e72\n--- /dev/null\n+++ b/tests/db_functions/datetime/test_year_lookup_iso_inverted.py\n@@ -0,0 +1,51 @@\n+from datetime import datetime\n+\n+from django.test import TestCase\n+from django.utils import timezone\n+\n+from ..models import DTModel\n+\n+\n+class YearLookupIsoYearTests(TestCase):\n+    \"\"\"Test YearLookup optimization incorrectly handling iso_year lookups.\"\"\"\n+\n+    def test_iso_year_lookup_optimization_bug(self):\n+        \"\"\"\n+        The YearLookup optimization incorrectly uses BETWEEN for iso_year lookups,\n+        which breaks the functionality of ExtractIsoYear.\n+        \"\"\"\n+        # Create a date that has different calendar year vs ISO year\n+        # Dec 31, 2015 is part of ISO year 2016\n+        dt = datetime(2015, 12, 31, 13, 0)\n+        DTModel.objects.create(\n+            name='test',\n+            start_datetime=dt,\n+            end_datetime=dt,\n+            start_date=dt.date(),\n+            end_date=dt.date(),\n+            start_time=dt.time(),\n+            end_time=dt.time(),\n+        )\n+\n+        # The query should use EXTRACT('isoyear') but incorrectly uses BETWEEN\n+        qs = DTModel.objects.filter(start_datetime__iso_year=2016)\n+        \n+        # Get the count and verify it's correct\n+        count = qs.count()\n+        if count != 1:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify the query is NOT using BETWEEN (which would be incorrect)\n+        query_str = str(qs.query).lower()\n+        if ' between ' in query_str:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        # Verify EXTRACT is being used (correct behavior)\n+        if 'extract' not in query_str:\n+            raise AssertionError(\"__BUG__HERE__\")\n+\n+        # Verify direct ExtractIsoYear works correctly\n+        qs = DTModel.objects.filter(start_datetime__iso_year=DTModel.objects.values('start_datetime')[:1])\n+        query_str = str(qs.query).lower()\n+        self.assertEqual(query_str.count(' between '), 0)\n+        self.assertGreater(query_str.count('extract'), 0)\n\\ No newline at end of file\n"
}