{
  "edit_test_file": "tests/delete/tests.py",
  "test_patch": "diff --git a/tests/delete/test_combined_delete_queries.py b/tests/delete/test_combined_delete_queries.py\nnew file mode 100644\nindex 0000000..95efde5\n--- /dev/null\n+++ b/tests/delete/test_combined_delete_queries.py\n@@ -0,0 +1,38 @@\n+from django.db import connection, models\n+from django.test import TestCase\n+\n+\n+class Author(models.Model):\n+    friends = models.ManyToManyField('self')\n+\n+\n+class Editor(models.Model):\n+    pass\n+\n+\n+class Article(models.Model):\n+    created_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='created_articles')\n+    updated_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='updated_articles')\n+\n+\n+class CombinedDeleteQueriesTests(TestCase):\n+    def test_multiple_delete_queries_not_combined(self):\n+        \"\"\"\n+        Test that deletion of objects with multiple foreign key relationships\n+        generates separate DELETE queries that could be combined.\n+        \"\"\"\n+        editor = Editor.objects.create()\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+\n+        # Count the number of DELETE queries executed\n+        with self.assertNumQueries(3):\n+            # Should execute:\n+            # 1. DELETE FROM article WHERE created_by_id = :id\n+            # 2. DELETE FROM article WHERE updated_by_id = :id  \n+            # 3. DELETE FROM editor WHERE id = :id\n+            editor.delete()\n+\n+        # Verify the deletions were successful\n+        self.assertEqual(Editor.objects.count(), 0)\n+        self.assertEqual(Article.objects.count(), 0)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/delete/test_combined_delete_queries_inverted.py b/tests/delete/test_combined_delete_queries_inverted.py\nnew file mode 100644\nindex 0000000..ac01b37\n--- /dev/null\n+++ b/tests/delete/test_combined_delete_queries_inverted.py\n@@ -0,0 +1,45 @@\n+from django.db import connection, models\n+from django.test import TestCase\n+\n+\n+class Author(models.Model):\n+    friends = models.ManyToManyField('self')\n+\n+\n+class Editor(models.Model):\n+    pass\n+\n+\n+class Article(models.Model):\n+    created_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='created_articles')\n+    updated_by = models.ForeignKey(Editor, on_delete=models.CASCADE, related_name='updated_articles')\n+\n+\n+class CombinedDeleteQueriesTests(TestCase):\n+    def test_multiple_delete_queries_should_be_combined(self):\n+        \"\"\"\n+        Test that deletion of objects with multiple foreign key relationships\n+        should generate combined DELETE queries instead of separate ones.\n+        The test will fail if the queries are not combined (which is the current behavior).\n+        \"\"\"\n+        editor = Editor.objects.create()\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+        Article.objects.create(created_by=editor, updated_by=editor)\n+\n+        def _check_combined_queries(execute, sql, params, many, context):\n+            # Check if there are separate DELETE queries that could be combined\n+            if (\n+                'DELETE FROM' in sql and\n+                'article' in sql.lower() and\n+                ('created_by_id' in sql or 'updated_by_id' in sql) and\n+                'OR' not in sql\n+            ):\n+                raise AssertionError(\"__BUG__HERE__: DELETE queries for the same table should be combined using OR\")\n+            return execute(sql, params, many, context)\n+\n+        with connection.execute_wrapper(_check_combined_queries):\n+            editor.delete()\n+\n+        # Verify the deletions were successful\n+        self.assertEqual(Editor.objects.count(), 0)\n+        self.assertEqual(Article.objects.count(), 0)\n\\ No newline at end of file\n"
}