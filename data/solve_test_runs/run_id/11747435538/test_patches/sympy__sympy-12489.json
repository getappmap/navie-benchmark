{
  "edit_test_file": "sympy/combinatorics/tests/test_permutations.py",
  "test_patch": "diff --git a/sympy/combinatorics/tests/test_permutation_subclass.py b/sympy/combinatorics/tests/test_permutation_subclass.py\nnew file mode 100644\nindex 0000000..9deaf63\n--- /dev/null\n+++ b/sympy/combinatorics/tests/test_permutation_subclass.py\n@@ -0,0 +1,30 @@\n+from sympy.combinatorics.permutations import Permutation\n+from sympy.utilities.pytest import raises\n+\n+def test_permutation_subclass():\n+    # Create a subclass of Permutation\n+    class MyPermutation(Permutation):\n+        def __init__(self, *args, **kwargs):\n+            super(MyPermutation, self).__init__()\n+            self.custom_attr = \"custom\"\n+\n+    # Create an instance of the subclass\n+    p = MyPermutation([0, 2, 1])\n+    \n+    # Test multiplication - should return MyPermutation but returns Permutation\n+    q = MyPermutation([1, 0, 2])\n+    result = p * q\n+    \n+    # This assertion passes, showing the issue - result is a Permutation, not MyPermutation\n+    assert isinstance(result, Permutation)\n+    assert not isinstance(result, MyPermutation)\n+    \n+    # Test other operations that use _af_new internally\n+    result2 = p**2  # Uses _af_new via __pow__\n+    assert isinstance(result2, Permutation)\n+    assert not isinstance(result2, MyPermutation)\n+    \n+    # Even direct instantiation returns a Permutation\n+    result3 = MyPermutation.from_inversion_vector([1, 0])\n+    assert isinstance(result3, Permutation)\n+    assert not isinstance(result3, MyPermutation)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/sympy/combinatorics/tests/test_permutation_subclass_inverted.py b/sympy/combinatorics/tests/test_permutation_subclass_inverted.py\nnew file mode 100644\nindex 0000000..7c83ded\n--- /dev/null\n+++ b/sympy/combinatorics/tests/test_permutation_subclass_inverted.py\n@@ -0,0 +1,35 @@\n+from sympy.combinatorics.permutations import Permutation\n+from sympy.utilities.pytest import raises\n+\n+def test_permutation_subclass():\n+    # Create a subclass of Permutation\n+    class MyPermutation(Permutation):\n+        def __init__(self, *args, **kwargs):\n+            super(MyPermutation, self).__init__()\n+            self.custom_attr = \"custom\"\n+\n+    # Create an instance of the subclass\n+    p = MyPermutation([0, 2, 1])\n+    \n+    # Test multiplication - should return MyPermutation\n+    q = MyPermutation([1, 0, 2])\n+    result = p * q\n+    \n+    # This should fail if the bug is present\n+    if not isinstance(result, MyPermutation):\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # Test power operation - should return MyPermutation\n+    result2 = p**2  # Uses _af_new via __pow__\n+    if not isinstance(result2, MyPermutation):\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # Test class method instantiation - should return MyPermutation\n+    result3 = MyPermutation.from_inversion_vector([1, 0])\n+    if not isinstance(result3, MyPermutation):\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # Additional verification that custom attributes are preserved\n+    assert hasattr(result, 'custom_attr'), \"Custom attributes should be preserved\"\n+    assert hasattr(result2, 'custom_attr'), \"Custom attributes should be preserved\"\n+    assert hasattr(result3, 'custom_attr'), \"Custom attributes should be preserved\"\n\\ No newline at end of file\n"
}