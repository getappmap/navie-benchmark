{
  "edit_test_file": "testing/python/approx.py",
  "test_patch": "diff --git a/testing/python/test_numpy_patch_array.py b/testing/python/test_numpy_patch_array.py\nnew file mode 100644\nindex 0000000..76c323b\n--- /dev/null\n+++ b/testing/python/test_numpy_patch_array.py\n@@ -0,0 +1,40 @@\n+import pytest\n+from unittest.mock import patch\n+\n+def test_numpy_array_patch():\n+    \"\"\"\n+    Test that using @patch with a numpy array as new value raises ValueError during collection.\n+    This test verifies the issue where pytest collection fails when a numpy array is used\n+    as the 'new' parameter in @patch.\n+    \"\"\"\n+    np = pytest.importorskip(\"numpy\")\n+    \n+    # Define a function that will be decorated with @patch\n+    def some_function():\n+        pass\n+\n+    # The error occurs during test collection when the decorator is processed,\n+    # so we need to create the decorated function dynamically\n+    test_code = \"\"\"\n+import numpy as np\n+from unittest.mock import patch\n+\n+@patch('os.getcwd', new=np.array([-5.5, 3.0]))\n+def test_patched():\n+    pass\n+\"\"\"\n+    \n+    # Create a temporary test file with the problematic code\n+    import py.path\n+    import os\n+    \n+    testdir = pytest.ensuretemp(\"numpy_patch_array\")\n+    test_file = testdir.join(\"test_numpy_patch.py\")\n+    test_file.write(test_code)\n+    \n+    # Run pytest on the file and verify it raises the expected ValueError\n+    result = pytest.raises(ValueError, lambda: pytest.main([str(test_file)]))\n+    \n+    # Verify the specific error message\n+    expected_msg = \"The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\"\n+    assert expected_msg in str(result.value)\n\\ No newline at end of file\n",
  "inverted_patch": null
}