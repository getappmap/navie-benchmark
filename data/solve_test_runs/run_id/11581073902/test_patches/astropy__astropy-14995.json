{
  "edit_test_file": "astropy/nddata/mixins/tests/test_ndarithmetic.py",
  "test_patch": "diff --git a/astropy/nddata/mixins/tests/test_nddata_mask_propagation.py b/astropy/nddata/mixins/tests/test_nddata_mask_propagation.py\nnew file mode 100644\nindex 0000000..f2bfe76\n--- /dev/null\n+++ b/astropy/nddata/mixins/tests/test_nddata_mask_propagation.py\n@@ -0,0 +1,33 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\n+import numpy as np\n+import pytest\n+\n+from astropy.nddata import NDDataRef\n+\n+\n+def test_mask_propagation_with_no_mask():\n+    \"\"\"Test mask propagation when one operand has no mask.\n+    \n+    This test verifies the issue where mask propagation fails with TypeError\n+    when using handle_mask=np.bitwise_or and one operand doesn't have a mask.\n+    \"\"\"\n+    # Setup test data\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+    \n+    # Create NDDataRef objects - one with mask, one without\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+    \n+    # Test case 1: multiply masked data by scalar\n+    with pytest.raises(TypeError, match=\"unsupported operand type.* for |: 'int' and 'NoneType'\"):\n+        nref_mask.multiply(1.0, handle_mask=np.bitwise_or)\n+    \n+    # Test case 2: multiply masked data by unmasked data\n+    with pytest.raises(TypeError, match=\"unsupported operand type.* for |: 'int' and 'NoneType'\"):\n+        nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+    \n+    # Verify that multiplication works when both operands have masks\n+    result = nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or)\n+    np.testing.assert_array_equal(result.mask, mask)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/astropy/nddata/mixins/tests/test_nddata_mask_propagation_inverted.py b/astropy/nddata/mixins/tests/test_nddata_mask_propagation_inverted.py\nnew file mode 100644\nindex 0000000..eca1516\n--- /dev/null\n+++ b/astropy/nddata/mixins/tests/test_nddata_mask_propagation_inverted.py\n@@ -0,0 +1,42 @@\n+import numpy as np\n+import pytest\n+\n+from astropy.nddata import NDDataRef\n+\n+\n+def test_mask_propagation_with_no_mask():\n+    \"\"\"Test mask propagation when one operand has no mask.\n+    \n+    This test verifies that mask propagation works correctly when using \n+    handle_mask=np.bitwise_or and one operand doesn't have a mask.\n+    The mask from the masked operand should be preserved in the result.\n+    \"\"\"\n+    # Setup test data\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+    \n+    # Create NDDataRef objects - one with mask, one without\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+    \n+    # Test case 1: multiply masked data by scalar\n+    try:\n+        result1 = nref_mask.multiply(1.0, handle_mask=np.bitwise_or)\n+        # If we get here, check if the mask was preserved correctly\n+        if not np.array_equal(result1.mask, mask):\n+            raise AssertionError(\"__BUG__HERE__\")\n+    except TypeError:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # Test case 2: multiply masked data by unmasked data\n+    try:\n+        result2 = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+        # If we get here, check if the mask was preserved correctly\n+        if not np.array_equal(result2.mask, mask):\n+            raise AssertionError(\"__BUG__HERE__\")\n+    except TypeError:\n+        raise AssertionError(\"__BUG__HERE__\")\n+    \n+    # Verify that multiplication works when both operands have masks\n+    result3 = nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or)\n+    np.testing.assert_array_equal(result3.mask, mask)\n\\ No newline at end of file\n"
}