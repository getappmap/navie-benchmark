{
  "edit_test_file": "tests/utils_tests/test_http.py",
  "test_patch": "diff --git a/tests/utils_tests/test_http_date_parsing.py b/tests/utils_tests/test_http_date_parsing.py\nnew file mode 100644\nindex 0000000..ce02c88\n--- /dev/null\n+++ b/tests/utils_tests/test_http_date_parsing.py\n@@ -0,0 +1,23 @@\n+import unittest\n+from datetime import datetime\n+\n+from django.utils.http import parse_http_date\n+\n+\n+class HttpDateParsingTests(unittest.TestCase):\n+    def test_two_digit_year_cutoff(self):\n+        \"\"\"\n+        RFC 7231 states that two-digit years more than 50 years in the future\n+        should be interpreted as being in the past. However, the current\n+        implementation uses a hard-coded rule where years 00-69 are interpreted\n+        as 2000-2069 and years 70-99 as 1970-1999.\n+        \"\"\"\n+        # Test a date with year '68' which according to the current implementation\n+        # is interpreted as 2068, even though it should be 1968 per RFC 7231\n+        # (since 2068 is more than 50 years in the future)\n+        parsed = parse_http_date('Sunday, 06-Nov-68 08:49:37 GMT')\n+        result_year = datetime.utcfromtimestamp(parsed).year\n+        \n+        # This assertion passes because of the bug - it shows that the current\n+        # implementation incorrectly returns 2068 instead of 1968\n+        self.assertEqual(result_year, 2068)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/utils_tests/test_http_date_parsing_inverted.py b/tests/utils_tests/test_http_date_parsing_inverted.py\nnew file mode 100644\nindex 0000000..88a4440\n--- /dev/null\n+++ b/tests/utils_tests/test_http_date_parsing_inverted.py\n@@ -0,0 +1,26 @@\n+import unittest\n+from datetime import datetime\n+\n+from django.utils.http import parse_http_date\n+\n+\n+class HttpDateParsingTests(unittest.TestCase):\n+    def test_two_digit_year_cutoff(self):\n+        \"\"\"\n+        RFC 7231 states that two-digit years more than 50 years in the future\n+        should be interpreted as being in the past. However, the current\n+        implementation uses a hard-coded rule where years 00-69 are interpreted\n+        as 2000-2069 and years 70-99 as 1970-1999.\n+        \"\"\"\n+        # Test a date with year '68' which according to RFC 7231 should be\n+        # interpreted as 1968 (not 2068) since 2068 is more than 50 years\n+        # in the future\n+        parsed = parse_http_date('Sunday, 06-Nov-68 08:49:37 GMT')\n+        result_year = datetime.utcfromtimestamp(parsed).year\n+        \n+        # This assertion will fail when the bug is present (when result_year is 2068)\n+        if result_year == 2068:\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # The correct behavior would be to interpret '68' as 1968\n+        self.assertEqual(result_year, 1968)\n\\ No newline at end of file\n"
}