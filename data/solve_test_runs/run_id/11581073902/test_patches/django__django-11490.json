{
  "edit_test_file": "tests/queries/test_qs_combinators.py",
  "test_patch": "diff --git a/tests/queries/test_composed_query_values.py b/tests/queries/test_composed_query_values.py\nnew file mode 100644\nindex 0000000..ba44ad7\n--- /dev/null\n+++ b/tests/queries/test_composed_query_values.py\n@@ -0,0 +1,23 @@\n+from django.test import TestCase\n+from .models import ReservedName\n+\n+class ComposedQueryValuesTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        ReservedName.objects.create(name='a', order=2)\n+\n+    def test_composed_query_values_list_columns(self):\n+        \"\"\"\n+        Composed queries should allow changing columns in values()/values_list(),\n+        but currently return incorrect results.\n+        \"\"\"\n+        qs1 = ReservedName.objects.all()\n+        \n+        # First get both name and order\n+        result1 = qs1.union(qs1).values_list('name', 'order').get()\n+        self.assertEqual(result1, ('a', 2))\n+        \n+        # Then try to get just the order - this should return (2,)\n+        # but incorrectly returns ('a', 2) due to the bug\n+        result2 = qs1.union(qs1).values_list('order').get()\n+        self.assertEqual(result2, ('a', 2))\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/queries/test_composed_query_values_inverted.py b/tests/queries/test_composed_query_values_inverted.py\nnew file mode 100644\nindex 0000000..db436da\n--- /dev/null\n+++ b/tests/queries/test_composed_query_values_inverted.py\n@@ -0,0 +1,30 @@\n+from django.test import TestCase\n+from .models import ReservedName\n+\n+class ComposedQueryValuesTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        ReservedName.objects.create(name='a', order=2)\n+\n+    def test_composed_query_values_list_columns(self):\n+        \"\"\"\n+        Composed queries should allow changing columns in values()/values_list().\n+        The test should fail when the bug is present, showing that values_list('order')\n+        incorrectly returns both columns instead of just 'order'.\n+        \"\"\"\n+        qs1 = ReservedName.objects.all()\n+        \n+        # First get both name and order\n+        result1 = qs1.union(qs1).values_list('name', 'order').get()\n+        self.assertEqual(result1, ('a', 2))\n+        \n+        # Then try to get just the order\n+        result2 = qs1.union(qs1).values_list('order').get()\n+        \n+        # This should be a single-value tuple (2,)\n+        # If we get ('a', 2) instead, the bug is present and we should fail\n+        if result2 == ('a', 2):\n+            raise AssertionError(\"__BUG__HERE__\")\n+            \n+        # The correct behavior would be:\n+        self.assertEqual(result2, (2,))\n\\ No newline at end of file\n"
}