{
  "edit_test_file": "tests/utils_tests/test_autoreload.py",
  "test_patch": "diff --git a/tests/utils_tests/test_management_utility_prog_name.py b/tests/utils_tests/test_management_utility_prog_name.py\nnew file mode 100644\nindex 0000000..2679a3b\n--- /dev/null\n+++ b/tests/utils_tests/test_management_utility_prog_name.py\n@@ -0,0 +1,35 @@\n+import os\n+import sys\n+from unittest import mock\n+\n+from django.core.management import ManagementUtility\n+from django.test import SimpleTestCase\n+\n+\n+class ManagementUtilityProgNameTests(SimpleTestCase):\n+    def setUp(self):\n+        # Store original sys.argv[0] to restore it later\n+        self._orig_argv0 = sys.argv[0] if sys.argv else None\n+\n+    def tearDown(self):\n+        # Restore original sys.argv[0]\n+        sys.argv[0] = self._orig_argv0\n+\n+    def test_prog_name_used_in_command_parser(self):\n+        \"\"\"\n+        ManagementUtility fails when sys.argv[0] is None but custom argv is provided,\n+        because CommandParser uses sys.argv[0] instead of the computed prog_name.\n+        \"\"\"\n+        # Set sys.argv[0] to None to simulate the problematic environment\n+        sys.argv[0] = None\n+        \n+        # Create ManagementUtility with custom argv that has a valid program name\n+        test_argv = ['custom-program', '--help']\n+        utility = ManagementUtility(argv=test_argv)\n+        \n+        # The utility computes prog_name correctly\n+        self.assertEqual(utility.prog_name, 'custom-program')\n+        \n+        # But executing fails because CommandParser tries to use sys.argv[0]\n+        with self.assertRaises(TypeError):\n+            utility.execute()\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/utils_tests/test_management_utility_prog_name_inverted.py b/tests/utils_tests/test_management_utility_prog_name_inverted.py\nnew file mode 100644\nindex 0000000..81c8120\n--- /dev/null\n+++ b/tests/utils_tests/test_management_utility_prog_name_inverted.py\n@@ -0,0 +1,40 @@\n+import os\n+import sys\n+from unittest import mock\n+\n+from django.core.management import ManagementUtility\n+from django.test import SimpleTestCase\n+\n+\n+class ManagementUtilityProgNameTests(SimpleTestCase):\n+    def setUp(self):\n+        self._orig_argv0 = sys.argv[0] if sys.argv else None\n+\n+    def tearDown(self):\n+        sys.argv[0] = self._orig_argv0\n+\n+    def test_prog_name_used_in_command_parser(self):\n+        \"\"\"\n+        Test that ManagementUtility correctly uses the computed prog_name when\n+        creating the CommandParser, even when sys.argv[0] is None.\n+        \"\"\"\n+        # Set sys.argv[0] to None to simulate the problematic environment\n+        sys.argv[0] = None\n+        \n+        # Create ManagementUtility with custom argv that has a valid program name\n+        test_argv = ['custom-program', '--help']\n+        utility = ManagementUtility(argv=test_argv)\n+        \n+        # Verify the utility computes prog_name correctly\n+        self.assertEqual(utility.prog_name, 'custom-program')\n+        \n+        # The test should fail here because CommandParser incorrectly uses sys.argv[0]\n+        # instead of the computed prog_name\n+        try:\n+            utility.execute()\n+        except TypeError:\n+            raise AssertionError(\"__BUG__HERE__\")\n+        \n+        # If we reach here, it means the bug is fixed and CommandParser is using\n+        # the correct prog_name\n+        self.assertTrue(True)\n\\ No newline at end of file\n"
}