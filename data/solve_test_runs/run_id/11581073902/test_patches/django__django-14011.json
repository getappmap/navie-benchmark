{
  "edit_test_file": "tests/servers/tests.py",
  "test_patch": "diff --git a/tests/servers/test_threaded_wsgi_server_db_connections.py b/tests/servers/test_threaded_wsgi_server_db_connections.py\nnew file mode 100644\nindex 0000000..513f3db\n--- /dev/null\n+++ b/tests/servers/test_threaded_wsgi_server_db_connections.py\n@@ -0,0 +1,80 @@\n+\"\"\"\n+Tests for database connection handling in ThreadedWSGIServer.\n+\"\"\"\n+import threading\n+import time\n+from urllib.request import urlopen\n+\n+from django.core.servers.basehttp import ThreadedWSGIServer, WSGIServer\n+from django.test import LiveServerTestCase, override_settings\n+from django.test.testcases import LiveServerThread, QuietWSGIRequestHandler\n+\n+from .models import Person\n+\n+\n+class NonThreadedLiveServerThread(LiveServerThread):\n+    \"\"\"LiveServerThread that uses non-threaded WSGIServer.\"\"\"\n+    def _create_server(self):\n+        return WSGIServer(\n+            (self.host, self.port),\n+            QuietWSGIRequestHandler,\n+            allow_reuse_address=False\n+        )\n+\n+\n+class ThreadedLiveServerThread(LiveServerThread):\n+    \"\"\"LiveServerThread that uses ThreadedWSGIServer.\"\"\"\n+    def _create_server(self):\n+        return ThreadedWSGIServer(\n+            (self.host, self.port),\n+            QuietWSGIRequestHandler,\n+            allow_reuse_address=False\n+        )\n+\n+\n+@override_settings(ROOT_URLCONF='servers.urls')\n+class ThreadedWSGIServerConnectionTest(LiveServerTestCase):\n+    \"\"\"Test that reproduces the issue where ThreadedWSGIServer doesn't properly\n+    close database connections.\"\"\"\n+\n+    server_thread_class = ThreadedLiveServerThread\n+    available_apps = ['servers']\n+\n+    def test_threaded_server_db_connections(self):\n+        \"\"\"\n+        Test that concurrent database operations in ThreadedWSGIServer can lead\n+        to database connection issues.\n+        \"\"\"\n+        def db_operation():\n+            \"\"\"Create a Person object in the database.\"\"\"\n+            for _ in range(10):  # Multiple operations to increase race condition chance\n+                Person.objects.create(name='test_person')\n+                time.sleep(0.01)  # Small delay to help trigger the race condition\n+\n+        # Start multiple threads doing database operations\n+        threads = []\n+        for _ in range(5):  # Create multiple threads to increase chance of race condition\n+            thread = threading.Thread(target=db_operation)\n+            thread.daemon = True\n+            threads.append(thread)\n+            thread.start()\n+\n+        # Make some requests to the live server while DB operations are happening\n+        for _ in range(10):\n+            try:\n+                with urlopen(f'{self.live_server_url}/create_model_instance/'):\n+                    pass\n+                time.sleep(0.01)  # Small delay between requests\n+            except Exception:\n+                # We expect some requests might fail due to DB locks\n+                pass\n+\n+        # Wait for all threads to complete\n+        for thread in threads:\n+            thread.join()\n+\n+        # Verify we can still perform database operations\n+        try:\n+            Person.objects.create(name='final_test')\n+        except Exception as e:\n+            self.fail(f\"Database connection issues detected: {e}\")\n\\ No newline at end of file\n",
  "inverted_patch": null
}