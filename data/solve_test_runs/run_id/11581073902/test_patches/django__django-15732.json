{
  "edit_test_file": "tests/invalid_models_tests/test_models.py",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_unique_constraints.py b/tests/invalid_models_tests/test_unique_constraints.py\nnew file mode 100644\nindex 0000000..86a7111\n--- /dev/null\n+++ b/tests/invalid_models_tests/test_unique_constraints.py\n@@ -0,0 +1,31 @@\n+from django.db import connection\n+from django.db import models\n+from django.test import TestCase\n+from django.test.utils import override_settings\n+\n+class UniqueConstraintTests(TestCase):\n+    def test_unique_together_with_unique_field(self):\n+        \"\"\"\n+        Test that having unique_together on a field that already has unique=True\n+        creates duplicate unique constraints.\n+        \"\"\"\n+        class Model(models.Model):\n+            name = models.CharField(max_length=30, unique=True)\n+            \n+            class Meta:\n+                unique_together = (('name',),)\n+\n+        # Get the constraints on the model\n+        with connection.cursor() as cursor:\n+            table_name = Model._meta.db_table\n+            if connection.vendor == 'postgresql':\n+                cursor.execute(\"\"\"\n+                    SELECT COUNT(*) \n+                    FROM pg_constraint \n+                    WHERE conrelid = %s::regclass \n+                    AND contype = 'u'\n+                \"\"\", [table_name])\n+                unique_constraints_count = cursor.fetchone()[0]\n+                \n+                # Should have 2 unique constraints - one from unique=True and one from unique_together\n+                self.assertEqual(unique_constraints_count, 2)\n\\ No newline at end of file\n",
  "inverted_patch": null
}