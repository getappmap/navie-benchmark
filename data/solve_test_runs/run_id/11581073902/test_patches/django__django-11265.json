{
  "edit_test_file": "tests/filtered_relation/tests.py",
  "test_patch": "diff --git a/tests/filtered_relation/test_filtered_relation_exclude.py b/tests/filtered_relation/test_filtered_relation_exclude.py\nnew file mode 100644\nindex 0000000..3093275\n--- /dev/null\n+++ b/tests/filtered_relation/test_filtered_relation_exclude.py\n@@ -0,0 +1,35 @@\n+from django.core.exceptions import FieldError\n+from django.db.models import Q, FilteredRelation\n+from django.test import TestCase\n+\n+from .models import Author, Book, Editor\n+\n+\n+class FilteredRelationExcludeTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.author1 = Author.objects.create(name='Alice')\n+        cls.author2 = Author.objects.create(name='Jane')\n+        cls.editor_a = Editor.objects.create(name='a')\n+        cls.book1 = Book.objects.create(\n+            title='Poem by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+        cls.book2 = Book.objects.create(\n+            title='The book by Jane',\n+            editor=cls.editor_a,\n+            author=cls.author2,\n+        )\n+\n+    def test_exclude_filtered_relation_raises_field_error(self):\n+        \"\"\"\n+        Using exclude() on a queryset with an annotated FilteredRelation raises\n+        a FieldError because the annotation is not properly carried over to the\n+        new query created by split_exclude().\n+        \"\"\"\n+        msg = \"Cannot resolve keyword 'book_alice' into field. Choices are: book, content_object, content_type, content_type_id, favorite_books, id, name, object_id\"\n+        with self.assertRaisesMessage(FieldError, msg):\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/filtered_relation/test_filtered_relation_exclude_inverted.py b/tests/filtered_relation/test_filtered_relation_exclude_inverted.py\nnew file mode 100644\nindex 0000000..16b75c1\n--- /dev/null\n+++ b/tests/filtered_relation/test_filtered_relation_exclude_inverted.py\n@@ -0,0 +1,45 @@\n+from django.test import TestCase\n+from django.db.models import Q, FilteredRelation\n+from .models import Author, Book, Editor\n+\n+\n+class FilteredRelationExcludeTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test data\n+        cls.author1 = Author.objects.create(name='Alice')\n+        cls.author2 = Author.objects.create(name='Jane')\n+        cls.editor_a = Editor.objects.create(name='a')\n+        cls.book1 = Book.objects.create(\n+            title='Poem by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+        cls.book2 = Book.objects.create(\n+            title='The book by Jane',\n+            editor=cls.editor_a,\n+            author=cls.author2,\n+        )\n+\n+    def test_exclude_filtered_relation(self):\n+        \"\"\"\n+        Test that exclude() works correctly with FilteredRelation annotations.\n+        This should return all authors who don't have a book with title 'Poem by Alice'.\n+        \"\"\"\n+        try:\n+            # This query should return [author2] since author1 has 'Poem by Alice'\n+            authors = Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False)\n+\n+            # Verify the result\n+            self.assertEqual(len(authors), 1, \"Expected exactly one author in the result\")\n+            self.assertEqual(\n+                authors[0].name,\n+                'Jane',\n+                \"Expected to get Jane (author2) as she doesn't have 'Poem by Alice'\"\n+            )\n+        except Exception as e:\n+            if 'Cannot resolve keyword' in str(e):\n+                raise AssertionError(\"__BUG__HERE__\") from e\n+            raise  # Re-raise any other exceptions\n"
}