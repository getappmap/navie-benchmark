{
  "edit_test_file": "sklearn/model_selection/tests/test_split.py",
  "test_patch": "diff --git a/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py b/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py\nnew file mode 100644\nindex 0000000..29f0534\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_stratified_kfold_shuffle.py\n@@ -0,0 +1,37 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+from sklearn.utils.testing import assert_array_equal\n+\n+def test_stratified_kfold_shuffle_consistency():\n+    \"\"\"Test that StratifiedKFold with shuffle=True only changes batch order.\n+    \n+    This test verifies that when shuffle=True, the actual sample pairs within\n+    each fold remain consistent (just in different orders) rather than truly\n+    shuffling samples within strata as suggested by the documentation.\n+    \"\"\"\n+    # Create a simple dataset with 10 samples per class\n+    samples_per_class = 10\n+    X = np.linspace(0, samples_per_class * 2 - 1, samples_per_class * 2)\n+    y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)))\n+    \n+    # Get splits with shuffle=False\n+    kf_no_shuffle = StratifiedKFold(n_splits=10, shuffle=False, random_state=1)\n+    splits_no_shuffle = list(kf_no_shuffle.split(X, y))\n+    \n+    # Get splits with shuffle=True and two different random states\n+    kf_shuffle_1 = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)\n+    splits_shuffle_1 = list(kf_shuffle_1.split(X, y))\n+    \n+    kf_shuffle_2 = StratifiedKFold(n_splits=10, shuffle=True, random_state=2)\n+    splits_shuffle_2 = list(kf_shuffle_2.split(X, y))\n+    \n+    # For each fold, verify that the same pairs of indices appear in test sets\n+    # regardless of shuffling, just in different orders\n+    pairs_no_shuffle = {tuple(sorted(test)) for _, test in splits_no_shuffle}\n+    pairs_shuffle_1 = {tuple(sorted(test)) for _, test in splits_shuffle_1}\n+    pairs_shuffle_2 = {tuple(sorted(test)) for _, test in splits_shuffle_2}\n+    \n+    # The sets of pairs should be identical regardless of shuffling\n+    assert_array_equal(len(pairs_no_shuffle), 10)\n+    assert_array_equal(pairs_no_shuffle, pairs_shuffle_1)\n+    assert_array_equal(pairs_shuffle_1, pairs_shuffle_2)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py b/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py\nnew file mode 100644\nindex 0000000..a32a600\n--- /dev/null\n+++ b/sklearn/model_selection/tests/test_stratified_kfold_shuffle_inverted.py\n@@ -0,0 +1,44 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+from sklearn.utils.testing import assert_raises_regex\n+\n+def test_stratified_kfold_shuffle_consistency():\n+    \"\"\"Test that StratifiedKFold with shuffle=True properly shuffles within strata.\n+    \n+    This test verifies that when shuffle=True, the samples within strata are\n+    actually shuffled, rather than just reordering the batches. The test will\n+    fail if the shuffling is not working as documented.\n+    \"\"\"\n+    # Create a simple dataset with 10 samples per class\n+    samples_per_class = 10\n+    X = np.linspace(0, samples_per_class * 2 - 1, samples_per_class * 2)\n+    y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)))\n+    \n+    # Get splits with shuffle=True and two different random states\n+    kf_shuffle_1 = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)\n+    splits_shuffle_1 = list(kf_shuffle_1.split(X, y))\n+    \n+    kf_shuffle_2 = StratifiedKFold(n_splits=10, shuffle=True, random_state=2)\n+    splits_shuffle_2 = list(kf_shuffle_2.split(X, y))\n+    \n+    # Extract test sets and sort them for comparison\n+    test_sets_1 = [tuple(sorted(test)) for _, test in splits_shuffle_1]\n+    test_sets_2 = [tuple(sorted(test)) for _, test in splits_shuffle_2]\n+    \n+    # Convert to sets for comparison\n+    unique_pairs_1 = set(test_sets_1)\n+    unique_pairs_2 = set(test_sets_2)\n+    \n+    # If the sets are equal, it means the shuffling is only reordering batches\n+    # rather than actually shuffling within strata\n+    if unique_pairs_1 == unique_pairs_2:\n+        raise AssertionError(\"__BUG__HERE__\")\n+        \n+    # Additional verification that pairs should be different\n+    # Count how many pairs are identical between the two splits\n+    identical_pairs = sum(1 for pair1, pair2 in zip(sorted(test_sets_1), sorted(test_sets_2)) \n+                         if pair1 == pair2)\n+    \n+    # With proper shuffling, we expect most pairs to be different\n+    if identical_pairs > len(test_sets_1) // 2:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n"
}