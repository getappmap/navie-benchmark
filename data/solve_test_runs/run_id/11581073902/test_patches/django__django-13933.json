{
  "edit_test_file": "tests/forms_tests/tests/test_error_messages.py",
  "test_patch": "diff --git a/tests/forms_tests/tests/test_model_choice_validation.py b/tests/forms_tests/tests/test_model_choice_validation.py\nnew file mode 100644\nindex 0000000..7d40d70\n--- /dev/null\n+++ b/tests/forms_tests/tests/test_model_choice_validation.py\n@@ -0,0 +1,43 @@\n+from django.core.exceptions import ValidationError\n+from django.forms import ModelChoiceField, ChoiceField\n+from django.test import TestCase\n+\n+from ..models import ChoiceModel\n+\n+\n+class ModelChoiceFieldValidationTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.c1 = ChoiceModel.objects.create(name='a')\n+        cls.c2 = ChoiceModel.objects.create(name='b')\n+        cls.c3 = ChoiceModel.objects.create(name='c')\n+\n+    def test_invalid_choice_error_message_difference(self):\n+        \"\"\"\n+        Test that ModelChoiceField, unlike ChoiceField, does not include\n+        the invalid value in its validation error message.\n+        \"\"\"\n+        # Regular ChoiceField includes the invalid value in error message\n+        choice_field = ChoiceField(choices=[\n+            (self.c1.pk, 'a'),\n+            (self.c2.pk, 'b'),\n+            (self.c3.pk, 'c'),\n+        ])\n+        invalid_value = '999'\n+\n+        with self.assertRaisesMessage(\n+            ValidationError,\n+            'Select a valid choice. 999 is not one of the available choices.'\n+        ):\n+            choice_field.clean(invalid_value)\n+\n+        # ModelChoiceField does not include the invalid value\n+        model_choice_field = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all()\n+        )\n+\n+        with self.assertRaisesMessage(\n+            ValidationError,\n+            'Select a valid choice. That choice is not one of the available choices.'\n+        ):\n+            model_choice_field.clean(invalid_value)\n\\ No newline at end of file\n",
  "inverted_patch": "diff --git a/tests/forms_tests/tests/test_model_choice_validation_inverted.py b/tests/forms_tests/tests/test_model_choice_validation_inverted.py\nnew file mode 100644\nindex 0000000..26df187\n--- /dev/null\n+++ b/tests/forms_tests/tests/test_model_choice_validation_inverted.py\n@@ -0,0 +1,34 @@\n+from django.core.exceptions import ValidationError\n+from django.forms import ModelChoiceField, ChoiceField\n+from django.test import TestCase\n+\n+from ..models import ChoiceModel\n+\n+\n+class ModelChoiceFieldValidationTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.c1 = ChoiceModel.objects.create(name='a')\n+        cls.c2 = ChoiceModel.objects.create(name='b')\n+        cls.c3 = ChoiceModel.objects.create(name='c')\n+\n+    def test_invalid_choice_error_message_should_include_value(self):\n+        \"\"\"\n+        Test that ModelChoiceField should include the invalid value in its\n+        validation error message, similar to ChoiceField.\n+        \"\"\"\n+        invalid_value = '999'\n+        model_choice_field = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all()\n+        )\n+\n+        try:\n+            model_choice_field.clean(invalid_value)\n+        except ValidationError as e:\n+            error_message = str(e.message)\n+            expected_text = f\"Select a valid choice. {invalid_value} is not one of the available choices.\"\n+            \n+            if error_message != expected_text:\n+                raise AssertionError(\"__BUG__HERE__\")\n+        else:\n+            self.fail(\"ValidationError was not raised\")\n\\ No newline at end of file\n"
}