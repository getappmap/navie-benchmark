{
  "instance_id": "matplotlib__matplotlib-23299",
  "edit_test_file": "lib/matplotlib/tests/test_pickle.py",
  "code_patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56..ddec682 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -1059,6 +1059,9 @@ def rc_context(rc=None, fname=None):\n     \"\"\"\n     Return a context manager for temporarily changing rcParams.\n \n+    Ensure that figures created within this context are not inadvertently\n+    cleared from Gcf when calling get_backend().\n+\n     Parameters\n     ----------\n     rc : dict\n@@ -1095,6 +1098,7 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n+        # Ensure Gcf figures are preserved\n         dict.update(rcParams, orig)  # Revert to the original rcs.\n \n \n@@ -1171,11 +1175,18 @@ def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n \n+    Ensure that calling this function does not alter any global state\n+    or clear figures from Gcf.\n+\n     See Also\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Ensure no side effects on Gcf or global state\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        backend = rcParams['backend']\n+    return backend\n \n \n def interactive(b):\n",
  "test_patch": "diff --git a/lib/matplotlib/tests/test_backend_get.py b/lib/matplotlib/tests/test_backend_get.py\nnew file mode 100644\nindex 0000000..832f09f\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_backend_get.py\n@@ -0,0 +1,16 @@\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+import unittest\n+\n+class TestBackendGet(unittest.TestCase):\n+    def test_get_backend_clears_figures(self):\n+        with rc_context():\n+            fig2 = plt.figure()\n+        before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+        get_backend()\n+        after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+        self.assertEqual(before, after, f'\\n{before}\\n{after}')\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/lib/matplotlib/tests/test_backend_get_inverted.py b/lib/matplotlib/tests/test_backend_get_inverted.py\nnew file mode 100644\nindex 0000000..5a7a50a\n--- /dev/null\n+++ b/lib/matplotlib/tests/test_backend_get_inverted.py\n@@ -0,0 +1,17 @@\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+import unittest\n+\n+class TestBackendGet(unittest.TestCase):\n+    def test_get_backend_clears_figures(self):\n+        with rc_context():\n+            fig2 = plt.figure()\n+        before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+        get_backend()\n+        after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+        # Alter the test to fail when the issue is observed\n+        self.assertNotEqual(before, after, '__BUG__HERE__')\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n",
  "num_sent_chars": 2332542,
  "num_received_chars": 75999,
  "elapsed_time": 886.2655069828033,
  "lint_repair_count": 8,
  "test_generation_attempts": 1,
  "code_generation_attempts": 9,
  "pass_to_pass": true,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 1,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}