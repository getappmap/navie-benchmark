{
  "instance_id": "django__django-14580",
  "edit_test_file": null,
  "code_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 2848adc..5de6319 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -115,6 +115,7 @@ class MigrationAutodetector:\n         graph is an optional argument that, if provided, can help improve\n         dependency generation and avoid potential circular dependencies.\n         \"\"\"\n+        self.import_statements = set()\n         # The first phase is generating all the operations for each app\n         # and gathering them into a big per-app list.\n         # Then go through that list, order it, and split into migrations to\n@@ -435,6 +436,7 @@ class MigrationAutodetector:\n             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n         else:\n             self.generated_operations.setdefault(app_label, []).append(operation)\n+        self.ensure_imports_for_operation(operation)\n \n     def swappable_first_key(self, item):\n         \"\"\"\n@@ -523,6 +525,7 @@ class MigrationAutodetector:\n         Defer any model options that refer to collections of fields that might\n         be deferred (e.g. unique_together, index_together).\n         \"\"\"\n+        self.ensure_imports_for_bases()\n         old_keys = self.old_model_keys | self.old_unmanaged_keys\n         added_models = self.new_model_keys - old_keys\n         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 2463925,
  "num_received_chars": 123574,
  "elapsed_time": 665.5083038806915,
  "lint_repair_count": 6,
  "test_generation_attempts": 9,
  "code_generation_attempts": 4,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}