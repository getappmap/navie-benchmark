{
  "instance_id": "sphinx-doc__sphinx-7590",
  "edit_test_file": null,
  "code_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d88..981f446 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -4644,27 +4644,33 @@ class DefinitionParser(BaseParser):\n         return self.definition[startPos:self.pos]\n \n     def _parse_literal(self) -> ASTLiteral:\n-        # -> integer-literal\n-        #  | character-literal\n-        #  | floating-literal\n-        #  | string-literal\n-        #  | boolean-literal -> \"false\" | \"true\"\n-        #  | pointer-literal -> \"nullptr\"\n-        #  | user-defined-literal\n-        self.skip_ws()\n-        if self.skip_word('nullptr'):\n-            return ASTPointerLiteral()\n-        if self.skip_word('true'):\n-            return ASTBooleanLiteral(True)\n-        if self.skip_word('false'):\n-            return ASTBooleanLiteral(False)\n-        for regex in [float_literal_re, binary_literal_re, hex_literal_re,\n-                      integer_literal_re, octal_literal_re]:\n-            pos = self.pos\n-            if self.match(regex):\n-                while self.current_char in 'uUlLfF':\n-                    self.pos += 1\n-                return ASTNumberLiteral(self.definition[pos:self.pos])\n+            # -> integer-literal\n+            #  | character-literal\n+            #  | floating-literal\n+            #  | string-literal\n+            #  | boolean-literal -> \"false\" | \"true\"\n+            #  | pointer-literal -> \"nullptr\"\n+            #  | user-defined-literal\n+            self.skip_ws()\n+            if self.skip_word('nullptr'):\n+                return ASTPointerLiteral()\n+            if self.skip_word('true'):\n+                return ASTBooleanLiteral(True)\n+            if self.skip_word('false'):\n+                return ASTBooleanLiteral(False)\n+            for regex in [float_literal_re, binary_literal_re, hex_literal_re,\n+                          integer_literal_re, octal_literal_re]:\n+                pos = self.pos\n+                if self.match(regex):\n+                    while self.current_char in 'uUlLfF':\n+                        self.pos += 1\n+                    # Check for user-defined literal suffix\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if self.match(identifier_re):\n+                            identifier = ASTIdentifier(self.matched_text)\n+                            return ASTOperatorLiteral(identifier)\n+                    return ASTNumberLiteral(self.definition[pos:self.pos])\n \n         string = self._parse_string()\n         if string is not None:\n@@ -4745,27 +4751,27 @@ class DefinitionParser(BaseParser):\n         return ASTFoldExpr(leftExpr, op, rightExpr)\n \n     def _parse_primary_expression(self) -> ASTExpression:\n-        # literal\n-        # \"this\"\n-        # lambda-expression\n-        # \"(\" expression \")\"\n-        # fold-expression\n-        # id-expression -> we parse this with _parse_nested_name\n-        self.skip_ws()\n-        res = self._parse_literal()  # type: ASTExpression\n-        if res is not None:\n-            return res\n-        self.skip_ws()\n-        if self.skip_word(\"this\"):\n-            return ASTThisLiteral()\n-        # TODO: try lambda expression\n-        res = self._parse_fold_or_paren_expression()\n-        if res is not None:\n-            return res\n-        nn = self._parse_nested_name()\n-        if nn is not None:\n-            return ASTIdExpression(nn)\n-        return None\n+            # literal\n+            # \"this\"\n+            # lambda-expression\n+            # \"(\" expression \")\"\n+            # fold-expression\n+            # id-expression -> we parse this with _parse_nested_name\n+            self.skip_ws()\n+            res = self._parse_literal()  # type: ASTExpression\n+            if res is not None:\n+                return res\n+            self.skip_ws()\n+            if self.skip_word(\"this\"):\n+                return ASTThisLiteral()\n+            # TODO: try lambda expression\n+            res = self._parse_fold_or_paren_expression()\n+            if res is not None:\n+                return res\n+            nn = self._parse_nested_name()\n+            if nn is not None:\n+                return ASTIdExpression(nn)\n+            return None\n \n     def _parse_initializer_list(self, name: str, open: str, close: str\n                                 ) -> Tuple[List[Union[ASTExpression,\n",
  "test_patch": null,
  "test_inverted_patch": null,
  "num_sent_chars": 3271202,
  "num_received_chars": 48637,
  "elapsed_time": 499.1470992565155,
  "lint_repair_count": 1,
  "test_generation_attempts": 9,
  "code_generation_attempts": 5,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}