{
  "instance_id": "sympy__sympy-12481",
  "edit_test_file": "sympy/combinatorics/tests/test_permutations.py",
  "code_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 136ed5a..30c7708 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -801,8 +801,8 @@ class Permutation(Basic):\n     def __new__(cls, *args, **kwargs):\n         \"\"\"\n         Constructor for the Permutation object from a list or a\n-        list of lists in which all elements of the permutation may\n-        appear only once.\n+        list of lists. If cycles are provided, they are applied\n+        sequentially to form the final permutation.\n \n         Examples\n         ========\n@@ -871,12 +871,12 @@ def __new__(cls, *args, **kwargs):\n             if not is_sequence(a):  # b\n                 return _af_new(list(range(a + 1)))\n             if has_variety(is_sequence(ai) for ai in a):\n-                ok = False\n-        else:\n-            ok = False\n-        if not ok:\n-            raise ValueError(\"Permutation argument must be a list of ints, \"\n-                             \"a list of lists, Permutation or Cycle.\")\n+                # Process non-disjoint cycles sequentially\n+                perm = list(range(size or max(flatten(a)) + 1))\n+                for cycle in a:\n+                    for i in range(len(cycle) - 1):\n+                        perm[cycle[i]], perm[cycle[i + 1]] = perm[cycle[i + 1]], perm[cycle[i]]\n+                return _af_new(perm)\n \n \n         # safe to assume args are valid; this also makes a copy\n",
  "test_patch": "diff --git a/sympy/combinatorics/tests/test_cycle_order.py b/sympy/combinatorics/tests/test_cycle_order.py\nnew file mode 100644\nindex 0000000..a82d593\n--- /dev/null\n+++ b/sympy/combinatorics/tests/test_cycle_order.py\n@@ -0,0 +1,6 @@\n+from sympy.combinatorics.permutations import Permutation\n+from sympy.utilities.pytest import raises\n+\n+def test_non_disjoint_cycles():\n+    # This test reproduces the issue where non-disjoint cycles raise a ValueError\n+    raises(ValueError, lambda: Permutation([[0, 1], [0, 1]]))\n\\ No newline at end of file\n",
  "test_inverted_patch": "diff --git a/sympy/combinatorics/tests/test_cycle_order_inverted.py b/sympy/combinatorics/tests/test_cycle_order_inverted.py\nnew file mode 100644\nindex 0000000..fa1342c\n--- /dev/null\n+++ b/sympy/combinatorics/tests/test_cycle_order_inverted.py\n@@ -0,0 +1,8 @@\n+from sympy.combinatorics.permutations import Permutation\n+\n+def test_non_disjoint_cycles():\n+    # This test should fail when the issue is observed\n+    try:\n+        Permutation([[0, 1], [0, 1]])\n+    except ValueError:\n+        raise AssertionError(\"__BUG__HERE__\")\n\\ No newline at end of file\n",
  "num_sent_chars": 669708,
  "num_received_chars": 16360,
  "elapsed_time": 202.02970838546753,
  "lint_repair_count": 0,
  "test_generation_attempts": 1,
  "code_generation_attempts": 3,
  "pass_to_pass": false,
  "pass_to_fail": false,
  "fail_to_pass": false,
  "code_patch_score": 0,
  "appmap_data_test_status": null,
  "appmap_data_file_count": null,
  "appmap_data_context_size": null
}